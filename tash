[1mdiff --git a/server/src/AS/DB/API.hs b/server/src/AS/DB/API.hs[m
[1mindex 25ac752..676c746 100644[m
[1m--- a/server/src/AS/DB/API.hs[m
[1m+++ b/server/src/AS/DB/API.hs[m
[36m@@ -411,14 +411,14 @@[m [mgetVolatileLocs conn = do[m
 -- TODO: some of the cells may change from volatile -> not volatile, but they're still in volLocs[m
 setChunkVolatileCells :: [ASCell] -> Redis ()[m
 setChunkVolatileCells cells = do[m
[31m-  let vLocs = map cellLocation $ filter ((hasProp VolatileProp) . cellProps) cells[m
[32m+[m[32m  let vLocs = map cellLocation $ filter ((hasPropType VolatileProp) . cellProps) cells[m
   let locStrs = map (B.pack . show) vLocs[m
   sadd "volatileLocs" locStrs[m
   return ()[m
 [m
 deleteChunkVolatileCells :: [ASCell] -> Redis ()[m
 deleteChunkVolatileCells cells = do[m
[31m-  let vLocs = map cellLocation $ filter ((hasProp VolatileProp) . cellProps) cells[m
[32m+[m[32m  let vLocs = map cellLocation $ filter ((hasPropType VolatileProp) . cellProps) cells[m
   let locStrs = map (B.pack . show) vLocs[m
   srem "volatileLocs" locStrs[m
   return ()[m
[1mdiff --git a/server/src/AS/Daemon.hs b/server/src/AS/Daemon.hs[m
[1mindex 0455fff..0113f7b 100644[m
[1m--- a/server/src/AS/Daemon.hs[m
[1m+++ b/server/src/AS/Daemon.hs[m
[36m@@ -56,7 +56,7 @@[m [mgetStreamPropFromExpression _ = Nothing[m
 possiblyCreateDaemon :: MVar ServerState -> ASUserId -> ASCell -> IO ()[m
 possiblyCreateDaemon state owner cell@(Cell loc xp val props) = do [m
   let msg = ClientMessage Evaluate (PayloadCL [cell])[m
[31m-  case getProp StreamInfoProp props of [m
[32m+[m[32m  case getProp props StreamInfoProp of[m[41m [m
     Nothing -> do [m
       let maybeTag = getStreamPropFromExpression xp[m
       case maybeTag of [m
[1mdiff --git a/server/src/AS/Dispatch/Core.hs b/server/src/AS/Dispatch/Core.hs[m
[1mindex e221ece..c3af144 100644[m
[1m--- a/server/src/AS/Dispatch/Core.hs[m
[1m+++ b/server/src/AS/Dispatch/Core.hs[m
[36m@@ -248,7 +248,7 @@[m [mevalChain' conn valuesMap (c@(Cell loc xp oldVal ts):cs) fatCells fatCellHeads p[m
     -- where "get rid of cruft" = get rid of all the non-head cells first, which is deletedCells[m
     Coupled str lang _ key -> if (DU.isFatCellHead c)[m
       then (,) <$> evalResult <*> return decoupleLocs[m
[31m-      else (,) <$> (return $ Formatted (CellValue oldVal) (formatType <$> getProp ValueFormatProp ts)) <*> return [] -- temporary patch -- eval needs to get restructured[m
[32m+[m[32m      else (,) <$> (return $ Formatted (CellValue oldVal) (formatType <$> getProp ts ValueFormatProp)) <*> return [] -- temporary patch -- eval needs to get restructured[m
         where evalResult = EC.evaluateLanguage conn (locSheetId loc) (cellLocation c) valuesMap xp'[m
               xp' = Expression str lang[m
               decoupleLocs = DU.rangeKeyToIndices key[m
[1mdiff --git a/server/src/AS/Eval/CondFormat.hs b/server/src/AS/Eval/CondFormat.hs[m
[1mindex 9592478..21bb9e0 100644[m
[1m--- a/server/src/AS/Eval/CondFormat.hs[m
[1m+++ b/server/src/AS/Eval/CondFormat.hs[m
[36m@@ -48,7 +48,7 @@[m [mmeetsCondition conn sid valMap xp@(Expression str lang) v = do[m
       depInds = concat $ catMaybes depSets[m
       depIndsToGet = filter (not . (flip M.member) valMap) depInds[m
   cells <- lift $ DB.getPossiblyBlankCells depIndsToGet[m
[31m-  let getFormat = \ps -> formatType <$> getProp ValueFormatProp ps[m
[32m+[m[32m  let getFormat = \ps -> formatType <$> getProp ps ValueFormatProp[m
       valMapToMerge = map (\(Cell l _ v ps) -> (l, Formatted (CellValue v) $ getFormat ps)) cells[m
       valMap' = M.union valMap (M.fromList valMapToMerge)[m
   (Formatted res _) <- evaluateLanguage conn sid dummyLoc valMap' xp[m
[1mdiff --git a/server/src/AS/Handlers/Misc.hs b/server/src/AS/Handlers/Misc.hs[m
[1mindex df4d5f3..14814bb 100644[m
[1m--- a/server/src/AS/Handlers/Misc.hs[m
[1m+++ b/server/src/AS/Handlers/Misc.hs[m
[36m@@ -128,8 +128,12 @@[m [mhandleDelete uc state p@(PayloadWB workbook) = do[m
   return ()[m
 handleDelete uc state (PayloadR rng) = do[m
   let locs = rangeToIndices rng[m
[32m+[m[32m      formatsToClear = [ValueFormat Date][m
[32m+[m[32m      -- ^ Deleting a cell keeps some of the formats but deletes others. This is the current list of[m
[32m+[m[32m      -- formats to remove upon deletion.[m[41m [m
   conn <- dbConn <$> readMVar state[m
[31m-  blankedCells <- DB.getBlankedCellsAt locs[m
[32m+[m[32m  blankedCells <- DB.getBlankedCellsAt locs -- need to know the formats at the old locations[m
[32m+[m[32m  let blankedCells' =[m[41m [m
   updateMsg <- DP.runDispatchCycle state blankedCells (userCommitSource uc)[m
   let msg = makeDeleteMessage rng updateMsg[m
   case (serverResult msg) of[m
[1mdiff --git a/server/src/AS/Handlers/Props.hs b/server/src/AS/Handlers/Props.hs[m
[1mindex aa27acb..7617c2c 100644[m
[1m--- a/server/src/AS/Handlers/Props.hs[m
[1m+++ b/server/src/AS/Handlers/Props.hs[m
[36m@@ -20,7 +20,7 @@[m [mhandleToggleProp uc state (PayloadProp p rng) = do[m
   let locs = rangeToIndices rng[m
       pt   =  propType p[m
   cells <- getPossiblyBlankCells locs[m
[31m-  let (cellsWithProp, cellsWithoutProp) = partition ((hasProp pt) . cellProps) cells[m
[32m+[m[32m  let (cellsWithProp, cellsWithoutProp) = partition ((hasPropType pt) . cellProps) cells[m
   -- if there's a single prop present in the range, remove this prop from all the cells; [m
   -- otherwise set the prop in all the cells. [m
   if (null cellsWithoutProp)[m
[1mdiff --git a/server/src/AS/Types/Cell.hs b/server/src/AS/Types/Cell.hs[m
[1mindex 1d3b980..798f85d 100644[m
[1m--- a/server/src/AS/Types/Cell.hs[m
[1m+++ b/server/src/AS/Types/Cell.hs[m
[36m@@ -129,7 +129,7 @@[m [mpartitionByRangeKey cells keys = liftListTuple $ map (go cells) keys[m
         liftListTuple t = (concat $ map fst t, concat $ map snd t)[m
 [m
 getCellFormatType :: ASCell -> Maybe FormatType[m
[31m-getCellFormatType (Cell _ _ _ props) = maybe Nothing (Just . formatType) $ getProp ValueFormatProp props[m
[32m+[m[32mgetCellFormatType (Cell _ _ _ props) = maybe Nothing (Just . formatType) $ getProp props ValueFormatProp[m
 [m
 execErrorToValueError :: ASExecError -> ASValue[m
 execErrorToValueError e = ValueError (show e) "Exec error"[m
\ No newline at end of file[m
[1mdiff --git a/server/src/AS/Types/CellProps.hs b/server/src/AS/Types/CellProps.hs[m
[1mindex 4d11064..0639c98 100644[m
[1m--- a/server/src/AS/Types/CellProps.hs[m
[1m+++ b/server/src/AS/Types/CellProps.hs[m
[36m@@ -60,8 +60,11 @@[m [minstance Eq ASCellProps where[m
 getProp :: CellPropType -> ASCellProps -> Maybe CellProp[m
 getProp pt (ASCellProps m cm) = listToMaybe $ catMaybes $ [M.lookup pt cm, M.lookup pt m][m
 [m
[31m-hasProp :: CellPropType -> ASCellProps -> Bool[m
[31m-hasProp pt p = isJust $ getProp pt p[m
[32m+[m[32mhasPropType :: CellPropType -> ASCellProps -> Bool[m
[32m+[m[32mhasPropType pt p = isJust $ getProp pt p[m
[32m+[m
[32m+[m[32mhasProp :: CellProp -> ASCellProps -> Bool[m
[32m+[m[32mhasProp p ps = (getProp (propType p) ps) == Just p[m
 [m
 propType :: CellProp -> CellPropType[m
 propType (TextColor _) = TextColorProp[m
[1mdiff --git a/server/src/AS/Types/Excel.hs b/server/src/AS/Types/Excel.hs[m
[1mindex 3c9362d..d754aac 100644[m
[1m--- a/server/src/AS/Types/Excel.hs[m
[1m+++ b/server/src/AS/Types/Excel.hs[m
[36m@@ -196,15 +196,10 @@[m [minstance Ord EValue where[m
   (<=) v (EValueB False) = (<=) v (EValueNum $ return (EValueI 0))[m
   (<=) (EValueNum (Formatted n1 _)) (EValueNum (Formatted n2 _)) = (<=) n1 n2[m
   (<=) (EValueS s1) (EValueS s2) = (<=) s1 s2[m
[31m-  (<=) (EValueS s) (EValueNum n) = (<=) (strToEValueNum s) (EValueNum n)[m
[31m-  (<=) (EValueNum n) (EValueS s) = (<=) (EValueNum n) (strToEValueNum s)[m
[32m+[m[32m  (<=) (EValueS s) (EValueNum n) = False[m
[32m+[m[32m  (<=) (EValueNum n) (EValueS s) = True[m
   (<=) _ _ = error "Invalid comparison" [m
 [m
[31m-strToEValueNum :: String -> EValue[m
[31m-strToEValueNum str = case (readMaybe str :: Maybe Double) of [m
[31m-  Just d -> EValueNum $ return $ EValueD d[m
[31m-  Nothing -> error "Failed to convert string to number"[m
[31m-[m
 data EMatrix = EMatrix {emCols :: !Int, emRows :: !Int, content :: !(V.Vector EValue)}[m
   deriving (Show, Eq)[m
 data EEntity =[m
[1mdiff --git a/server/src/AS/Types/RowColProps.hs b/server/src/AS/Types/RowColProps.hs[m
[1mindex ff08577..62170a2 100644[m
[1m--- a/server/src/AS/Types/RowColProps.hs[m
[1m+++ b/server/src/AS/Types/RowColProps.hs[m
[36m@@ -46,8 +46,8 @@[m [memptyProps = ASRowColProps M.empty[m
 -- getProp :: RowColPropType -> ASRowColProps -> Maybe RowColProp[m
 -- getProp pt (ASRowColProps m) = M.lookup pt m[m
 [m
[31m--- hasProp :: RowColPropType -> ASRowColProps -> Bool[m
[31m--- hasProp pt p = isJust $ getProp pt p[m
[32m+[m[32m-- hasPropType :: RowColPropType -> ASRowColProps -> Bool[m
[32m+[m[32m-- hasPropType pt p = isJust $ getProp pt p[m
 [m
 -- removeProp :: RowColPropType -> ASRowColProps -> ASRowColProps[m
 -- removeProp pt (ASRowColProps m) = ASRowColProps $ M.delete pt m[m
