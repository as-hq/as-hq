
==================== FINAL INTERFACE ====================
2015-08-20 07:09:06.344469 UTC

interface alphasheets-0.1.0.0:AS.Parsing.Out 7084
  interface hash: 8c90ad10f4e5e1da986e29b1ac1f6934
  ABI hash: fba6f9deafe016118fae642fb99574ed
  export-list hash: a35a850caac02fe781c1c3ce3af3ec40
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 01dbfe2a4bc4387a8d0369737a5dc5cb
  used TH splices: False
  where
exports:
  AS.Parsing.Out.bool
  AS.Parsing.Out.colStrToInt
  AS.Parsing.Out.colon
  AS.Parsing.Out.dependenciesFromExceLLoc
  AS.Parsing.Out.dollar
  AS.Parsing.Out.exLocToASLocation
  AS.Parsing.Out.exLocToString
  AS.Parsing.Out.exc
  AS.Parsing.Out.excelMatch
  AS.Parsing.Out.getBlockDelim
  AS.Parsing.Out.getDependencies
  AS.Parsing.Out.getDependenciesAndExpressions
  AS.Parsing.Out.getInlineDelim
  AS.Parsing.Out.getMatchesWithContext
  AS.Parsing.Out.indexMatch
  AS.Parsing.Out.indexToExcel
  AS.Parsing.Out.intToColStr
  AS.Parsing.Out.jsonDeserialize
  AS.Parsing.Out.modifiedLists
  AS.Parsing.Out.parseMatches
  AS.Parsing.Out.parseMatchesWithContext
  AS.Parsing.Out.parseNext
  AS.Parsing.Out.rangeMatch
  AS.Parsing.Out.replaceMatches
  AS.Parsing.Out.sheetMatch
  AS.Parsing.Out.sheetRefMatch
  AS.Parsing.Out.shiftExLoc
  AS.Parsing.Out.shiftExLocs
  AS.Parsing.Out.showFilteredValue
  AS.Parsing.Out.showValue
  AS.Parsing.Out.toListStr
  AS.Parsing.Out.unpackExcelExprs
  AS.Parsing.Out.unpackExcelLocs
  AS.Parsing.Out.unpackExcelVals
module dependencies: AS.Parsing.Common AS.Types
package dependencies: SHA-1.6.4.2 aeson-0.8.0.2 array-0.5.0.0
                      attoparsec-0.12.1.6 base base64-bytestring-1.0.0.1 binary-0.7.1.0
                      blaze-builder-0.4.0.1 bytestring-0.10.4.0 case-insensitive-1.2.0.4
                      containers-0.5.5.1 deepseq-1.3.0.2 dlist-0.7.1.1 entropy-0.3.7
                      ghc-prim hashable-1.2.3.3 integer-gmp mtl-2.1.3.1 network-2.6.2.0
                      old-locale-1.0.0.6 parsec-3.1.9 primitive-0.6 random-1.1
                      regex-base-0.93.2 regex-posix-0.95.2 scientific-0.3.3.8
                      text-1.2.0.6 time-1.4.2 transformers-0.3.0.0 unix-2.7.0.1
                      unordered-containers-0.2.5.1 vector-0.10.12.3 websockets-0.9.5.0
orphans: aeson-0.8.0.2:Data.Aeson.Types.Generic
         aeson-0.8.0.2:Data.Aeson.Types.Instances
         aeson-0.8.0.2:Data.Aeson.Types.Internal
         attoparsec-0.12.1.6:Data.Attoparsec.ByteString.Char8 base:GHC.Base
         base:GHC.Float base:GHC.Real binary-0.7.1.0:Data.Binary.Generic
         bytestring-0.10.4.0:Data.ByteString.Builder
         hashable-1.2.3.3:Data.Hashable.Generic
         network-2.6.2.0:Network.Socket network-2.6.2.0:Network.Socket.Types
         random-1.1:System.Random regex-base-0.93.2:Text.Regex.Base.Context
         regex-posix-0.95.2:Text.Regex.Posix.ByteString
         regex-posix-0.95.2:Text.Regex.Posix.ByteString.Lazy
         regex-posix-0.95.2:Text.Regex.Posix.Sequence
         regex-posix-0.95.2:Text.Regex.Posix.String text-1.2.0.6:Data.Text
         text-1.2.0.6:Data.Text.Lazy time-1.4.2:Data.Time.Calendar.Gregorian
         time-1.4.2:Data.Time.Format.Parse
         time-1.4.2:Data.Time.LocalTime.LocalTime
         transformers-0.3.0.0:Control.Monad.Trans.Error
         vector-0.10.12.3:Data.Vector.Fusion.Stream
         vector-0.10.12.3:Data.Vector.Unboxed
family instance modules: alphasheets-0.1.0.0:AS.Types
                         attoparsec-0.12.1.6:Data.Attoparsec.Internal.Types
                         base:Control.Applicative base:Data.Either base:Data.Monoid
                         base:Data.Type.Equality base:GHC.Exts base:GHC.Generics
                         dlist-0.7.1.1:Data.DList primitive-0.6:Control.Monad.Primitive
                         text-1.2.0.6:Data.Text text-1.2.0.6:Data.Text.Lazy
                         unordered-containers-0.2.5.1:Data.HashMap.Base
                         unordered-containers-0.2.5.1:Data.HashSet
                         vector-0.10.12.3:Data.Vector vector-0.10.12.3:Data.Vector.Primitive
                         vector-0.10.12.3:Data.Vector.Storable
                         vector-0.10.12.3:Data.Vector.Unboxed
                         vector-0.10.12.3:Data.Vector.Unboxed.Base
import  -/  AS.Parsing.Common 2fdb05fa6cb85dd95bd00704eb6e020b
  exports: 6373d90a9aaddcd2d18cba04a491c26c
  decomposeLocs a187d4df91fa5ae9a88d3b5f9b361b23
  normalizeRanges b84908553215ac552bf2a4817a63c514
import  -/  AS.Types b606c3629b6c721cf8b97ba4ece45fb1
  exports: 66ecab93115eea25472e439473866aa8
  ASExpression 202fe15cb9625b3476a51d6a1b19686c
  ASLanguage fe64043cb1e3f3d06f3bab2e586b8c96
  ASLocation c3999fef437ba89bfafc0ba56adaa4e1
  ASValue b1acb5fd16e89609b5c353aa6b20e24f
  CPP 7e9bafe0a3280af8bc293e73f2f8dc97
  DisplayValue 66dc853e726e30545fb05775cbf1241e
  ExIndex 10af0d2cbc45debd5deca5449bd54100
  ExLoc 5733d884981255bd53b7dc4f99414708
  ExRange f81806d4435b7a8b23cf506267646c46
  ExSheet 03b19d60702443f36c72a14fd99c5971
  Excel 6f0c1e795df7563c73906c63f4a7551d
  Expression d3eb52f5348f449ca41cbf92f7270c44
  Index a3a1c51a9db8b7858642af330a1e8ef6
  Java 9b21b67372c2a409574e39e3678c1240
  OCaml 60aba87dc36e4bf82b5b1cf38a91c070
  ObjectValue cd9e69317277b20ea39898bc831da919
  Python ce1f286eba669d7c31d15d8f4f9ce369
  R e5aa1ec8867b6c49c3d01a9d514fc432
  Range 1e8bee9c012b2f09e1603d7cb28278d0
  SQL 1d65d8106d848b73ade1a7081249b16b
  Sheet 4a8ba79abcb864e6bd656f5f2f0848a1
  StyledValue 04e7cc38f7557e5fd95dea3932d8371e
  ValueB 73540a017cc72f8cc2349e05165d22ef
  ValueD 5c335f4d2e77df69f43e9b158f338ba5
  ValueI a31c28b7c7ba3bf5a85821fcab0b4d16
  ValueL 7f6bc38d21b476842e803fe228ce3ebe
  ValueNaN c159794a3c490d098a34c71805955413
  ValueS ca16720e7303fc40a036682a9da10488
  col aa8c9cc04ebc0bf1e46bcfa76c670702
  dbl ae362e08e10a56e9e988c119bfb50903
  expression bb46e6eaff36b352d59123812921fd83
  index 769cf76d5c23d47c50b5dfb83aeaa33e
  language a464de82425c95b8fe43de0f0debbb43
  lst 90b068cb6723e6cf98b5e81cfba84c1b
  row 8fb61fe7faa3d67ea54bc18d9dd381db
  sheet 1fcb782c33118e138886e0efce286836
  sheetId 0c4bccad93176d85b6fd47db3d6383e3
  str 90e5d5ff41315975dbd5ca1645525b48
import  -/  base:Control.Applicative 30b769206cb5c020684e1bda0d7e7dd3
import  -/  base:Data.Char 1ace810ea04187cd227c9ed982bb7d15
import  -/  base:Data.Either d1c890129a7c6a9ec02a642c6c2f4ed3
import  -/  base:Data.List 8b77870d02d66076337587b759b7ee19
import  -/  base:Data.Maybe 5034d40e23c3a7110309f188001df4ca
import  -/  base:Data.Tuple cac4e06c48274e85317bd3e59867ef5b
import  -/  base:GHC.Base 5d7c5f596f9a4c8a8abd8517c8bcd5dd
import  -/  base:GHC.List 4cff382327e59a5787355ca0a4174450
import  -/  base:GHC.Num 5e7786970581cacc802bf850d458a30b
import  -/  base:GHC.Real 35345ccdfd774068d1f4418df87bd3c9
import  -/  base:GHC.Show cf1a7ff9edb0f41528085aad04d33753
import  -/  base:GHC.Unicode 328b8e1d86fa0b0f8b798c018561e9b0
import  -/  base:Prelude 74043f272d60acec1777d3461cfe5ef4
import  -/  base:Text.Read 6fe10a0a6d0a38c215de3b09e72ca556
import  -/  containers-0.5.5.1:Data.Map 39e9346954b9366e01d2c8afb617e216
import  -/  ghc-prim:GHC.Classes 3e6cbe1e7e80480408cfa8d5450726a0
import  -/  parsec-3.1.9:Text.Parsec 62fd9a2906998e77f1ce16ddb8634d92
import  -/  parsec-3.1.9:Text.Parsec.Char ee0a2ace2ba83101bc4a2dfa34c0dd1b
import  -/  parsec-3.1.9:Text.Parsec.Combinator 45d464160f5a747c34cf8cd2718e5dd5
import  -/  parsec-3.1.9:Text.Parsec.Prim 43645ebeb33f25a8e29d51fba3329d0e
import  -/  parsec-3.1.9:Text.Parsec.Text 67fd77fda74c32335fc9086dab2a7fd6
import  -/  regex-posix-0.95.2:Text.Regex.Posix ac2bb8a4caf67648cfb9326fa3deedd9
import  -/  text-1.2.0.6:Data.Text 0a4e6ca8ca412aa3cbc86c5bc7204623
import  -/  text-1.2.0.6:Data.Text.Lazy e143c21d39ea2c2a2b33f7cef87568ee
da571f03b895fef3beab469f8b12cfe3
  $wa :: Text.Parsec.Text.Parser t
         -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
            -> ([t]
                -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                -> Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> (Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> ([t]
                -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                -> Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
       Unfolding: (\ @ t
                     w :: Text.Parsec.Text.Parser t
                     @ b
                     w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     w2 :: [t]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w4 :: [t]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                   Text.Parsec.Prim.$wa10
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     @ t
                     (\ @ b1
                        s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        cok :: t
                               -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1
                        cerr :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b1
                        eok :: t
                               -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1
                        eerr :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b1 ->
                      AS.Parsing.Out.getMatchesWithContext7
                        @ t
                        w
                        @ b1
                        s1
                        (\ x :: (GHC.Base.String, t)
                           s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err :: Text.Parsec.Error.ParseError ->
                         case x of wild { (,) inter next ->
                         cok
                           next
                           s2
                           (case s2 of wild1 { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                            case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                            case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                            case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                            case Text.Parsec.Error.$wmergeError
                                   ww4
                                   ww5
                                   ww6
                                   ww2
                                   ww11
                                   ww12
                                   ww13
                                   (GHC.Types.[]
                                      @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                            Text.Parsec.Error.ParseError ww15 ww16 } } } } }) })
                        eerr
                        (\ x :: (GHC.Base.String, t)
                           s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err :: Text.Parsec.Error.ParseError ->
                         case x of wild { (,) inter next ->
                         eok
                           next
                           s2
                           (case s2 of wild1 { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                            case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                            case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                            case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                            case Text.Parsec.Error.$wmergeError
                                   ww4
                                   ww5
                                   ww6
                                   ww2
                                   ww11
                                   ww12
                                   ww13
                                   (GHC.Types.[]
                                      @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                            Text.Parsec.Error.ParseError ww15 ww16 } } } } }) })
                        eerr)
                       `cast`
                     (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                               <Data.Text.Internal.Text>_R
                               <()>_R
                               <Data.Functor.Identity.Identity>_R
                               <t>_R))
                     @ b
                     w1
                     w2
                     w3
                     w4) -}
fdb86a59501b5af6e9ac4c7fc4172536
  $wa1 :: GHC.Prim.ByteArray#
          -> GHC.Prim.Int#
          -> GHC.Prim.Int#
          -> Text.Parsec.Pos.SourceName
          -> GHC.Prim.Int#
          -> GHC.Prim.Int#
          -> ()
          -> (GHC.Types.Char
              -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
              -> Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (GHC.Types.Char
              -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
              -> Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> Data.Functor.Identity.Identity b
    {- Arity: 11,
       Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)> -}
dbd22b2d95f63261aa2c29684e214746
  $wcolStrToInt :: GHC.Base.String -> GHC.Prim.Int#
    {- Arity: 1, Strictness: <S,1*U> -}
119199f773d791386762f72eb332ac1e
  $wgetDependenciesAndExpressions :: AS.Types.ASLocation
                                     -> AS.Types.ASExpression
                                     -> [(GHC.Types.Int, GHC.Types.Int)]
                                     -> (# [[AS.Types.ASLocation]], [AS.Types.ASExpression] #)
    {- Arity: 3, Strictness: <L,U><L,U><L,U>,
       Unfolding: (\ w :: AS.Types.ASLocation
                     w1 :: AS.Types.ASExpression
                     w2 :: [(GHC.Types.Int, GHC.Types.Int)] ->
                   let {
                     ds :: ([GHC.Base.String], [AS.Types.ExLoc])
                     = AS.Parsing.Out.getMatchesWithContext
                         @ AS.Types.ExLoc
                         (case w1 of wild {
                            AS.Types.Expression ds1 ds2 -> ds1
                            AS.Types.Reference ipv2 ipv3 -> AS.Types.expression1 })
                         AS.Parsing.Out.excelMatch1
                           `cast`
                         (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                   <Data.Text.Internal.Text>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <AS.Types.ExLoc>_R))
                   } in
                   let {
                     exLocs :: [AS.Types.ExLoc]
                     = case ds of wild { (,) inter exLocs1 -> exLocs1 }
                   } in
                   (# AS.Parsing.Out.getDependencies w exLocs w2,
                      let {
                        inter :: [GHC.Base.String]
                        = case ds of wild { (,) inter1 exLocs1 -> inter1 }
                      } in
                      let {
                        lvl22 :: AS.Types.ASLanguage
                        = case w1 of wild {
                            AS.Types.Expression ds1 ds2 -> ds2
                            AS.Types.Reference ipv2 ipv3 -> AS.Types.language1 }
                      } in
                      letrec {
                        go :: [(GHC.Types.Int, GHC.Types.Int)] -> [AS.Types.ASExpression]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ ds1 :: [(GHC.Types.Int, GHC.Types.Int)] ->
                          case ds1 of wild {
                            [] -> GHC.Types.[] @ AS.Types.ASExpression
                            : y ys
                            -> GHC.Types.:
                                 @ AS.Types.ASExpression
                                 (AS.Types.Expression
                                    (AS.Parsing.Out.getDependenciesAndExpressions_blend
                                       inter
                                       (GHC.Base.map
                                          @ AS.Types.ExLoc
                                          @ [GHC.Types.Char]
                                          (\ x :: AS.Types.ExLoc ->
                                           AS.Parsing.Out.exLocToString
                                             (AS.Parsing.Out.shiftExLoc y x))
                                          exLocs))
                                    lvl22)
                                 (go ys) }
                      } in
                      go w2 #)) -}
ee3203749b87bf4fcc66c3d67277c5d5
  $windexToExcel :: GHC.Prim.Int# -> GHC.Types.Int -> GHC.Base.String
    {- Arity: 2, Strictness: <L,U><L,1*U(U)>,
       Unfolding: (\ ww :: GHC.Prim.Int# ww1 :: GHC.Types.Int ->
                   GHC.Base.++
                     @ GHC.Types.Char
                     (AS.Parsing.Out.$wintToColStr ww)
                     (case ww1 of ww2 { GHC.Types.I# ww3 ->
                      case GHC.Show.$wshowSignedInt
                             0
                             ww3
                             (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                      GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
9efddfc9822fd455baeb4418233d4a01
  $wintToColStr :: GHC.Prim.Int# -> [GHC.Types.Char]
    {- Arity: 1, Strictness: <L,U> -}
40c49a6553f6a5a651c80d12152c138d
  $wlvl :: AS.Types.ASValue -> (# GHC.Types.Int, GHC.Types.Int #)
    {- Arity: 1, Strictness: <L,1*U>,
       Unfolding: (\ w :: AS.Types.ASValue ->
                   let {
                     ints :: [GHC.Types.Int]
                     = case w of wild {
                         DEFAULT
                         -> GHC.Types.:
                              @ GHC.Types.Int
                              (case wild of wild1 {
                                 DEFAULT -> case AS.Types.dbl1 ret_ty GHC.Types.Int of {}
                                 AS.Types.ValueD d
                                 -> case d of wild2 { GHC.Types.D# x ->
                                    let {
                                      n :: GHC.Prim.Int# = GHC.Prim.double2Int# x
                                    } in
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.<## x (GHC.Prim.int2Double# n)) of wild3 {
                                      GHC.Types.False -> GHC.Types.I# n
                                      GHC.Types.True -> GHC.Types.I# (GHC.Prim.-# n 1) } } })
                              (GHC.Types.[] @ GHC.Types.Int)
                         AS.Types.ValueL l
                         -> GHC.Base.map
                              @ AS.Types.ASValue
                              @ GHC.Types.Int
                              AS.Parsing.Out.unpackExcelLocs2
                              l }
                   } in
                   (# GHC.List.!!_sub @ GHC.Types.Int ints 0,
                      GHC.List.!!_sub @ GHC.Types.Int ints 1 #)) -}
bab45b04558667b5a8d1c84d40ad6460
  bool :: AS.Types.ASLanguage -> GHC.Base.String -> GHC.Base.String
    {- Arity: 2, Strictness: <S,1*U><L,U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage str :: GHC.Base.String ->
                   case lang of wild {
                     DEFAULT
                     -> GHC.Types.:
                          @ GHC.Types.Char
                          (case str of wild1 {
                             [] -> case GHC.List.badHead ret_ty GHC.Types.Char of {}
                             : x ds1 -> GHC.Unicode.toLower x })
                          (case str of wild1 {
                             [] -> GHC.List.tail1 @ GHC.Types.Char : ds1 xs -> xs })
                     AS.Types.Python -> str
                     AS.Types.SQL -> str
                     AS.Types.Excel -> str }) -}
07e93e2061568c140fcc9a486b1d0dfb
  colStrToInt :: GHC.Base.String -> GHC.Types.Int
    {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: GHC.Base.String ->
                   case AS.Parsing.Out.$wcolStrToInt w of ww { DEFAULT ->
                   GHC.Types.I# ww }) -}
9cc6d6a4d083779fe684fa9bb655bbbb
  colon :: Text.Parsec.Text.Parser GHC.Base.String
    {- Unfolding: (AS.Parsing.Out.colon1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))) -}
3fef2d71dc6744e6bac4e11470d2b0cb
  colon1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
            -> ([GHC.Types.Char]
                -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                -> Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> (Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> ([GHC.Types.Char]
                -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                -> Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> (Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Unfolding: (Text.Parsec.Char.string1
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     AS.Parsing.Out.colon4
                     AS.Parsing.Out.colon2) -}
0912b7a0d871bf9940e8b3c115a09ed6
  colon2 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.colon3
                     (GHC.Types.[] @ GHC.Types.Char)) -}
f0f0d015eabec6bc083a203ca36f959f
  colon3 :: GHC.Types.Char
    {- HasNoCafRefs, Unfolding: (GHC.Types.C# ':') -}
4a1a8e171ef431385640e6aea822bb0f
  colon4 :: Text.Parsec.Prim.Stream
                Data.Text.Internal.Text
                Data.Functor.Identity.Identity
                GHC.Types.Char
    {- Unfolding: (Text.Parsec.Prim.$fStreamTextmChar0
                     @ Data.Functor.Identity.Identity
                     Data.Functor.Identity.$fMonadIdentity) -}
b32ab8b17c8a068a038462d81d2cfa50
  dependenciesFromExceLLoc :: AS.Types.ASLocation
                              -> AS.Types.ExLoc
                              -> [AS.Types.ASLocation]
    {- Arity: 2, Strictness: <L,U><S,1*U> -}
93d7332df62ca8eb9522b2f152dc3e40
  dollar :: Text.Parsec.Text.Parser GHC.Base.String
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.dollar1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String>_R))) -}
6310742cdfe81d83b3abb6e4f821a36c
  dollar1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
             -> (GHC.Base.String
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> (Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> (GHC.Base.String
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> (Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (\ @ b
                     s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     cok :: GHC.Base.String
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b
                     cerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eok :: GHC.Base.String
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b
                     eerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b ->
                   Text.Parsec.Char.string1
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     AS.Parsing.Out.colon4
                     AS.Parsing.Out.dollar2
                     @ b
                     s1
                     cok
                     cerr
                     eok
                     (\ err :: Text.Parsec.Error.ParseError ->
                      Text.Parsec.Char.string1
                        @ Data.Text.Internal.Text
                        @ ()
                        @ Data.Functor.Identity.Identity
                        AS.Parsing.Out.colon4
                        (GHC.Types.[] @ GHC.Types.Char)
                        @ b
                        s1
                        cok
                        cerr
                        (\ y :: GHC.Base.String
                           s' :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eok y s' (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eerr (Text.Parsec.Error.mergeError err err')))) -}
d27047bd88325757e9abfd143fd812c3
  dollar2 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.dollar3
                     (GHC.Types.[] @ GHC.Types.Char)) -}
07effcffb4fdae316a5cf2e07b09c560
  dollar3 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '$') -}
370e65ed54669f1d3807186c045e638d
  exLocToASLocation :: AS.Types.ASLocation
                       -> AS.Types.ExLoc
                       -> AS.Types.ASLocation
    {- Arity: 2, Strictness: <L,U><S,1*U> -}
fdf07ddd003086a03b07e33201ae024f
  exLocToString :: AS.Types.ExLoc -> GHC.Base.String
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
11e8c5395903c21a4a188e793278c7af
  exc :: Text.Parsec.Text.Parser GHC.Base.String
    {- Unfolding: (AS.Parsing.Out.exc1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))) -}
2e4a37841d36df57bef5aef3eeba477c
  exc1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
          -> ([GHC.Types.Char]
              -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
              -> Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> ([GHC.Types.Char]
              -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
              -> Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Unfolding: (Text.Parsec.Char.string1
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     AS.Parsing.Out.colon4
                     AS.Parsing.Out.exc2) -}
a3ce1f58c63d7a1745a7da6833e3daa7
  exc2 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.exc3
                     (GHC.Types.[] @ GHC.Types.Char)) -}
51867d1380a2f5cb48734518dbf3a8a0
  exc3 :: GHC.Types.Char
    {- HasNoCafRefs, Unfolding: (GHC.Types.C# '!') -}
76ef8218a984db57ad0842ec78f35c91
  excelMatch :: Text.Parsec.Text.Parser AS.Types.ExLoc
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.excelMatch1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <AS.Types.ExLoc>_R))) -}
4cf6cc1b44631557fd7991d8b9dc65f4
  excelMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
ae26400591956619a237df55b9b67902
  getBlockDelim :: AS.Types.ASLanguage -> GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage ->
                   case lang of wild {
                     DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                     AS.Types.OCaml -> AS.Parsing.Out.getBlockDelim1 }) -}
d3852025989d192bacb058f382031f8e
  getBlockDelim1 :: [GHC.Types.Char]
    {- Unfolding: (GHC.CString.unpackCString# ";;"#) -}
81727361fe15de9ba652f620ef19f80c
  getDependencies :: AS.Types.ASLocation
                     -> [AS.Types.ExLoc]
                     -> [(GHC.Types.Int, GHC.Types.Int)]
                     -> [[AS.Types.ASLocation]]
    {- Arity: 3, Strictness: <L,U><L,U><S,1*U>,
       Unfolding: (\ loc :: AS.Types.ASLocation
                     matches :: [AS.Types.ExLoc]
                     offsets :: [(GHC.Types.Int, GHC.Types.Int)] ->
                   letrec {
                     go :: [(GHC.Types.Int, GHC.Types.Int)] -> [[AS.Types.ASLocation]]
                       {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [(GHC.Types.Int, GHC.Types.Int)] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ [AS.Types.ASLocation]
                         : y ys
                         -> GHC.Types.:
                              @ [AS.Types.ASLocation]
                              (letrec {
                                 go1 :: [AS.Types.ExLoc] -> [AS.Types.ASLocation]
                                   {- Arity: 1, Strictness: <S,1*U> -}
                                 = \ ds1 :: [AS.Types.ExLoc] ->
                                   case ds1 of wild1 {
                                     [] -> GHC.Types.[] @ AS.Types.ASLocation
                                     : y1 ys1
                                     -> GHC.Base.++
                                          @ AS.Types.ASLocation
                                          (AS.Parsing.Out.dependenciesFromExceLLoc
                                             loc
                                             (AS.Parsing.Out.shiftExLoc y y1))
                                          (go1 ys1) }
                               } in
                               AS.Parsing.Common.normalizeRanges_go (go1 matches))
                              (go ys) }
                   } in
                   go offsets) -}
80fa9728608910e4a01ccc1c352909fe
  getDependenciesAndExpressions :: AS.Types.ASLocation
                                   -> AS.Types.ASExpression
                                   -> [(GHC.Types.Int, GHC.Types.Int)]
                                   -> ([[AS.Types.ASLocation]], [AS.Types.ASExpression])
    {- Arity: 3, Strictness: <L,U><L,U><L,U>m, Inline: INLINE[0],
       Unfolding: InlineRule (3, True, False)
                  (\ w :: AS.Types.ASLocation
                     w1 :: AS.Types.ASExpression
                     w2 :: [(GHC.Types.Int, GHC.Types.Int)] ->
                   case AS.Parsing.Out.$wgetDependenciesAndExpressions
                          w
                          w1
                          w2 of ww { (#,#) ww1 ww2 ->
                   (ww1, ww2) }) -}
2e2f50b54343b30dc3ba92309afaee49
  getDependenciesAndExpressions_blend :: [[GHC.Types.Char]]
                                         -> [[GHC.Types.Char]]
                                         -> [GHC.Types.Char]
    {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
2d71e4942b9452df1e4de476f9862d2a
  getInlineDelim :: AS.Types.ASLanguage -> GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage ->
                   case lang of wild {
                     DEFAULT -> AS.Parsing.Out.getInlineDelim1
                     AS.Types.OCaml -> AS.Parsing.Out.getBlockDelim1 }) -}
9afbc91216ad78d5e8c780c299d3059d
  getInlineDelim1 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.getInlineDelim2
                     (GHC.Types.[] @ GHC.Types.Char)) -}
3217b70f2b2f3d466ffcb7a8d9b5b28b
  getInlineDelim2 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ';') -}
124ceca39897287ce4a6156fc6261390
  getMatchesWithContext :: GHC.Base.String
                           -> Text.Parsec.Text.Parser t
                           -> ([GHC.Base.String], [t])
    {- Arity: 2,
       Strictness: <L,1*U><C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))>,
       Unfolding: (\ @ t
                     target :: GHC.Base.String
                     p :: Text.Parsec.Text.Parser t ->
                   case (Text.Parsec.Prim.runParsecT
                           @ Data.Text.Internal.Text
                           @ ()
                           @ Data.Functor.Identity.Identity
                           @ ([GHC.Base.String], [t])
                           AS.Parsing.Out.getMatchesWithContext8
                           (AS.Parsing.Out.getMatchesWithContext5 @ t p)
                             `cast`
                           (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                     <Data.Text.Internal.Text>_R
                                     <()>_R
                                     <Data.Functor.Identity.Identity>_R
                                     <([GHC.Base.String], [t])>_R))
                           (Text.Parsec.Prim.State
                              @ Data.Text.Internal.Text
                              @ ()
                              (case target of dt { DEFAULT ->
                               GHC.ST.runSTRep
                                 @ Data.Text.Internal.Text
                                 (\ @ s1 s2 :: GHC.Prim.State# s1 ->
                                  case GHC.Prim.newByteArray# @ s1 8 s2 of ds1 { (#,#) ipv ipv1 ->
                                  AS.Parsing.Out.getMatchesWithContext4
                                    @ s1
                                    (Data.Text.Array.MArray @ s1 ipv1)
                                    AS.Parsing.Out.getMatchesWithContext3
                                    dt
                                    0
                                    ipv }) })
                              AS.Parsing.Out.getMatchesWithContext2
                              GHC.Tuple.()))
                          `cast`
                        (Data.Functor.Identity.NTCo:Identity[0]
                             <Text.Parsec.Prim.Consumed
                                  (Data.Functor.Identity.Identity
                                       (Text.Parsec.Prim.Reply
                                            Data.Text.Internal.Text
                                            ()
                                            ([GHC.Base.String], [t])))>_R) of wild {
                     Text.Parsec.Prim.Consumed r
                     -> case r `cast`
                             (Data.Functor.Identity.NTCo:Identity[0]
                                  <Text.Parsec.Prim.Reply
                                       Data.Text.Internal.Text
                                       ()
                                       ([GHC.Base.String], [t])>_R) of wild1 {
                          Text.Parsec.Prim.Ok x ds ds1 -> x
                          Text.Parsec.Prim.Error err
                          -> AS.Parsing.Out.getMatchesWithContext1 @ t }
                     Text.Parsec.Prim.Empty r
                     -> case r `cast`
                             (Data.Functor.Identity.NTCo:Identity[0]
                                  <Text.Parsec.Prim.Reply
                                       Data.Text.Internal.Text
                                       ()
                                       ([GHC.Base.String], [t])>_R) of wild1 {
                          Text.Parsec.Prim.Ok x ds ds1 -> x
                          Text.Parsec.Prim.Error err
                          -> AS.Parsing.Out.getMatchesWithContext1 @ t } }) -}
ceb41e2ab3f2d9c6b87bcc2fdc8c0fdc
  getMatchesWithContext1 :: ([GHC.Base.String], [t])
    {- Strictness: b -}
75adb0cbca1ad104715b446f3fd024dc
  getMatchesWithContext2 :: Text.Parsec.Pos.SourcePos
    {- HasNoCafRefs,
       Unfolding: (Text.Parsec.Pos.SourcePos
                     (GHC.Types.[] @ GHC.Types.Char)
                     1
                     1) -}
8e8e5c91c90ab8257465755e8880874d
  getMatchesWithContext3 :: GHC.Types.Int
    {- HasNoCafRefs, Unfolding: (GHC.Types.I# 4) -}
595ff1d774fbbe4652286a2806be41e6
  getMatchesWithContext4 :: Data.Text.Array.MArray s1
                            -> GHC.Types.Int
                            -> [GHC.Types.Char]
                            -> GHC.Prim.Int#
                            -> GHC.Prim.State# s1
                            -> (# GHC.Prim.State# s1, Data.Text.Internal.Text #)
    {- Arity: 5, Strictness: <L,U(U)><L,U(U)><S,1*U><L,U><L,U> -}
91f3f40e822c802c37b3f6b7e9f9c205
  getMatchesWithContext5 :: Text.Parsec.Text.Parser t
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> (([GHC.Base.String], [t])
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (([GHC.Base.String], [t])
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (\ @ t
                     a4 :: Text.Parsec.Text.Parser t
                     @ b
                     eta :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     eta1 :: ([GHC.Base.String], [t])
                             -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                             -> Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eta2 :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eta3 :: ([GHC.Base.String], [t])
                             -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                             -> Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eta4 :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b ->
                   Text.Parsec.Prim.$wa10
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     @ (GHC.Base.String, t)
                     (\ @ b1
                        s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        cok :: (GHC.Base.String, t)
                               -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1
                        ds :: Text.Parsec.Error.ParseError
                              -> Data.Functor.Identity.Identity b1
                        eok :: (GHC.Base.String, t)
                               -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1
                        eerr :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b1 ->
                      AS.Parsing.Out.getMatchesWithContext7
                        @ t
                        a4
                        @ b1
                        s1
                        cok
                        eerr
                        eok
                        eerr)
                       `cast`
                     (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                               <Data.Text.Internal.Text>_R
                               <()>_R
                               <Data.Functor.Identity.Identity>_R
                               <(GHC.Base.String, t)>_R))
                     @ b
                     eta
                     (\ x :: [(GHC.Base.String, t)]
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.getMatchesWithContext6
                        @ t
                        x
                        @ b
                        s2
                        eta1
                        eta2
                        (\ x1 :: ([GHC.Base.String], [t])
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eta2 (Text.Parsec.Error.mergeError err err')))
                     eta2
                     (\ x :: [(GHC.Base.String, t)]
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.getMatchesWithContext6
                        @ t
                        x
                        @ b
                        s2
                        eta1
                        eta2
                        (\ x1 :: ([GHC.Base.String], [t])
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eta4 (Text.Parsec.Error.mergeError err err')))) -}
41c20a29c216c8f699e70d0b76c3fbd6
  getMatchesWithContext6 :: [(GHC.Base.String, t)]
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> (([GHC.Base.String], [t])
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (([GHC.Base.String], [t])
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <L,U><L,U(U,U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)> -}
b54188e31a9091f957c373e765c72670
  getMatchesWithContext7 :: Text.Parsec.Text.Parser t
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> ((GHC.Base.String, t)
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> ((GHC.Base.String, t)
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
9abe7d3e5aa36457a2110419b7b7d31f
  getMatchesWithContext8 :: GHC.Base.Monad
                                Data.Functor.Identity.Identity
    {- Unfolding: (GHC.Base.D:Monad
                     @ Data.Functor.Identity.Identity
                     Data.Functor.Identity.$fMonadIdentity_$c>>=
                     (Text.Parsec.Prim.runPT2 @ Data.Functor.Identity.Identity)
                     AS.Parsing.Out.getMatchesWithContext9
                       `cast`
                     (forall a4.
                      <a4>_R ->_R Sym (Data.Functor.Identity.NTCo:Identity[0] <a4>_R))
                     (Text.Parsec.Prim.runPT1 @ Data.Functor.Identity.Identity)) -}
900976c8396d362551dc946c36d5e7d3
  getMatchesWithContext9 :: a -> a
    {- Arity: 1, HasNoCafRefs, Unfolding: (\ @ a4 tpl :: a4 -> tpl) -}
f316b80645e2380aac0e8ca5013f973c
  indexMatch :: Text.Parsec.Text.Parser AS.Types.ExLoc
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.indexMatch1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <AS.Types.ExLoc>_R))) -}
7f92d04bdb0a0b738613b1d59e9e045d
  indexMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> Data.Functor.Identity.Identity b1
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (\ @ b1
                     s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     cok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     cerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1
                     eok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     eerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1 ->
                   AS.Parsing.Out.dollar1
                     @ b1
                     s1
                     (\ x :: GHC.Base.String
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.indexMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         cok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         cerr (Text.Parsec.Error.mergeError err err')))
                     cerr
                     (\ x :: GHC.Base.String
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.indexMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eerr (Text.Parsec.Error.mergeError err err')))
                     eerr) -}
848d1c6321660394b0a38b4e2f2788b4
  indexMatch2 :: GHC.Base.String
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
9ce715ffe88cc3088d066ceb117a5253
  indexToExcel :: (GHC.Types.Int, GHC.Types.Int) -> GHC.Base.String
    {- Arity: 1, Strictness: <S(SL),1*U(1*U(U),1*U(U))>,
       Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: (GHC.Types.Int, GHC.Types.Int) ->
                   case w of ww { (,) ww1 ww2 ->
                   case ww1 of ww3 { GHC.Types.I# ww4 ->
                   AS.Parsing.Out.$windexToExcel ww4 ww2 } }) -}
5f8159895092510996ffbdcc0eb0e3d6
  intToColStr :: GHC.Types.Int -> GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: GHC.Types.Int ->
                   case w of ww { GHC.Types.I# ww1 ->
                   AS.Parsing.Out.$wintToColStr ww1 }) -}
6300bf81c41e8e5466161c36299273a6
  jsonDeserialize :: AS.Types.ASLanguage
                     -> GHC.Base.String
                     -> GHC.Base.String
                     -> GHC.Base.String
    {- Arity: 3, Strictness: <S,1*U><L,1*U><L,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage
                     objType :: GHC.Base.String
                     jsonRep :: GHC.Base.String ->
                   case lang of wild {
                     DEFAULT -> AS.Parsing.Out.jsonDeserialize4
                     AS.Types.R
                     -> GHC.Base.++
                          @ GHC.Types.Char
                          objType
                          (GHC.CString.unpackAppendCString#
                             "$("#
                             (GHC.Base.++
                                @ GHC.Types.Char
                                jsonRep
                                AS.Parsing.Out.jsonDeserialize2))
                     AS.Types.Python
                     -> GHC.Base.++
                          @ GHC.Types.Char
                          objType
                          (GHC.CString.unpackAppendCString#
                             ".deserialize("#
                             (GHC.Base.++
                                @ GHC.Types.Char
                                jsonRep
                                AS.Parsing.Out.jsonDeserialize2))
                     AS.Types.OCaml
                     -> GHC.CString.unpackAppendCString#
                          "Serialization# "#
                          (GHC.Base.++
                             @ GHC.Types.Char
                             objType
                             (GHC.Types.:
                                @ GHC.Types.Char
                                AS.Parsing.Out.jsonDeserialize1
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   jsonRep
                                   AS.Parsing.Out.getBlockDelim1)))
                     AS.Types.SQL
                     -> GHC.Base.++
                          @ GHC.Types.Char
                          objType
                          (GHC.CString.unpackAppendCString#
                             ".deserialize("#
                             (GHC.Base.++
                                @ GHC.Types.Char
                                jsonRep
                                AS.Parsing.Out.jsonDeserialize2)) }) -}
34a8e2a81efc7644a57f5e69a1ea02e6
  jsonDeserialize1 :: GHC.Types.Char
    {- HasNoCafRefs, Unfolding: (GHC.Types.C# ' ') -}
af65d7fe30963ed2639f09f227f4449a
  jsonDeserialize2 :: [GHC.Types.Char]
    {- HasNoCafRefs,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.jsonDeserialize3
                     (GHC.Types.[] @ GHC.Types.Char)) -}
dbb5d5342a8e93bafd79f1a34e377d8e
  jsonDeserialize3 :: GHC.Types.Char
    {- HasNoCafRefs, Unfolding: (GHC.Types.C# ')') -}
6d2b24de28bdf99630b626e6b7872284
  jsonDeserialize4 :: GHC.Base.String {- Strictness: b -}
dae2c2c23937d5922f977fef6b8bd8b3
  modifiedLists :: AS.Types.ASLanguage
                   -> GHC.Base.String
                   -> GHC.Base.String
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage str :: GHC.Base.String ->
                   case lang of wild {
                     DEFAULT -> str
                     AS.Types.Python
                     -> GHC.CString.unpackAppendCString#
                          "arr("#
                          (GHC.Base.++
                             @ GHC.Types.Char
                             str
                             AS.Parsing.Out.jsonDeserialize2) }) -}
5f020da2d1288dff7430c8cb1544465d
  parseMatches :: Text.Parsec.Text.Parser t
                  -> Text.Parsec.Text.Parser [t]
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
       Unfolding: InlineRule (0, True, True)
                  AS.Parsing.Out.parseMatches1
                    `cast`
                  (forall t.
                   <Text.Parsec.Text.Parser t>_R
                   ->_R Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                 <Data.Text.Internal.Text>_R
                                 <()>_R
                                 <Data.Functor.Identity.Identity>_R
                                 <[t]>_R)) -}
18ee5c8561e8717e8e1b27ebe9c39750
  parseMatches1 :: Text.Parsec.Text.Parser t
                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                      -> ([t]
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                      -> (Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                      -> ([t]
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                      -> (Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                      -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
       Inline: INLINE[0],
       Unfolding: InlineRule (6, True, True)
                  (\ @ t
                     w :: Text.Parsec.Text.Parser t
                     @ b
                     w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     w2 :: [t]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w4 :: [t]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                   AS.Parsing.Out.$wa @ t w @ b w1 w2 w3 w4) -}
16db7ea2733ebf02868ee45daeb91ee2
  parseMatchesWithContext :: Text.Parsec.Text.Parser t
                             -> Text.Parsec.Text.Parser ([GHC.Base.String], [t])
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.getMatchesWithContext5
                     `cast`
                   (forall t.
                    <Text.Parsec.Text.Parser t>_R
                    ->_R Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                  <Data.Text.Internal.Text>_R
                                  <()>_R
                                  <Data.Functor.Identity.Identity>_R
                                  <([GHC.Base.String], [t])>_R))) -}
86d431208a8ae0b149db41e4c7713d63
  parseNext :: Text.Parsec.Text.Parser t
               -> Text.Parsec.Text.Parser (GHC.Base.String, t)
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.getMatchesWithContext7
                     `cast`
                   (forall t.
                    <Text.Parsec.Text.Parser t>_R
                    ->_R Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                  <Data.Text.Internal.Text>_R
                                  <()>_R
                                  <Data.Functor.Identity.Identity>_R
                                  <(GHC.Base.String, t)>_R))) -}
ff3fa5bd90895ce175ca185eafa0aa05
  rangeMatch :: Text.Parsec.Text.Parser AS.Types.ExLoc
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.rangeMatch1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <AS.Types.ExLoc>_R))) -}
b37ef5dfa21998435ca60cdb6243b3cc
  rangeMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> Data.Functor.Identity.Identity b1
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (\ @ b1
                     s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     cok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     cerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1
                     eok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     eerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1 ->
                   AS.Parsing.Out.indexMatch1
                     @ b1
                     s1
                     (\ x :: AS.Types.ExLoc
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.rangeMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         cok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         cerr (Text.Parsec.Error.mergeError err err')))
                     cerr
                     (\ x :: AS.Types.ExLoc
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.rangeMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eerr (Text.Parsec.Error.mergeError err err')))
                     eerr) -}
86e34a60fa2788b292fc294739f60ed1
  rangeMatch2 :: AS.Types.ExLoc
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <L,U><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
efc937eaa950cd7daac838c89238cffe
  replaceMatches :: ([GHC.Base.String], [t])
                    -> (t -> GHC.Base.String)
                    -> GHC.Base.String
                    -> GHC.Base.String
    {- Arity: 3, Strictness: <S(SL),1*U(1*U,1*U)><L,C(U)><L,A>,
       Unfolding: InlineRule (3, True, False)
                  (\ @ t
                     ds :: ([GHC.Base.String], [t])
                     f :: t -> GHC.Base.String
                     target :: GHC.Base.String ->
                   case ds of wild { (,) inter matches ->
                   AS.Parsing.Out.getDependenciesAndExpressions_blend
                     inter
                     (GHC.Base.build
                        @ [GHC.Types.Char]
                        (\ @ b1 c :: [GHC.Types.Char] -> b1 -> b1 n :: b1 ->
                         GHC.Base.foldr
                           @ t
                           @ b1
                           (GHC.Base.mapFB @ [GHC.Types.Char] @ b1 @ t c f)
                           n
                           matches)) }) -}
1b84e5076d5eb4708de574c6ba9f6f8c
  sheetMatch :: Text.Parsec.Text.Parser GHC.Base.String
    {- Arity: 5,
       Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (AS.Parsing.Out.sheetMatch1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))) -}
79d1ffae07923d14838dfa76136be869
  sheetMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> ([GHC.Types.Char]
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> ([GHC.Types.Char]
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (\ @ b
                     w2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     w3 :: [GHC.Types.Char]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w5 :: [GHC.Types.Char]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                   Text.Parsec.Combinator.$wa11
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     @ GHC.Types.Char
                     @ GHC.Types.Char
                     AS.Parsing.Out.sheetMatch2
                       `cast`
                     (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                               <Data.Text.Internal.Text>_R
                               <()>_R
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Char>_R))
                     @ b
                     w2
                     w3
                     w4
                     w5
                     w6) -}
412970899cf82a7bb4a00d2fc4007915
  sheetMatch2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> (GHC.Types.Char
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (GHC.Types.Char
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <S(SSS),1*U(U(U,U,U),U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Inline: INLINE[0],
       Unfolding: InlineRule (5, True, False)
                  (\ @ b
                     w :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     w1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                   case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                   case ww1 of ww4 { Data.Text.Internal.Text ww5 ww6 ww7 ->
                   case ww2 of ww8 { Text.Parsec.Pos.SourcePos ww9 ww10 ww11 ->
                   AS.Parsing.Out.$wa1
                     @ b
                     ww5
                     ww6
                     ww7
                     ww9
                     ww10
                     ww11
                     ww3
                     w1
                     w2
                     w3
                     w4 } } }) -}
3601d300fdf565d1aaaf2be6a27fc351
  sheetRefMatch :: Text.Parsec.Text.Parser AS.Types.ExLoc
    {- Arity: 5,
       Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (AS.Parsing.Out.sheetRefMatch1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <AS.Types.ExLoc>_R))) -}
6c5dd246b03b82245ac711a45270d1f4
  sheetRefMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b1)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b1)
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b1)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b1)
                    -> Data.Functor.Identity.Identity b1
    {- Arity: 5,
       Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (\ @ b1
                     s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     cok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     cerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1
                     eok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     eerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1 ->
                   Text.Parsec.Combinator.$wa11
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     @ GHC.Types.Char
                     @ GHC.Types.Char
                     AS.Parsing.Out.sheetMatch2
                       `cast`
                     (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                               <Data.Text.Internal.Text>_R
                               <()>_R
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Char>_R))
                     @ b1
                     s1
                     (\ x :: GHC.Base.String
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.sheetRefMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         cok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         cerr (Text.Parsec.Error.mergeError err err')))
                     cerr
                     (\ x :: GHC.Base.String
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.sheetRefMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eerr (Text.Parsec.Error.mergeError err err')))
                     eerr) -}
d075d7b1459c2ba1921cd688f9bfac69
  sheetRefMatch2 :: GHC.Base.String
                    -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                       -> (AS.Types.ExLoc
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b)
                       -> (Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b)
                       -> (AS.Types.ExLoc
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b)
                       -> (Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b)
                       -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <L,U><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
7a9513066b9e21066fdf0eb668550f27
  shiftExLoc :: (GHC.Types.Int, GHC.Types.Int)
                -> AS.Types.ExLoc
                -> AS.Types.ExLoc
    {- Arity: 2, Strictness: <L,U(U(U),U(U))><S,1*U> -}
731023e1ff4922d9e8bcdfb689746c66
  shiftExLocs :: (GHC.Types.Int, GHC.Types.Int)
                 -> [AS.Types.ExLoc]
                 -> [AS.Types.ExLoc]
    {- Arity: 2, Strictness: <L,U(U(U),U(U))><S,1*U>,
       Unfolding: (\ offset :: (GHC.Types.Int, GHC.Types.Int)
                     exLocs :: [AS.Types.ExLoc] ->
                   GHC.Base.map
                     @ AS.Types.ExLoc
                     @ AS.Types.ExLoc
                     (AS.Parsing.Out.shiftExLoc offset)
                     exLocs) -}
8e83370c83342f981802724042107cde
  showFilteredValue :: AS.Types.ASLanguage
                       -> AS.Types.ASValue
                       -> GHC.Base.String
    {- Arity: 2, Strictness: <L,U><S,1*U> -}
b578bbe58813250922d33bfaa0479f00
  showValue :: AS.Types.ASLanguage
               -> AS.Types.ASValue
               -> GHC.Base.String
    {- Arity: 2, Strictness: <L,U><S,1*U> -}
22ddc91a2cb35970d6b6862d4270504e
  toListStr :: AS.Types.ASLanguage
               -> [GHC.Base.String]
               -> GHC.Base.String
    {- Arity: 2, Strictness: <S,1*U><L,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage
                     lst :: [GHC.Base.String] ->
                   let {
                     $j :: [GHC.Types.Char]
                           -> [GHC.Types.Char]
                           -> [GHC.Types.Char]
                           -> [GHC.Types.Char]
                       {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U> -}
                     = \ end :: [GHC.Types.Char]
                         delim :: [GHC.Types.Char]
                         start :: [GHC.Types.Char] ->
                       GHC.Base.++
                         @ GHC.Types.Char
                         end
                         (case lst of wild {
                            [] -> start
                            : x xs1
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 (Data.List.intercalate_$spoly_go
                                    @ GHC.Types.Char
                                    x
                                    (Data.List.prependToAll @ [GHC.Types.Char] delim xs1))
                                 start })
                   } in
                   case lang of wild {
                     DEFAULT
                     -> case AS.Parsing.Out.toListStr8 ret_ty [GHC.Types.Char] of {}
                     AS.Types.R
                     -> $j
                          AS.Parsing.Out.toListStr7
                          AS.Parsing.Out.toListStr5
                          AS.Parsing.Out.jsonDeserialize2
                     AS.Types.Python
                     -> $j
                          AS.Parsing.Out.toListStr3
                          AS.Parsing.Out.toListStr5
                          AS.Parsing.Out.toListStr1
                     AS.Types.OCaml
                     -> $j
                          AS.Parsing.Out.toListStr3
                          AS.Parsing.Out.getInlineDelim1
                          AS.Parsing.Out.toListStr1
                     AS.Types.SQL
                     -> $j
                          AS.Parsing.Out.toListStr3
                          AS.Parsing.Out.toListStr5
                          AS.Parsing.Out.toListStr1
                     AS.Types.Excel
                     -> $j
                          AS.Parsing.Out.toListStr3
                          AS.Parsing.Out.toListStr5
                          AS.Parsing.Out.toListStr1 }) -}
9c74ba5c29c3a5dd91d568bcf6813788
  toListStr1 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.toListStr2
                     (GHC.Types.[] @ GHC.Types.Char)) -}
e5b275321e448e42fb2b08053cdffada
  toListStr2 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ']') -}
0e5ecbc1d809fd9c4f5addab3df120a2
  toListStr3 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.toListStr4
                     (GHC.Types.[] @ GHC.Types.Char)) -}
aa63d8fbd0d0fc742ec876f688845f8c
  toListStr4 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '[') -}
da43e05536c5fd583f380185f546440b
  toListStr5 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.toListStr6
                     (GHC.Types.[] @ GHC.Types.Char)) -}
9078272afdec3667e52d085296dc8600
  toListStr6 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ',') -}
2e667afca4a395529f764b7e94ad856f
  toListStr7 :: [GHC.Types.Char]
    {- Unfolding: (GHC.CString.unpackCString# "c("#) -}
23a93b15b837af31d9fdb5cd70cbe63d
  toListStr8 :: ([GHC.Types.Char],
                 [GHC.Types.Char],
                 [GHC.Types.Char])
    {- Strictness: b -}
48b274407b90829998182721f8cc2891
  unpackExcelExprs :: AS.Types.ASValue -> [GHC.Base.String]
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ ds :: AS.Types.ASValue ->
                   case ds of wild {
                     DEFAULT -> GHC.Types.[] @ GHC.Base.String
                     AS.Types.ValueL l
                     -> GHC.Base.map
                          @ AS.Types.ASValue
                          @ [GHC.Types.Char]
                          AS.Types.str
                          l }) -}
2127a0b32f46d90039afb45500ea8d0b
  unpackExcelLocs :: AS.Types.ASValue
                     -> [(GHC.Types.Int, GHC.Types.Int)]
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ ds :: AS.Types.ASValue ->
                   case ds of wild {
                     DEFAULT -> AS.Parsing.Out.unpackExcelLocs3
                     AS.Types.ValueL locs
                     -> GHC.Base.map
                          @ AS.Types.ASValue
                          @ (GHC.Types.Int, GHC.Types.Int)
                          AS.Parsing.Out.unpackExcelLocs1
                          locs }) -}
6c48916d1d8ac0b62fbfeaf33a6d68a9
  unpackExcelLocs1 :: AS.Types.ASValue
                      -> (GHC.Types.Int, GHC.Types.Int)
    {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: AS.Types.ASValue ->
                   case AS.Parsing.Out.$wlvl w of ww { (#,#) ww1 ww2 ->
                   (ww1, ww2) }) -}
08b43b6fc092e719f74d6fe36ab71a86
  unpackExcelLocs2 :: AS.Types.ASValue -> GHC.Types.Int
    {- Arity: 1, Strictness: <S,1*U>m,
       Unfolding: InlineRule (1, True, False)
                  (\ x :: AS.Types.ASValue ->
                   case x of wild {
                     DEFAULT -> case AS.Types.dbl1 ret_ty GHC.Types.Int of {}
                     AS.Types.ValueD d
                     -> case d of wild1 { GHC.Types.D# x1 ->
                        let {
                          n :: GHC.Prim.Int# = GHC.Prim.double2Int# x1
                        } in
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<## x1 (GHC.Prim.int2Double# n)) of wild2 {
                          GHC.Types.False -> GHC.Types.I# n
                          GHC.Types.True -> GHC.Types.I# (GHC.Prim.-# n 1) } } }) -}
54ada1cc80123cfe4c0333d57d787083
  unpackExcelLocs3 :: [(GHC.Types.Int, GHC.Types.Int)]
    {- Strictness: b -}
5d5ec8993ba355b1397cb04ad2b3b125
  unpackExcelVals :: AS.Types.ASValue -> [AS.Types.ASValue]
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ ds :: AS.Types.ASValue ->
                   case ds of wild {
                     DEFAULT -> GHC.Types.[] @ AS.Types.ASValue
                     AS.Types.ValueL l -> l }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

