-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings to ZeroMQ 4.x
--   
--   The 0MQ lightweight messaging kernel is a library which extends the
--   standard socket interfaces with features traditionally provided by
--   specialised messaging middleware products.
--   
--   0MQ sockets provide an abstraction of asynchronous message queues,
--   multiple messaging patterns, message filtering (subscriptions),
--   seamless access to multiple transport protocols and more.
--   
--   This library provides the Haskell language binding to 0MQ &gt;= 4.x
@package zeromq4-haskell
@version 0.6.3


-- | <i>Warning</i>: This is an internal module and subject to change
--   without notice.
module System.ZMQ4.Internal.Base
newtype ZMQMsg
ZMQMsg :: Ptr () -> ZMQMsg
content :: ZMQMsg -> Ptr ()
data ZMQPoll
ZMQPoll :: {-# UNPACK #-} !ZMQSocket -> {-# UNPACK #-} !CInt -> {-# UNPACK #-} !CShort -> {-# UNPACK #-} !CShort -> ZMQPoll
pSocket :: ZMQPoll -> {-# UNPACK #-} !ZMQSocket
pFd :: ZMQPoll -> {-# UNPACK #-} !CInt
pEvents :: ZMQPoll -> {-# UNPACK #-} !CShort
pRevents :: ZMQPoll -> {-# UNPACK #-} !CShort
type ZMQMsgPtr = Ptr ZMQMsg
type ZMQCtx = Ptr ()
type ZMQSocket = Ptr ()
type ZMQPollPtr = Ptr ZMQPoll
newtype ZMQSocketType
ZMQSocketType :: CInt -> ZMQSocketType
typeVal :: ZMQSocketType -> CInt
pair :: ZMQSocketType
pub :: ZMQSocketType
sub :: ZMQSocketType
xpub :: ZMQSocketType
xsub :: ZMQSocketType
request :: ZMQSocketType
response :: ZMQSocketType
dealer :: ZMQSocketType
router :: ZMQSocketType
pull :: ZMQSocketType
newtype ZMQOption
ZMQOption :: CInt -> ZMQOption
optVal :: ZMQOption -> CInt
push :: ZMQSocketType
stream :: ZMQSocketType
affinity :: ZMQOption
backlog :: ZMQOption
conflate :: ZMQOption
curve :: ZMQOption
curvePublicKey :: ZMQOption
curveSecretKey :: ZMQOption
curveServer :: ZMQOption
curveServerKey :: ZMQOption
delayAttachOnConnect :: ZMQOption
events :: ZMQOption
filedesc :: ZMQOption
identity :: ZMQOption
immediate :: ZMQOption
ipv4Only :: ZMQOption
ipv6 :: ZMQOption
lastEndpoint :: ZMQOption
linger :: ZMQOption
maxMessageSize :: ZMQOption
mcastHops :: ZMQOption
mechanism :: ZMQOption
null :: ZMQOption
plain :: ZMQOption
plainPassword :: ZMQOption
plainServer :: ZMQOption
plainUserName :: ZMQOption
probeRouter :: ZMQOption
rate :: ZMQOption
receiveBuf :: ZMQOption
newtype ZMQCtxOption
ZMQCtxOption :: CInt -> ZMQCtxOption
ctxOptVal :: ZMQCtxOption -> CInt
receiveHighWM :: ZMQOption
receiveMore :: ZMQOption
_ioThreads :: ZMQCtxOption
receiveTimeout :: ZMQOption
_maxSockets :: ZMQCtxOption
reconnectIVL :: ZMQOption
reconnectIVLMax :: ZMQOption
recoveryIVL :: ZMQOption
newtype ZMQEventType
ZMQEventType :: Word16 -> ZMQEventType
eventTypeVal :: ZMQEventType -> Word16
reqCorrelate :: ZMQOption
reqRelaxed :: ZMQOption
connected :: ZMQEventType
routerMandatory :: ZMQOption
connectDelayed :: ZMQEventType
sendBuf :: ZMQOption
connectRetried :: ZMQEventType
sendHighWM :: ZMQOption
listening :: ZMQEventType
sendTimeout :: ZMQOption
bindFailed :: ZMQEventType
subscribe :: ZMQOption
accepted :: ZMQEventType
tcpAcceptFilter :: ZMQOption
acceptFailed :: ZMQEventType
tcpKeepAlive :: ZMQOption
closed :: ZMQEventType
tcpKeepAliveCount :: ZMQOption
closeFailed :: ZMQEventType
tcpKeepAliveIdle :: ZMQOption
disconnected :: ZMQEventType
data ZMQEvent
ZMQEvent :: {-# UNPACK #-} !ZMQEventType -> {-# UNPACK #-} !Int32 -> ZMQEvent
zeEvent :: ZMQEvent -> {-# UNPACK #-} !ZMQEventType
zeValue :: ZMQEvent -> {-# UNPACK #-} !Int32
tcpKeepAliveInterval :: ZMQOption
allEvents :: ZMQEventType
unsubscribe :: ZMQOption
monitorStopped :: ZMQEventType
xpubVerbose :: ZMQOption
zapDomain :: ZMQOption
peekZMQEvent :: ZMQMsgPtr -> IO ZMQEvent
newtype ZMQSecMechanism
ZMQSecMechanism :: Int -> ZMQSecMechanism
secMechanism :: ZMQSecMechanism -> Int
secNull :: ZMQSecMechanism
secPlain :: ZMQSecMechanism
secCurve :: ZMQSecMechanism
newtype ZMQMsgOption
ZMQMsgOption :: CInt -> ZMQMsgOption
msgOptVal :: ZMQMsgOption -> CInt
more :: ZMQMsgOption
newtype ZMQFlag
ZMQFlag :: CInt -> ZMQFlag
flagVal :: ZMQFlag -> CInt
dontWait :: ZMQFlag
sndMore :: ZMQFlag
newtype ZMQPollEvent
ZMQPollEvent :: CShort -> ZMQPollEvent
pollVal :: ZMQPollEvent -> CShort
pollIn :: ZMQPollEvent
pollOut :: ZMQPollEvent
pollerr :: ZMQPollEvent
c_zmq_version :: Ptr CInt -> Ptr CInt -> Ptr CInt -> IO ()
c_zmq_ctx_new :: IO ZMQCtx
c_zmq_ctx_shutdown :: ZMQCtx -> IO CInt
c_zmq_ctx_term :: ZMQCtx -> IO CInt
c_zmq_ctx_get :: ZMQCtx -> CInt -> IO CInt
c_zmq_ctx_set :: ZMQCtx -> CInt -> CInt -> IO CInt
c_zmq_msg_init :: ZMQMsgPtr -> IO CInt
c_zmq_msg_init_size :: ZMQMsgPtr -> CSize -> IO CInt
c_zmq_msg_close :: ZMQMsgPtr -> IO CInt
c_zmq_msg_data :: ZMQMsgPtr -> IO (Ptr a)
c_zmq_msg_size :: ZMQMsgPtr -> IO CSize
c_zmq_msg_get :: ZMQMsgPtr -> CInt -> IO CInt
c_zmq_msg_set :: ZMQMsgPtr -> CInt -> CInt -> IO CInt
c_zmq_socket :: ZMQCtx -> CInt -> IO ZMQSocket
c_zmq_close :: ZMQSocket -> IO CInt
c_zmq_setsockopt :: ZMQSocket -> CInt -> Ptr () -> CSize -> IO CInt
c_zmq_getsockopt :: ZMQSocket -> CInt -> Ptr () -> Ptr CSize -> IO CInt
c_zmq_bind :: ZMQSocket -> CString -> IO CInt
c_zmq_unbind :: ZMQSocket -> CString -> IO CInt
c_zmq_connect :: ZMQSocket -> CString -> IO CInt
c_zmq_disconnect :: ZMQSocket -> CString -> IO CInt
c_zmq_sendmsg :: ZMQSocket -> ZMQMsgPtr -> CInt -> IO CInt
c_zmq_recvmsg :: ZMQSocket -> ZMQMsgPtr -> CInt -> IO CInt
c_zmq_socket_monitor :: ZMQSocket -> CString -> CInt -> IO CInt
c_zmq_errno :: IO CInt
c_zmq_strerror :: CInt -> IO CString
c_zmq_proxy :: ZMQSocket -> ZMQSocket -> ZMQSocket -> IO CInt
c_zmq_poll :: ZMQPollPtr -> CInt -> CLong -> IO CInt
c_zmq_z85_encode :: CString -> Ptr Word8 -> CSize -> IO CString
c_zmq_z85_decode :: Ptr Word8 -> CString -> IO (Ptr Word8)
c_zmq_curve_keypair :: CString -> CString -> IO CInt
instance Eq ZMQMsg
instance Ord ZMQMsg
instance Eq ZMQSocketType
instance Ord ZMQSocketType
instance Eq ZMQOption
instance Ord ZMQOption
instance Eq ZMQCtxOption
instance Ord ZMQCtxOption
instance Eq ZMQEventType
instance Ord ZMQEventType
instance Show ZMQEventType
instance Storable ZMQEventType
instance Eq ZMQSecMechanism
instance Ord ZMQSecMechanism
instance Show ZMQSecMechanism
instance Eq ZMQMsgOption
instance Ord ZMQMsgOption
instance Eq ZMQFlag
instance Ord ZMQFlag
instance Eq ZMQPollEvent
instance Ord ZMQPollEvent
instance Storable ZMQPoll
instance Storable ZMQMsg


-- | We use our own functions for throwing exceptions in order to get the
--   actual error message via <tt>zmq_strerror</tt>. 0MQ defines additional
--   error numbers besides those defined by the operating system, so
--   <tt>zmq_strerror</tt> should be used in preference to
--   <tt>strerror</tt> which is used by the standard throw* functions in
--   <a>Error</a>.
--   
--   <i>Warning</i>: This is an internal module and subject to change
--   without notice.
module System.ZMQ4.Internal.Error

-- | ZMQError encapsulates information about errors, which occur when using
--   the native 0MQ API, such as error number and message.
data ZMQError
ZMQError :: Int -> String -> String -> ZMQError

-- | Error number value.
errno :: ZMQError -> Int

-- | Source where this error originates from.
source :: ZMQError -> String

-- | Actual error message.
message :: ZMQError -> String
throwError :: String -> IO a
throwIf :: (a -> Bool) -> String -> IO a -> IO a
throwIf_ :: (a -> Bool) -> String -> IO a -> IO ()
throwIfRetry :: (a -> Bool) -> String -> IO a -> IO a
throwIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
throwIfMinus1 :: (Eq a, Num a) => String -> IO a -> IO a
throwIfMinus1_ :: (Eq a, Num a) => String -> IO a -> IO ()
throwIfNull :: String -> IO (Ptr a) -> IO (Ptr a)
throwIfMinus1Retry :: (Eq a, Num a) => String -> IO a -> IO a
throwIfMinus1Retry_ :: (Eq a, Num a) => String -> IO a -> IO ()
throwIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a
throwIfRetryMayBlock_ :: (a -> Bool) -> String -> IO a -> IO b -> IO ()
throwIfMinus1RetryMayBlock :: (Eq a, Num a) => String -> IO a -> IO b -> IO a
throwIfMinus1RetryMayBlock_ :: (Eq a, Num a) => String -> IO a -> IO b -> IO ()
zmqErrnoMessage :: CInt -> IO String
zmqErrno :: IO Errno
instance Typeable ZMQError
instance Eq ZMQError
instance Ord ZMQError
instance Exception ZMQError
instance Show ZMQError


-- | Type-level restricted data. This module allows for type declarations
--   which embed certain restrictions, such as value bounds. E.g.
--   <tt>Restricted N0 N1 Int</tt> denotes an <a>Int</a> which can only
--   have values [0 .. 1]. When creating such a value, the constructor
--   functions <a>restrict</a> or <a>toRestricted</a> ensure that the
--   restrictions are obeyed. Code that consumes restricted types does not
--   need to check the constraints.
--   
--   <i>N.B.</i> This module is more or less tailored to be used within
--   <a>ZMQ3</a>. Therefore the provided type level restrictions are
--   limited.
module Data.Restricted

-- | Type level restriction.
data Restricted r v

-- | A uniform way to restrict values.
class Restriction r v
toRestricted :: Restriction r v => v -> Maybe (Restricted r v)
restrict :: Restriction r v => v -> Restricted r v

-- | Get the actual value.
rvalue :: Restricted r v -> v

-- | type level -1
data Nneg1

-- | type-level 1
data N1

-- | type-level 0
data N0

-- | type-level 254
data N254

-- | type-level infinity
data Inf

-- | divisable by 4
data Div4

-- | divisable by 5
data Div5
instance Show v => Show (Restricted r v)
instance Restriction Div5 ByteString
instance Restriction Div4 ByteString
instance Restriction (N1, N254) ByteString
instance Restriction (N1, N254) String
instance Integral a => Restriction (Nneg1, Int64) a
instance Integral a => Restriction (Nneg1, Int32) a
instance Integral a => Restriction (Nneg1, Inf) a
instance Integral a => Restriction (N1, Int64) a
instance Integral a => Restriction (N1, Int32) a
instance Integral a => Restriction (N1, Inf) a
instance Integral a => Restriction (N0, Int64) a
instance Integral a => Restriction (N0, Int32) a
instance Integral a => Restriction (N0, Inf) a
instance Show Div5
instance Show Div4
instance Show Inf
instance Show N254
instance Show N1
instance Show N0
instance Show Nneg1


-- | <i>Warning</i>: This is an internal module and subject to change
--   without notice.
module System.ZMQ4.Internal

-- | A 0MQ context representation.
newtype Context
Context :: ZMQCtx -> Context
_ctx :: Context -> ZMQCtx

-- | A 0MQ Socket.
newtype Socket a
Socket :: SocketRepr -> Socket a
_socketRepr :: Socket a -> SocketRepr
data SocketRepr
SocketRepr :: ZMQSocket -> IORef Bool -> SocketRepr
_socket :: SocketRepr -> ZMQSocket
_sockLive :: SocketRepr -> IORef Bool

-- | Socket types.
class SocketType a
zmqSocketType :: SocketType a => a -> ZMQSocketType
class SocketLike s
toSocket :: SocketLike s => s t -> Socket t
newtype Message
Message :: ZMQMsgPtr -> Message
msgPtr :: Message -> ZMQMsgPtr

-- | Flags to apply on send operations (cf. man zmq_send)
data Flag

-- | ZMQ_DONTWAIT (Only relevant on Windows.)
DontWait :: Flag

-- | ZMQ_SNDMORE
SendMore :: Flag
type Timeout = Int64
type Size = Word

-- | Configuration switch
data Switch

-- | Use default setting
Default :: Switch

-- | Activate setting
On :: Switch

-- | De-activate setting
Off :: Switch

-- | Event types to monitor.
data EventType
ConnectedEvent :: EventType
ConnectDelayedEvent :: EventType
ConnectRetriedEvent :: EventType
ListeningEvent :: EventType
BindFailedEvent :: EventType
AcceptedEvent :: EventType
AcceptFailedEvent :: EventType
ClosedEvent :: EventType
CloseFailedEvent :: EventType
DisconnectedEvent :: EventType
MonitorStoppedEvent :: EventType
AllEvents :: EventType

-- | Event Message to receive when monitoring socket events.
data EventMsg
Connected :: !ByteString -> !Fd -> EventMsg
ConnectDelayed :: !ByteString -> EventMsg
ConnectRetried :: !ByteString -> !Int -> EventMsg
Listening :: !ByteString -> !Fd -> EventMsg
BindFailed :: !ByteString -> !Int -> EventMsg
Accepted :: !ByteString -> !Fd -> EventMsg
AcceptFailed :: !ByteString -> !Int -> EventMsg
Closed :: !ByteString -> !Fd -> EventMsg
CloseFailed :: !ByteString -> !Int -> EventMsg
Disconnected :: !ByteString -> !Fd -> EventMsg
MonitorStopped :: !ByteString -> !Int -> EventMsg
data SecurityMechanism
Null :: SecurityMechanism
Plain :: SecurityMechanism
Curve :: SecurityMechanism
data KeyFormat a
BinaryFormat :: KeyFormat Div4
TextFormat :: KeyFormat Div5
messageOf :: ByteString -> IO Message
messageOfLazy :: ByteString -> IO Message
messageClose :: Message -> IO ()
messageFree :: Message -> IO ()
messageInit :: IO Message
messageInitSize :: Size -> IO Message
setIntOpt :: (Storable b, Integral b) => Socket a -> ZMQOption -> b -> IO ()
setStrOpt :: Socket a -> ZMQOption -> String -> IO ()
getIntOpt :: (Storable b, Integral b) => Socket a -> ZMQOption -> b -> IO b
getStrOpt :: Socket a -> ZMQOption -> IO String
getInt32Option :: ZMQOption -> Socket a -> IO Int
setInt32OptFromRestricted :: Integral i => ZMQOption -> Restricted r i -> Socket b -> IO ()
ctxIntOption :: Integral i => String -> ZMQCtxOption -> Context -> IO i
setCtxIntOption :: Integral i => String -> ZMQCtxOption -> i -> Context -> IO ()
getByteStringOpt :: Socket a -> ZMQOption -> IO ByteString
setByteStringOpt :: Socket a -> ZMQOption -> ByteString -> IO ()
z85Encode :: MonadIO m => Restricted Div4 ByteString -> m ByteString
z85Decode :: MonadIO m => Restricted Div5 ByteString -> m ByteString
toZMQFlag :: Flag -> ZMQFlag
combine :: (Integral i, Bits i) => [i] -> i
combineFlags :: [Flag] -> CInt
mkSocketRepr :: SocketType t => t -> Context -> IO SocketRepr
closeSock :: SocketRepr -> IO ()
onSocket :: String -> Socket a -> (ZMQSocket -> IO b) -> IO b
bool2cint :: Bool -> CInt
toSwitch :: (Show a, Integral a) => String -> a -> Switch
fromSwitch :: Integral a => Switch -> a
events2cint :: [EventType] -> CInt
eventMessage :: ByteString -> ZMQEvent -> EventMsg
toMechanism :: SecurityMechanism -> ZMQSecMechanism
fromMechanism :: String -> Int -> SecurityMechanism
getKey :: KeyFormat f -> Socket a -> ZMQOption -> IO ByteString
instance Typeable Context
instance Show (KeyFormat a)
instance Eq (KeyFormat a)
instance Eq Flag
instance Ord Flag
instance Show Flag
instance Eq Switch
instance Ord Switch
instance Show Switch
instance Eq EventType
instance Ord EventType
instance Show EventType
instance Eq EventMsg
instance Show EventMsg
instance Eq SecurityMechanism
instance Show SecurityMechanism
instance SocketLike Socket


-- | 0MQ haskell binding. The API closely follows the C-API of 0MQ with the
--   main difference being that sockets are typed.
--   
--   <i>Notes</i>
--   
--   Many option settings use a <a>Restriction</a> to further constrain the
--   range of possible values of their integral types. For example the
--   maximum message size can be given as -1, which means no limit or by
--   greater values, which denote the message size in bytes. The type of
--   <a>setMaxMessageSize</a> is therefore:
--   
--   <pre>
--   setMaxMessageSize :: Integral i
--                       =&gt; Restricted (Nneg1, Int64) i
--                       -&gt; Socket a
--                       -&gt; IO ()
--   </pre>
--   
--   which means any integral value in the range of <tt>-1</tt> to
--   (<tt>maxBound :: Int64</tt>) can be given. To create a restricted
--   value from plain value, use <a>toRestricted</a> or <a>restrict</a>.
module System.ZMQ4

-- | <a>ZMQ_PAIR</a>
data Pair
Pair :: Pair

-- | <a>ZMQ_PUB</a>
data Pub
Pub :: Pub

-- | <a>ZMQ_SUB</a>
data Sub
Sub :: Sub

-- | <a>ZMQ_XPUB</a>
data XPub
XPub :: XPub

-- | <a>ZMQ_XSUB</a>
data XSub
XSub :: XSub

-- | <a>ZMQ_REQ</a>
data Req
Req :: Req

-- | <a>ZMQ_REP</a>
data Rep
Rep :: Rep

-- | <a>ZMQ_DEALER</a>
data Dealer
Dealer :: Dealer

-- | <a>ZMQ_ROUTER</a>
data Router
Router :: Router

-- | <i>Deprecated: Use Dealer</i>
type XReq = Dealer

-- | <i>Deprecated: Use Router</i>
type XRep = Router

-- | <a>ZMQ_PULL</a>
data Pull
Pull :: Pull

-- | <a>ZMQ_PUSH</a>
data Push
Push :: Push

-- | <a>ZMQ_STREAM</a>
data Stream
Stream :: Stream

-- | Socket types.
class SocketType a

-- | Sockets which can <a>send</a>.
class Sender a

-- | Sockets which can <a>receive</a>.
class Receiver a

-- | Sockets which can <a>subscribe</a>.
class Subscriber a
class SocketLike s

-- | Sockets which can be <a>conflate</a>d.
class Conflatable a

-- | Sockets which can send probes (cf. <a>setProbeRouter</a>).
class SendProbe a
type Size = Word

-- | A 0MQ context representation.
data Context

-- | A 0MQ Socket.
data Socket a

-- | Flags to apply on send operations (cf. man zmq_send)
data Flag

-- | ZMQ_DONTWAIT (Only relevant on Windows.)
DontWait :: Flag

-- | ZMQ_SNDMORE
SendMore :: Flag

-- | Configuration switch
data Switch

-- | Use default setting
Default :: Switch

-- | Activate setting
On :: Switch

-- | De-activate setting
Off :: Switch
type Timeout = Int64

-- | Socket events.
data Event

-- | <tt>ZMQ_POLLIN</tt> (incoming messages)
In :: Event

-- | <tt>ZMQ_POLLOUT</tt> (outgoing messages, i.e. at least 1 byte can be
--   written)
Out :: Event

-- | <pre>
--   ZMQ_POLLERR
--   </pre>
Err :: Event

-- | Event types to monitor.
data EventType
ConnectedEvent :: EventType
ConnectDelayedEvent :: EventType
ConnectRetriedEvent :: EventType
ListeningEvent :: EventType
BindFailedEvent :: EventType
AcceptedEvent :: EventType
AcceptFailedEvent :: EventType
ClosedEvent :: EventType
CloseFailedEvent :: EventType
DisconnectedEvent :: EventType
MonitorStoppedEvent :: EventType
AllEvents :: EventType

-- | Event Message to receive when monitoring socket events.
data EventMsg
Connected :: !ByteString -> !Fd -> EventMsg
ConnectDelayed :: !ByteString -> EventMsg
ConnectRetried :: !ByteString -> !Int -> EventMsg
Listening :: !ByteString -> !Fd -> EventMsg
BindFailed :: !ByteString -> !Int -> EventMsg
Accepted :: !ByteString -> !Fd -> EventMsg
AcceptFailed :: !ByteString -> !Int -> EventMsg
Closed :: !ByteString -> !Fd -> EventMsg
CloseFailed :: !ByteString -> !Int -> EventMsg
Disconnected :: !ByteString -> !Fd -> EventMsg
MonitorStopped :: !ByteString -> !Int -> EventMsg

-- | A <a>Poll</a> value contains the object to poll (a 0MQ socket or a
--   file descriptor), the set of <a>Event</a>s which are of interest
--   and--optionally-- a callback-function which is invoked iff the set of
--   interested events overlaps with the actual events.
data Poll s m
Sock :: s t -> [Event] -> Maybe ([Event] -> m ()) -> Poll s m
File :: Fd -> [Event] -> Maybe ([Event] -> m ()) -> Poll s m
data KeyFormat a
BinaryFormat :: KeyFormat Div4
TextFormat :: KeyFormat Div5
data SecurityMechanism
Null :: SecurityMechanism
Plain :: SecurityMechanism
Curve :: SecurityMechanism

-- | Run an action with a 0MQ context. The <a>Context</a> supplied to your
--   action will <i>not</i> be valid after the action either returns or
--   throws an exception.
withContext :: (Context -> IO a) -> IO a

-- | Run an action with a 0MQ socket. The socket will be closed after
--   running the supplied action even if an error occurs. The socket
--   supplied to your action will <i>not</i> be valid after the action
--   terminates.
withSocket :: SocketType a => Context -> a -> (Socket a -> IO b) -> IO b

-- | Bind the socket to the given address (cf. <a>zmq_bind</a>).
bind :: Socket a -> String -> IO ()

-- | Unbind the socket from the given address (cf. <a>zmq_unbind</a>).
unbind :: Socket a -> String -> IO ()

-- | Connect the socket to the given address (cf. <a>zmq_connect</a>).
connect :: Socket a -> String -> IO ()

-- | Disconnect the socket from the given endpoint (cf.
--   <a>zmq_disconnect</a>).
disconnect :: Socket a -> String -> IO ()

-- | Send the given <a>ByteString</a> over the socket (cf.
--   <a>zmq_sendmsg</a>).
--   
--   <i>Note</i>: This function always calls <tt>zmq_sendmsg</tt> in a
--   non-blocking way, i.e. there is no need to provide the
--   <tt>ZMQ_DONTWAIT</tt> flag as this is used by default. Still
--   <a>send</a> is blocking the thread as long as the message can not be
--   queued on the socket using GHC's <tt>threadWaitWrite</tt>.
send :: Sender a => Socket a -> [Flag] -> ByteString -> IO ()

-- | Send the given <a>ByteString</a> over the socket (cf.
--   <a>zmq_sendmsg</a>).
--   
--   This is operationally identical to <tt>send socket (Strict.concat
--   (Lazy.toChunks lbs)) flags</tt> but may be more efficient.
--   
--   <i>Note</i>: This function always calls <tt>zmq_sendmsg</tt> in a
--   non-blocking way, i.e. there is no need to provide the
--   <tt>ZMQ_DONTWAIT</tt> flag as this is used by default. Still
--   <a>send'</a> is blocking the thread as long as the message can not be
--   queued on the socket using GHC's <tt>threadWaitWrite</tt>.
send' :: Sender a => Socket a -> [Flag] -> ByteString -> IO ()

-- | Send a multi-part message. This function applies the <a>SendMore</a>
--   <a>Flag</a> between all message parts. 0MQ guarantees atomic delivery
--   of a multi-part message (cf. <a>zmq_sendmsg</a>).
sendMulti :: Sender a => Socket a -> NonEmpty ByteString -> IO ()

-- | Receive a <tt>ByteString</tt> from socket (cf. <a>zmq_recvmsg</a>).
--   
--   <i>Note</i>: This function always calls <tt>zmq_recvmsg</tt> in a
--   non-blocking way, i.e. there is no need to provide the
--   <tt>ZMQ_DONTWAIT</tt> flag as this is used by default. Still
--   <a>receive</a> is blocking the thread as long as no data is available
--   using GHC's <a>threadWaitRead</a>.
receive :: Receiver a => Socket a -> IO (ByteString)

-- | Receive a multi-part message. This function collects all message parts
--   send via <a>sendMulti</a>.
receiveMulti :: Receiver a => Socket a -> IO [ByteString]

-- | Return the runtime version of the underlying 0MQ library as a (major,
--   minor, patch) triple.
version :: IO (Int, Int, Int)

-- | Monitor socket events (cf. <a>zmq_socket_monitor</a>).
--   
--   This function returns a function which can be invoked to retrieve the
--   next socket event, potentially blocking until the next one becomes
--   available. When applied to <a>False</a>, monitoring will terminate,
--   i.e. internal monitoring resources will be disposed. Consequently
--   after <a>monitor</a> has been invoked, the returned function must be
--   applied <i>once</i> to <a>False</a>.
monitor :: [EventType] -> Context -> Socket a -> IO (Bool -> IO (Maybe EventMsg))

-- | Setup socket monitoring, i.e. a <a>Pair</a> socket which sends
--   monitoring events about the given <a>Socket</a> to the given address.
socketMonitor :: [EventType] -> String -> Socket a -> IO ()

-- | Polls for events on the given <a>Poll</a> descriptors. Returns a list
--   of events per descriptor which have occured. (cf. <a>zmq_poll</a>)
poll :: (SocketLike s, MonadIO m) => Timeout -> [Poll s m] -> m [[Event]]

-- | Subscribe Socket to given subscription.
subscribe :: Subscriber a => Socket a -> ByteString -> IO ()

-- | Unsubscribe Socket from given subscription.
unsubscribe :: Subscriber a => Socket a -> ByteString -> IO ()

-- | <a>zmq_ctx_get ZMQ_IO_THREADS</a>.
ioThreads :: Context -> IO Word

-- | <a>zmq_ctx_get ZMQ_MAX_SOCKETS</a>.
maxSockets :: Context -> IO Word

-- | <a>zmq_ctx_get ZMQ_IO_THREADS</a>.
setIoThreads :: Word -> Context -> IO ()

-- | <a>zmq_ctx_get ZMQ_MAX_SOCKETS</a>.
setMaxSockets :: Word -> Context -> IO ()

-- | <a>zmq_getsockopt ZMQ_AFFINITY</a>.
affinity :: Socket a -> IO Word64

-- | <a>zmq_getsockopt ZMQ_BACKLOG</a>.
backlog :: Socket a -> IO Int

-- | Restricts the outgoing and incoming socket buffers to a single
--   message.
conflate :: Conflatable a => Socket a -> IO Bool

-- | <a>zmq_getsockopt ZMQ_CURVE_PUBLICKEY</a>.
curvePublicKey :: KeyFormat f -> Socket a -> IO ByteString

-- | <a>zmq_getsockopt ZMQ_CURVE_SECRETKEY</a>.
curveSecretKey :: KeyFormat f -> Socket a -> IO ByteString

-- | <a>zmq_getsockopt ZMQ_CURVE_SERVERKEY</a>.
curveServerKey :: KeyFormat f -> Socket a -> IO ByteString

-- | <i>Deprecated: Use immediate</i>
delayAttachOnConnect :: Socket a -> IO Bool

-- | <a>zmq_getsockopt ZMQ_EVENTS</a>.
events :: Socket a -> IO [Event]

-- | <a>zmq_getsockopt ZMQ_FD</a>.
fileDescriptor :: Socket a -> IO Fd

-- | <a>zmq_getsockopt ZMQ_IDENTITY</a>.
identity :: Socket a -> IO ByteString

-- | <a>zmq_getsockopt ZMQ_IMMEDIATE</a>.
immediate :: Socket a -> IO Bool

-- | <i>Deprecated: Use ipv6</i>
ipv4Only :: Socket a -> IO Bool

-- | <a>zmq_getsockopt ZMQ_IPV6</a>.
ipv6 :: Socket a -> IO Bool

-- | <a>zmq_getsockopt ZMQ_LAST_ENDPOINT</a>.
lastEndpoint :: Socket a -> IO String

-- | <a>zmq_getsockopt ZMQ_LINGER</a>.
linger :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_MAXMSGSIZE</a>.
maxMessageSize :: Socket a -> IO Int64

-- | <a>zmq_getsockopt ZMQ_MULTICAST_HOPS</a>.
mcastHops :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_MECHANISM</a>.
mechanism :: Socket a -> IO SecurityMechanism

-- | <a>zmq_getsockopt ZMQ_RCVMORE</a>.
moreToReceive :: Socket a -> IO Bool

-- | <a>zmq_getsockopt ZMQ_PLAIN_SERVER</a>.
plainServer :: Socket a -> IO Bool

-- | <a>zmq_getsockopt ZMQ_PLAIN_PASSWORD</a>.
plainPassword :: Socket a -> IO ByteString

-- | <a>zmq_getsockopt ZMQ_PLAIN_USERNAME</a>.
plainUserName :: Socket a -> IO ByteString

-- | <a>zmq_getsockopt ZMQ_RATE</a>.
rate :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_RCVBUF</a>.
receiveBuffer :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_RCVHWM</a>.
receiveHighWM :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_RCVTIMEO</a>.
receiveTimeout :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_RECONNECT_IVL</a>.
reconnectInterval :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_RECONNECT_IVL_MAX</a>.
reconnectIntervalMax :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_RECOVERY_IVL</a>.
recoveryInterval :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_SNDBUF</a>.
sendBuffer :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_SNDHWM</a>.
sendHighWM :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_SNDTIMEO</a>.
sendTimeout :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_TCP_KEEPALIVE</a>.
tcpKeepAlive :: Socket a -> IO Switch

-- | <a>zmq_getsockopt ZMQ_TCP_KEEPALIVE_CNT</a>.
tcpKeepAliveCount :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_TCP_KEEPALIVE_IDLE</a>.
tcpKeepAliveIdle :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_TCP_KEEPALIVE_INTVL</a>.
tcpKeepAliveInterval :: Socket a -> IO Int

-- | <a>zmq_getsockopt ZMQ_ZAP_DOMAIN</a>.
zapDomain :: Socket a -> IO ByteString

-- | <a>zmq_setsockopt ZMQ_AFFINITY</a>.
setAffinity :: Word64 -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_BACKLOG</a>.
setBacklog :: Integral i => Restricted (N0, Int32) i -> Socket a -> IO ()

-- | Restrict the outgoing and incoming socket buffers to a single message.
setConflate :: Conflatable a => Bool -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_CURVE_SERVER</a>.
setCurveServer :: Bool -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_CURVE_PUBLICKEY</a>.
setCurvePublicKey :: KeyFormat f -> Restricted f ByteString -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_CURVE_SECRETKEY</a>.
setCurveSecretKey :: KeyFormat f -> Restricted f ByteString -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_CURVE_SERVERKEY</a>.
setCurveServerKey :: KeyFormat f -> Restricted f ByteString -> Socket a -> IO ()

-- | <i>Deprecated: Use setImmediate</i>
setDelayAttachOnConnect :: Bool -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_IDENTITY</a>.
setIdentity :: Restricted (N1, N254) ByteString -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_IMMEDIATE</a>.
setImmediate :: Bool -> Socket a -> IO ()

-- | <i>Deprecated: Use setIpv6</i>
setIpv4Only :: Bool -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_IPV6</a>.
setIpv6 :: Bool -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_LINGER</a>.
setLinger :: Integral i => Restricted (Nneg1, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_MAXMSGSIZE</a>.
setMaxMessageSize :: Integral i => Restricted (Nneg1, Int64) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_MULTICAST_HOPS</a>.
setMcastHops :: Integral i => Restricted (N1, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_PLAIN_SERVER</a>.
setPlainServer :: Bool -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_PLAIN_USERNAME</a>.
setPlainPassword :: Restricted (N1, N254) ByteString -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_PLAIN_USERNAME</a>.
setPlainUserName :: Restricted (N1, N254) ByteString -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_PROBE_ROUTER</a>.
setProbeRouter :: SendProbe a => Bool -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_RATE</a>.
setRate :: Integral i => Restricted (N1, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_RCVBUF</a>.
setReceiveBuffer :: Integral i => Restricted (N0, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_RCVHWM</a>.
setReceiveHighWM :: Integral i => Restricted (N0, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_RCVTIMEO</a>.
setReceiveTimeout :: Integral i => Restricted (Nneg1, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_RECONNECT_IVL</a>.
setReconnectInterval :: Integral i => Restricted (N0, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_RECONNECT_IVL_MAX</a>.
setReconnectIntervalMax :: Integral i => Restricted (N0, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_RECOVERY_IVL</a>.
setRecoveryInterval :: Integral i => Restricted (N0, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_REQ_CORRELATE</a>.
setReqCorrelate :: Bool -> Socket Req -> IO ()

-- | <a>zmq_setsockopt ZMQ_REQ_RELAXED</a>.
setReqRelaxed :: Bool -> Socket Req -> IO ()

-- | <a>zmq_setsockopt ZMQ_ROUTER_MANDATORY</a>.
setRouterMandatory :: Bool -> Socket Router -> IO ()

-- | <a>zmq_setsockopt ZMQ_SNDBUF</a>.
setSendBuffer :: Integral i => Restricted (N0, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_SNDHWM</a>.
setSendHighWM :: Integral i => Restricted (N0, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_SNDTIMEO</a>.
setSendTimeout :: Integral i => Restricted (Nneg1, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_TCP_ACCEPT_FILTER</a>.
setTcpAcceptFilter :: Maybe ByteString -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_TCP_KEEPALIVE</a>.
setTcpKeepAlive :: Switch -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_TCP_KEEPALIVE_CNT</a>.
setTcpKeepAliveCount :: Integral i => Restricted (Nneg1, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_TCP_KEEPALIVE_IDLE</a>.
setTcpKeepAliveIdle :: Integral i => Restricted (Nneg1, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_TCP_KEEPALIVE_INTVL</a>.
setTcpKeepAliveInterval :: Integral i => Restricted (Nneg1, Int32) i -> Socket a -> IO ()

-- | <a>zmq_setsockopt ZMQ_XPUB_VERBOSE</a>.
setXPubVerbose :: Bool -> Socket XPub -> IO ()

-- | Create a restricted value. If the given value does not satisfy the
--   restrictions, a modified variant is used instead, e.g. if an integer
--   is larger than the upper bound, the upper bound value is used.
restrict :: Restriction r v => v -> Restricted r v

-- | Create a restricted value. Returns <a>Nothing</a> if the given value
--   does not satisfy all restrictions.
toRestricted :: Restriction r v => v -> Maybe (Restricted r v)

-- | ZMQError encapsulates information about errors, which occur when using
--   the native 0MQ API, such as error number and message.
data ZMQError

-- | Error number value.
errno :: ZMQError -> Int

-- | Source where this error originates from.
source :: ZMQError -> String

-- | Actual error message.
message :: ZMQError -> String

-- | <i>Deprecated: Use context</i>
init :: Size -> IO Context

-- | Terminate a 0MQ context. Equivalent to <a>zmq_ctx_term</a>.
term :: Context -> IO ()

-- | Shutdown a 0MQ context. Equivalent to <a>zmq_ctx_shutdown</a>.
shutdown :: Context -> IO ()

-- | Initialize a 0MQ context. Equivalent to <a>zmq_ctx_new</a>.
context :: IO Context

-- | Create a new 0MQ socket within the given context. <a>withSocket</a>
--   provides automatic socket closing and may be safer to use.
socket :: SocketType a => Context -> a -> IO (Socket a)

-- | Close a 0MQ socket. <a>withSocket</a> provides automatic socket
--   closing and may be safer to use.
close :: Socket a -> IO ()

-- | Wait until data is available for reading from the given Socket. After
--   this function returns, a call to <a>receive</a> will essentially be
--   non-blocking.
waitRead :: Socket a -> IO ()

-- | Wait until data can be written to the given Socket. After this
--   function returns, a call to <a>send</a> will essentially be
--   non-blocking.
waitWrite :: Socket a -> IO ()
z85Encode :: MonadIO m => Restricted Div4 ByteString -> m ByteString
z85Decode :: MonadIO m => Restricted Div5 ByteString -> m ByteString

-- | Starts built-in 0MQ proxy (cf. <a>zmq_proxy</a>)
--   
--   Proxy connects front to back socket
--   
--   Before calling proxy all sockets should be bound
--   
--   If the capture socket is not Nothing, the proxy shall send all
--   messages, received on both frontend and backend, to the capture
--   socket.
proxy :: Socket a -> Socket b -> Maybe (Socket c) -> IO ()

-- | Generate a new curve key pair. (cf. <a>zmq_curve_keypair</a>)
curveKeyPair :: MonadIO m => m (Restricted Div5 ByteString, Restricted Div5 ByteString)
instance Typeable Pair
instance Typeable Pub
instance Typeable Sub
instance Typeable XPub
instance Typeable XSub
instance Typeable Req
instance Typeable Rep
instance Typeable Dealer
instance Typeable Router
instance Typeable Pull
instance Typeable Push
instance Typeable Stream
instance Eq Pair
instance Generic Pair
instance Eq Pub
instance Generic Pub
instance Eq Sub
instance Generic Sub
instance Eq XPub
instance Generic XPub
instance Eq XSub
instance Generic XSub
instance Eq Req
instance Generic Req
instance Eq Rep
instance Generic Rep
instance Eq Dealer
instance Generic Dealer
instance Eq Router
instance Generic Router
instance Eq Pull
instance Generic Pull
instance Eq Push
instance Generic Push
instance Eq Stream
instance Generic Stream
instance Eq Event
instance Ord Event
instance Read Event
instance Show Event
instance Datatype D1Pair
instance Constructor C1_0Pair
instance Datatype D1Pub
instance Constructor C1_0Pub
instance Datatype D1Sub
instance Constructor C1_0Sub
instance Datatype D1XPub
instance Constructor C1_0XPub
instance Datatype D1XSub
instance Constructor C1_0XSub
instance Datatype D1Req
instance Constructor C1_0Req
instance Datatype D1Rep
instance Constructor C1_0Rep
instance Datatype D1Dealer
instance Constructor C1_0Dealer
instance Datatype D1Router
instance Constructor C1_0Router
instance Datatype D1Pull
instance Constructor C1_0Pull
instance Datatype D1Push
instance Constructor C1_0Push
instance Datatype D1Stream
instance Constructor C1_0Stream
instance Receiver Stream
instance Sender Stream
instance SocketType Stream
instance Conflatable Push
instance Sender Push
instance SocketType Push
instance Conflatable Pull
instance Receiver Pull
instance SocketType Pull
instance SendProbe Router
instance Receiver Router
instance Sender Router
instance SocketType Router
instance SendProbe Dealer
instance Conflatable Dealer
instance Receiver Dealer
instance Sender Dealer
instance SocketType Dealer
instance Receiver Rep
instance Sender Rep
instance SocketType Rep
instance SendProbe Req
instance Receiver Req
instance Sender Req
instance SocketType Req
instance Receiver XSub
instance Sender XSub
instance SocketType XSub
instance Receiver XPub
instance Sender XPub
instance SocketType XPub
instance Conflatable Sub
instance Receiver Sub
instance Subscriber Sub
instance SocketType Sub
instance Conflatable Pub
instance Sender Pub
instance SocketType Pub
instance Receiver Pair
instance Sender Pair
instance SocketType Pair


-- | This modules exposes a monadic interface of <a>ZMQ4</a>. Actions run
--   inside a <a>ZMQ</a> monad and <a>Socket</a>s are guaranteed not to
--   leak outside their corresponding <a>runZMQ</a> scope. Running
--   <a>ZMQ</a> computations asynchronously is directly supported through
--   <a>async</a>.
module System.ZMQ4.Monadic

-- | The ZMQ monad is modeled after <a>ST</a> and encapsulates a
--   <a>Context</a>. It uses the uninstantiated type variable <tt>z</tt> to
--   distinguish different invoctions of <a>runZMQ</a> and to prevent
--   unintented use of <a>Socket</a>s outside their scope. Cf. the paper of
--   John Launchbury and Simon Peyton Jones <i>Lazy Functional State
--   Threads</i>.
data ZMQ z a

-- | The ZMQ socket, parameterised by <tt>SocketType</tt> and belonging to
--   a particular <a>ZMQ</a> thread.
data Socket z t

-- | Flags to apply on send operations (cf. man zmq_send)
data Flag

-- | ZMQ_DONTWAIT (Only relevant on Windows.)
DontWait :: Flag

-- | ZMQ_SNDMORE
SendMore :: Flag

-- | Configuration switch
data Switch

-- | Use default setting
Default :: Switch

-- | Activate setting
On :: Switch

-- | De-activate setting
Off :: Switch
type Timeout = Int64

-- | Socket events.
data Event

-- | <tt>ZMQ_POLLIN</tt> (incoming messages)
In :: Event

-- | <tt>ZMQ_POLLOUT</tt> (outgoing messages, i.e. at least 1 byte can be
--   written)
Out :: Event

-- | <pre>
--   ZMQ_POLLERR
--   </pre>
Err :: Event

-- | Event types to monitor.
data EventType
ConnectedEvent :: EventType
ConnectDelayedEvent :: EventType
ConnectRetriedEvent :: EventType
ListeningEvent :: EventType
BindFailedEvent :: EventType
AcceptedEvent :: EventType
AcceptFailedEvent :: EventType
ClosedEvent :: EventType
CloseFailedEvent :: EventType
DisconnectedEvent :: EventType
MonitorStoppedEvent :: EventType
AllEvents :: EventType

-- | Event Message to receive when monitoring socket events.
data EventMsg
Connected :: !ByteString -> !Fd -> EventMsg
ConnectDelayed :: !ByteString -> EventMsg
ConnectRetried :: !ByteString -> !Int -> EventMsg
Listening :: !ByteString -> !Fd -> EventMsg
BindFailed :: !ByteString -> !Int -> EventMsg
Accepted :: !ByteString -> !Fd -> EventMsg
AcceptFailed :: !ByteString -> !Int -> EventMsg
Closed :: !ByteString -> !Fd -> EventMsg
CloseFailed :: !ByteString -> !Int -> EventMsg
Disconnected :: !ByteString -> !Fd -> EventMsg
MonitorStopped :: !ByteString -> !Int -> EventMsg

-- | A <a>Poll</a> value contains the object to poll (a 0MQ socket or a
--   file descriptor), the set of <a>Event</a>s which are of interest
--   and--optionally-- a callback-function which is invoked iff the set of
--   interested events overlaps with the actual events.
data Poll s m
Sock :: s t -> [Event] -> Maybe ([Event] -> m ()) -> Poll s m
File :: Fd -> [Event] -> Maybe ([Event] -> m ()) -> Poll s m
data KeyFormat a
BinaryFormat :: KeyFormat Div4
TextFormat :: KeyFormat Div5
data SecurityMechanism
Null :: SecurityMechanism
Plain :: SecurityMechanism
Curve :: SecurityMechanism

-- | Socket types.
class SocketType a

-- | Sockets which can <a>send</a>.
class Sender a

-- | Sockets which can <a>receive</a>.
class Receiver a

-- | Sockets which can <a>subscribe</a>.
class Subscriber a
class SocketLike s

-- | Sockets which can be <a>conflate</a>d.
class Conflatable a

-- | Sockets which can send probes (cf. <a>setProbeRouter</a>).
class SendProbe a

-- | <a>ZMQ_PAIR</a>
data Pair
Pair :: Pair

-- | <a>ZMQ_PUB</a>
data Pub
Pub :: Pub

-- | <a>ZMQ_SUB</a>
data Sub
Sub :: Sub

-- | <a>ZMQ_XPUB</a>
data XPub
XPub :: XPub

-- | <a>ZMQ_XSUB</a>
data XSub
XSub :: XSub

-- | <a>ZMQ_REQ</a>
data Req
Req :: Req

-- | <a>ZMQ_REP</a>
data Rep
Rep :: Rep

-- | <a>ZMQ_DEALER</a>
data Dealer
Dealer :: Dealer

-- | <a>ZMQ_ROUTER</a>
data Router
Router :: Router

-- | <a>ZMQ_PULL</a>
data Pull
Pull :: Pull

-- | <a>ZMQ_PUSH</a>
data Push
Push :: Push

-- | <a>ZMQ_STREAM</a>
data Stream
Stream :: Stream
version :: ZMQ z (Int, Int, Int)

-- | Return the value computed by the given <a>ZMQ</a> monad. Rank-2
--   polymorphism is used to prevent leaking of <tt>z</tt>. An invocation
--   of <a>runZMQ</a> will internally create a <a>Context</a> and all
--   actions are executed relative to this context. On finish the context
--   will be disposed, but see <a>async</a>.
runZMQ :: MonadIO m => (forall z. ZMQ z a) -> m a

-- | Run the given <a>ZMQ</a> computation asynchronously, i.e. this
--   function runs the computation in a new thread using <a>async</a>.
--   <i>N.B.</i> reference counting is used to prolong the lifetime of the
--   <a>Context</a> encapsulated in <a>ZMQ</a> as necessary, e.g.:
--   
--   <pre>
--   runZMQ $ do
--       s &lt;- socket Pair
--       async $ do
--           liftIO (threadDelay 10000000)
--           identity s &gt;&gt;= liftIO . print
--   </pre>
--   
--   Here, <a>runZMQ</a> will finish before the code section in
--   <a>async</a>, but due to reference counting, the <a>Context</a> will
--   only be disposed after <a>async</a> finishes as well.
async :: ZMQ z a -> ZMQ z (Async a)
socket :: SocketType t => t -> ZMQ z (Socket z t)
ioThreads :: ZMQ z Word
maxSockets :: ZMQ z Word
setIoThreads :: Word -> ZMQ z ()
setMaxSockets :: Word -> ZMQ z ()
close :: Socket z t -> ZMQ z ()
bind :: Socket z t -> String -> ZMQ z ()
unbind :: Socket z t -> String -> ZMQ z ()
connect :: Socket z t -> String -> ZMQ z ()
disconnect :: Socket z t -> String -> ZMQ z ()
send :: Sender t => Socket z t -> [Flag] -> ByteString -> ZMQ z ()
send' :: Sender t => Socket z t -> [Flag] -> ByteString -> ZMQ z ()
sendMulti :: Sender t => Socket z t -> NonEmpty ByteString -> ZMQ z ()
receive :: Receiver t => Socket z t -> ZMQ z ByteString
receiveMulti :: Receiver t => Socket z t -> ZMQ z [ByteString]
subscribe :: Subscriber t => Socket z t -> ByteString -> ZMQ z ()
unsubscribe :: Subscriber t => Socket z t -> ByteString -> ZMQ z ()
proxy :: Socket z a -> Socket z b -> Maybe (Socket z c) -> ZMQ z ()
monitor :: [EventType] -> Socket z t -> ZMQ z (Bool -> IO (Maybe EventMsg))
socketMonitor :: [EventType] -> String -> Socket z t -> ZMQ z ()

-- | Polls for events on the given <a>Poll</a> descriptors. Returns a list
--   of events per descriptor which have occured. (cf. <a>zmq_poll</a>)
poll :: (SocketLike s, MonadIO m) => Timeout -> [Poll s m] -> m [[Event]]
affinity :: Socket z t -> ZMQ z Word64
backlog :: Socket z t -> ZMQ z Int
conflate :: Conflatable t => Socket z t -> ZMQ z Bool
curvePublicKey :: KeyFormat f -> Socket z t -> ZMQ z ByteString
curveSecretKey :: KeyFormat f -> Socket z t -> ZMQ z ByteString
curveServerKey :: KeyFormat f -> Socket z t -> ZMQ z ByteString

-- | <i>Deprecated: Use immediate</i>
delayAttachOnConnect :: Socket z t -> ZMQ z Bool
events :: Socket z t -> ZMQ z [Event]
fileDescriptor :: Socket z t -> ZMQ z Fd
identity :: Socket z t -> ZMQ z ByteString
immediate :: Socket z t -> ZMQ z Bool

-- | <i>Deprecated: Use ipv6</i>
ipv4Only :: Socket z t -> ZMQ z Bool
ipv6 :: Socket z t -> ZMQ z Bool
lastEndpoint :: Socket z t -> ZMQ z String
linger :: Socket z t -> ZMQ z Int
maxMessageSize :: Socket z t -> ZMQ z Int64
mcastHops :: Socket z t -> ZMQ z Int
mechanism :: Socket z t -> ZMQ z SecurityMechanism
moreToReceive :: Socket z t -> ZMQ z Bool
plainServer :: Socket z t -> ZMQ z Bool
plainPassword :: Socket z t -> ZMQ z ByteString
plainUserName :: Socket z t -> ZMQ z ByteString
rate :: Socket z t -> ZMQ z Int
receiveBuffer :: Socket z t -> ZMQ z Int
receiveHighWM :: Socket z t -> ZMQ z Int
receiveTimeout :: Socket z t -> ZMQ z Int
reconnectInterval :: Socket z t -> ZMQ z Int
reconnectIntervalMax :: Socket z t -> ZMQ z Int
recoveryInterval :: Socket z t -> ZMQ z Int
sendBuffer :: Socket z t -> ZMQ z Int
sendHighWM :: Socket z t -> ZMQ z Int
sendTimeout :: Socket z t -> ZMQ z Int
tcpKeepAlive :: Socket z t -> ZMQ z Switch
tcpKeepAliveCount :: Socket z t -> ZMQ z Int
tcpKeepAliveIdle :: Socket z t -> ZMQ z Int
tcpKeepAliveInterval :: Socket z t -> ZMQ z Int
zapDomain :: Socket z t -> ZMQ z ByteString
setAffinity :: Word64 -> Socket z t -> ZMQ z ()
setBacklog :: Integral i => Restricted (N0, Int32) i -> Socket z t -> ZMQ z ()
setConflate :: Conflatable t => Bool -> Socket z t -> ZMQ z ()
setCurveServer :: Bool -> Socket z t -> ZMQ z ()
setCurvePublicKey :: KeyFormat f -> Restricted f ByteString -> Socket z t -> ZMQ z ()
setCurveSecretKey :: KeyFormat f -> Restricted f ByteString -> Socket z t -> ZMQ z ()
setCurveServerKey :: KeyFormat f -> Restricted f ByteString -> Socket z t -> ZMQ z ()

-- | <i>Deprecated: Use setImmediate</i>
setDelayAttachOnConnect :: Bool -> Socket z t -> ZMQ z ()
setIdentity :: Restricted (N1, N254) ByteString -> Socket z t -> ZMQ z ()
setImmediate :: Bool -> Socket z t -> ZMQ z ()

-- | <i>Deprecated: Use setIpv6</i>
setIpv4Only :: Bool -> Socket z t -> ZMQ z ()
setIpv6 :: Bool -> Socket z t -> ZMQ z ()
setLinger :: Integral i => Restricted (Nneg1, Int32) i -> Socket z t -> ZMQ z ()
setMaxMessageSize :: Integral i => Restricted (Nneg1, Int64) i -> Socket z t -> ZMQ z ()
setMcastHops :: Integral i => Restricted (N1, Int32) i -> Socket z t -> ZMQ z ()
setPlainServer :: Bool -> Socket z t -> ZMQ z ()
setPlainPassword :: Restricted (N1, N254) ByteString -> Socket z t -> ZMQ z ()
setPlainUserName :: Restricted (N1, N254) ByteString -> Socket z t -> ZMQ z ()
setProbeRouter :: SendProbe t => Bool -> Socket z t -> ZMQ z ()
setRate :: Integral i => Restricted (N1, Int32) i -> Socket z t -> ZMQ z ()
setReceiveBuffer :: Integral i => Restricted (N0, Int32) i -> Socket z t -> ZMQ z ()
setReceiveHighWM :: Integral i => Restricted (N0, Int32) i -> Socket z t -> ZMQ z ()
setReceiveTimeout :: Integral i => Restricted (Nneg1, Int32) i -> Socket z t -> ZMQ z ()
setReconnectInterval :: Integral i => Restricted (N0, Int32) i -> Socket z t -> ZMQ z ()
setReconnectIntervalMax :: Integral i => Restricted (N0, Int32) i -> Socket z t -> ZMQ z ()
setRecoveryInterval :: Integral i => Restricted (N0, Int32) i -> Socket z t -> ZMQ z ()
setReqCorrelate :: Bool -> Socket z Req -> ZMQ z ()
setReqRelaxed :: Bool -> Socket z Req -> ZMQ z ()
setRouterMandatory :: Bool -> Socket z Router -> ZMQ z ()
setSendBuffer :: Integral i => Restricted (N0, Int32) i -> Socket z t -> ZMQ z ()
setSendHighWM :: Integral i => Restricted (N0, Int32) i -> Socket z t -> ZMQ z ()
setSendTimeout :: Integral i => Restricted (Nneg1, Int32) i -> Socket z t -> ZMQ z ()
setTcpAcceptFilter :: Maybe ByteString -> Socket z t -> ZMQ z ()
setTcpKeepAlive :: Switch -> Socket z t -> ZMQ z ()
setTcpKeepAliveCount :: Integral i => Restricted (Nneg1, Int32) i -> Socket z t -> ZMQ z ()
setTcpKeepAliveIdle :: Integral i => Restricted (Nneg1, Int32) i -> Socket z t -> ZMQ z ()
setTcpKeepAliveInterval :: Integral i => Restricted (Nneg1, Int32) i -> Socket z t -> ZMQ z ()
setXPubVerbose :: Bool -> Socket z XPub -> ZMQ z ()

-- | ZMQError encapsulates information about errors, which occur when using
--   the native 0MQ API, such as error number and message.
data ZMQError

-- | Error number value.
errno :: ZMQError -> Int

-- | Source where this error originates from.
source :: ZMQError -> String

-- | Actual error message.
message :: ZMQError -> String

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Create a restricted value. If the given value does not satisfy the
--   restrictions, a modified variant is used instead, e.g. if an integer
--   is larger than the upper bound, the upper bound value is used.
restrict :: Restriction r v => v -> Restricted r v

-- | Create a restricted value. Returns <a>Nothing</a> if the given value
--   does not satisfy all restrictions.
toRestricted :: Restriction r v => v -> Maybe (Restricted r v)
waitRead :: Socket z t -> ZMQ z ()
waitWrite :: Socket z t -> ZMQ z ()
z85Encode :: MonadIO m => Restricted Div4 ByteString -> m ByteString
z85Decode :: MonadIO m => Restricted Div5 ByteString -> m ByteString

-- | Generate a new curve key pair. (cf. <a>zmq_curve_keypair</a>)
curveKeyPair :: MonadIO m => m (Restricted Div5 ByteString, Restricted Div5 ByteString)
instance Applicative (ZMQ z)
instance Functor (ZMQ z)
instance MonadMask (ZMQ z)
instance MonadCatch (ZMQ z)
instance MonadThrow (ZMQ z)
instance MonadIO (ZMQ z)
instance Monad (ZMQ z)
instance SocketLike (Socket z)
