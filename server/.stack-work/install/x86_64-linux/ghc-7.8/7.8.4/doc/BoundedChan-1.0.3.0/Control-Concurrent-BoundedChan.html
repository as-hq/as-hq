<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Concurrent.BoundedChan</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Concurrent-BoundedChan.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">BoundedChan-1.0.3.0: Implementation of bounded channels.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Control.Concurrent.BoundedChan</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Implements bounded channels. These channels differ from normal <code>Chan</code>s in
 that they are guaranteed to contain no more than a certain number of
 elements. This is ideal when you may be writing to a channel faster than you
 are able to read from it.</p><p>This module supports all the functions of <a href="../base-4.7.0.2/Control-Concurrent-Chan.html">Control.Concurrent.Chan</a> except
 <code>unGetChan</code> and <code>dupChan</code>, which are not supported for bounded channels.</p><p>Extra consitency: This version enforces that if thread Alice writes
 e1 followed by e2 then e1 will be returned by readChan before e2.
 Conversely, if thead Bob reads e1 followed by e2 then it was true that
 writeChan e1 preceded writeChan e2.</p><p>Previous versions did not enforce this consistency: if writeChan were
 preempted between putMVars or killThread arrived between putMVars then it
 can fail.  Similarly it might fail if readChan were stopped after putMVar
 and before the second takeMVar.  An unlucky pattern of several such deaths
 might actually break the invariants of the array in an unrecoverable way
 causing all future reads and writes to block.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:BoundedChan">BoundedChan</a> a</li><li class="src short"><a href="#v:newBoundedChan">newBoundedChan</a> ::  <a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> (<a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a)</li><li class="src short"><a href="#v:writeChan">writeChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:tryWriteChan">tryWriteChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:readChan">readChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> a</li><li class="src short"><a href="#v:tryReadChan">tryReadChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> (<a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:isEmptyChan">isEmptyChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:getChanContents">getChanContents</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> [a]</li><li class="src short"><a href="#v:writeList2Chan">writeList2Chan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; [a] -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> ()</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:BoundedChan" class="def">BoundedChan</a> a</p><div class="doc"><p><code><a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a></code> is an abstract data type representing a bounded channel.</p></div></div><div class="top"><p class="src"><a name="v:newBoundedChan" class="def">newBoundedChan</a> ::  <a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a> -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> (<a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a)</p><div class="doc"><p><code>newBoundedChan n</code> returns a channel than can contain no more than <code>n</code>
 elements.</p></div></div><div class="top"><p class="src"><a name="v:writeChan" class="def">writeChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> ()</p><div class="doc"><p>Write an element to the channel. If the channel is full, this routine will
 block until it is able to write.  Blockers wait in a fair FIFO queue.</p></div></div><div class="top"><p class="src"><a name="v:tryWriteChan" class="def">tryWriteChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><p>A variant of <code><a href="Control-Concurrent-BoundedChan.html#v:writeChan">writeChan</a></code> which, instead of blocking when the channel is
 full, simply aborts and does not write the element. Note that this routine
 can still block while waiting for write access to the channel.</p></div></div><div class="top"><p class="src"><a name="v:readChan" class="def">readChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> a</p><div class="doc"><p>Read an element from the channel. If the channel is empty, this routine
 will block until it is able to read.  Blockers wait in a fair FIFO queue.</p></div></div><div class="top"><p class="src"><a name="v:tryReadChan" class="def">tryReadChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> (<a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> a)</p><div class="doc"><p>A variant of <code><a href="Control-Concurrent-BoundedChan.html#v:readChan">readChan</a></code> which, instead of blocking when the channel is
 empty, immediately returns <code><a href="../base-4.7.0.2/Data-Maybe.html#v:Nothing">Nothing</a></code>. Otherwise, <code><a href="Control-Concurrent-BoundedChan.html#v:tryReadChan">tryReadChan</a></code> returns
 <code><code><a href="../base-4.7.0.2/Data-Maybe.html#v:Just">Just</a></code> a</code> where <code>a</code> is the element read from the channel. Note that this
 routine can still block while waiting for read access to the channel.</p></div></div><div class="top"><p class="src"><a name="v:isEmptyChan" class="def">isEmptyChan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> <a href="../base-4.7.0.2/Data-Bool.html#t:Bool">Bool</a></p><div class="doc"><div class="warning"><p>Deprecated: This isEmptyChan can block, no non-blocking substitute yet</p></div><p>DANGER: This may block on an empty channel if there is already a blocked reader.
 Returns <code><a href="../base-4.7.0.2/Data-Bool.html#v:True">True</a></code> if the supplied channel is empty.</p><p>DEPRECATED</p></div></div><div class="top"><p class="src"><a name="v:getChanContents" class="def">getChanContents</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> [a]</p><div class="doc"><p>Return a lazy list representing the contents of the supplied channel.  Competing
 readers might steal from this list.</p></div></div><div class="top"><p class="src"><a name="v:writeList2Chan" class="def">writeList2Chan</a> ::  <a href="Control-Concurrent-BoundedChan.html#t:BoundedChan">BoundedChan</a> a -&gt; [a] -&gt; <a href="../base-4.7.0.2/System-IO.html#t:IO">IO</a> ()</p><div class="doc"><p>Write a list of elements to the channel. If the channel becomes full, this
 routine will block until it is able to write.  Competing writers may interleave with
 this one.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>