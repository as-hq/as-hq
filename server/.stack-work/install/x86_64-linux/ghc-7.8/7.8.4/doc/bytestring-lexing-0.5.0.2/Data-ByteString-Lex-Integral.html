<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.ByteString.Lex.Integral</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-ByteString-Lex-Integral.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">bytestring-lexing-0.5.0.2: Parse and produce literals efficiently from strict or lazy bytestrings.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Copyright (c) 2010--2015 wren gayle romano</td></tr><tr><th>License</th><td>BSD2</td></tr><tr><th>Maintainer</th><td>wren@community.haskell.org</td></tr><tr><th>Stability</th><td>provisional</td></tr><tr><th>Portability</th><td>Haskell98</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.ByteString.Lex.Integral</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">General combinators</a></li><li><a href="#g:2">Decimal conversions</a></li><li><a href="#g:3">Hexadecimal conversions</a></li><li><a href="#g:4">Octal conversions</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Functions for parsing and producing <code><a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a></code> values from/to
 <code><a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code>s based on the &quot;Char8&quot; encoding. That is, we assume
 an ASCII-compatible encoding of alphanumeric characters.</p><p><em>Since: 0.3.0</em></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:readSigned">readSigned</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Num">Num</a> a =&gt; (<a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)) -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:readDecimal">readDecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:readDecimal_">readDecimal_</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a</li><li class="src short"><a href="#v:packDecimal">packDecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:readHexadecimal">readHexadecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:packHexadecimal">packHexadecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:asHexadecimal">asHexadecimal</a> :: <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:readOctal">readOctal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:packOctal">packOctal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></li></ul></div><div id="interface"><h1 id="g:1">General combinators</h1><div class="top"><p class="src"><a name="v:readSigned" class="def">readSigned</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Num">Num</a> a =&gt; (<a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)) -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>Adjust a reading function to recognize an optional leading
 sign. As with the other functions, we assume an ASCII-compatible
 encoding of the sign characters.</p></div></div><h1 id="g:2">Decimal conversions</h1><div class="top"><p class="src"><a name="v:readDecimal" class="def">readDecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>Read an unsigned/non-negative integral value in ASCII decimal
 format. Returns <code>Nothing</code> if there is no integer at the beginning
 of the string, otherwise returns <code>Just</code> the integer read and the
 remainder of the string.</p><p>If you are extremely concerned with performance, then it is more
 performant to use this function at <code>Int</code> or <code>Word</code> and then to
 call <code><a href="../base-4.7.0.2/Prelude.html#v:fromIntegral">fromIntegral</a></code> to perform the conversion at the end. However,
 doing this will make your code succeptible to overflow bugs if
 the target type is larger than <code>Int</code>.</p></div></div><div class="top"><p class="src"><a name="v:readDecimal_" class="def">readDecimal_</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a</p><div class="doc"><p>A variant of <code><a href="Data-ByteString-Lex-Integral.html#v:readDecimal">readDecimal</a></code> which does not return the tail of
 the string, and returns <code>0</code> instead of <code>Nothing</code>. This is twice
 as fast for <code><a href="../base-4.7.0.2/Data-Int.html#t:Int64">Int64</a></code> on 32-bit systems, but has identical performance
 to <code><a href="Data-ByteString-Lex-Integral.html#v:readDecimal">readDecimal</a></code> for all other types and architectures.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a name="v:packDecimal" class="def">packDecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Convert a non-negative integer into an (unsigned) ASCII decimal
 string. Returns <code>Nothing</code> on negative inputs.</p></div></div><h1 id="g:3">Hexadecimal conversions</h1><div class="top"><p class="src"><a name="v:readHexadecimal" class="def">readHexadecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>Read a non-negative integral value in ASCII hexadecimal format.
 Returns <code>Nothing</code> if there is no integer at the beginning of the
 string, otherwise returns <code>Just</code> the integer read and the remainder
 of the string.</p><p>This function does not recognize the various hexadecimal sigils
 like &quot;0x&quot;, but because there are so many different variants,
 those are best handled by helper functions which then use this
 function for the actual numerical parsing. This function recognizes
 both upper-case, lower-case, and mixed-case hexadecimal.</p></div></div><div class="top"><p class="src"><a name="v:packHexadecimal" class="def">packHexadecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Convert a non-negative integer into a lower-case ASCII hexadecimal
 string. Returns <code>Nothing</code> on negative inputs.</p></div></div><div class="top"><p class="src"><a name="v:asHexadecimal" class="def">asHexadecimal</a> :: <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Convert a bitvector into a lower-case ASCII hexadecimal string.
 This is helpful for visualizing raw binary data, rather than for
 parsing as such.</p></div></div><h1 id="g:4">Octal conversions</h1><div class="top"><p class="src"><a name="v:readOctal" class="def">readOctal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>Read a non-negative integral value in ASCII octal format.
 Returns <code>Nothing</code> if there is no integer at the beginning of the
 string, otherwise returns <code>Just</code> the integer read and the remainder
 of the string.</p><p>This function does not recognize the various octal sigils like
 &quot;0o&quot;, but because there are different variants, those are best
 handled by helper functions which then use this function for the
 actual numerical parsing.</p></div></div><div class="top"><p class="src"><a name="v:packOctal" class="def">packOctal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></p><div class="doc"><p>Convert a non-negative integer into an ASCII octal string.
 Returns <code>Nothing</code> on negative inputs.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>