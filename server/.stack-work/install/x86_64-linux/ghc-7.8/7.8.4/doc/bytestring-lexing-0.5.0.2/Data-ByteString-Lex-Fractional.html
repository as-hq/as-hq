<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.ByteString.Lex.Fractional</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-ByteString-Lex-Fractional.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">bytestring-lexing-0.5.0.2: Parse and produce literals efficiently from strict or lazy bytestrings.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Copyright (c) 2015 wren gayle romano</td></tr><tr><th>License</th><td>BSD2</td></tr><tr><th>Maintainer</th><td>wren@community.haskell.org</td></tr><tr><th>Stability</th><td>provisional</td></tr><tr><th>Portability</th><td>Haskell98 + ScopedTypeVariables</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.ByteString.Lex.Fractional</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">General combinators</a></li><li><a href="#g:2">Decimal conversions</a></li><li><a href="#g:3">Hexadecimal conversions</a></li><li><a href="#g:4">Octal conversions</a></li><li><a href="#g:5">Exponential conversions</a></li><li><a href="#g:6">Precision-limited conversions</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Functions for parsing and producing <code><a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a></code> values from/to
 <code><a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a></code>s based on the &quot;Char8&quot; encoding. That is, we assume
 an ASCII-compatible encoding of alphanumeric characters.</p><p><em>Since: 0.5.0</em></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:readSigned">readSigned</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Num">Num</a> a =&gt; (<a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)) -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:readDecimal">readDecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:readHexadecimal">readHexadecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:readOctal">readOctal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:readExponential">readExponential</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:decimalPrecision">decimalPrecision</a> :: <span class="keyword">forall</span> proxy a. <a href="../base-4.7.0.2/Prelude.html#t:RealFloat">RealFloat</a> a =&gt; proxy a -&gt; <a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:readDecimalLimited">readDecimalLimited</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a> -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:readExponentialLimited">readExponentialLimited</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a> -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</li></ul></div><div id="interface"><h1 id="g:1">General combinators</h1><div class="top"><p class="src"><a name="v:readSigned" class="def">readSigned</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Num">Num</a> a =&gt; (<a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)) -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>Adjust a reading function to recognize an optional leading
 sign. As with the other functions, we assume an ASCII-compatible
 encoding of the sign characters.</p></div></div><h1 id="g:2">Decimal conversions</h1><div class="top"><p class="src"><a name="v:readDecimal" class="def">readDecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>Read an unsigned/non-negative fractional value in ASCII decimal
 format; that is, anything matching the regex <code>\d+(\.\d+)?</code>.
 Returns <code>Nothing</code> if there is no such number at the beginning
 of the string, otherwise returns <code>Just</code> the number read and the
 remainder of the string.</p><p>N.B., see <code><a href="Data-ByteString-Lex-Fractional.html#v:readDecimalLimited">readDecimalLimited</a></code> if your fractional type has limited
 precision and you expect your inputs to have greater precision
 than can be represented. Even for types with unlimited precision
 (e.g., <code><a href="../base-4.7.0.2/Prelude.html#t:Rational">Rational</a></code>), you may want to check out <code><a href="Data-ByteString-Lex-Fractional.html#v:readDecimalLimited">readDecimalLimited</a></code>.</p></div></div><h1 id="g:3">Hexadecimal conversions</h1><div class="top"><p class="src"><a name="v:readHexadecimal" class="def">readHexadecimal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>Read a non-negative integral value in ASCII hexadecimal format.
 Returns <code>Nothing</code> if there is no integer at the beginning of the
 string, otherwise returns <code>Just</code> the integer read and the remainder
 of the string.</p><p>This function does not recognize the various hexadecimal sigils
 like &quot;0x&quot;, but because there are so many different variants,
 those are best handled by helper functions which then use this
 function for the actual numerical parsing. This function recognizes
 both upper-case, lower-case, and mixed-case hexadecimal.</p></div></div><h1 id="g:4">Octal conversions</h1><div class="top"><p class="src"><a name="v:readOctal" class="def">readOctal</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>Read a non-negative integral value in ASCII octal format.
 Returns <code>Nothing</code> if there is no integer at the beginning of the
 string, otherwise returns <code>Just</code> the integer read and the remainder
 of the string.</p><p>This function does not recognize the various octal sigils like
 &quot;0o&quot;, but because there are different variants, those are best
 handled by helper functions which then use this function for the
 actual numerical parsing.</p></div></div><h1 id="g:5">Exponential conversions</h1><div class="top"><p class="src"><a name="v:readExponential" class="def">readExponential</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>Read an unsigned/non-negative fractional value in ASCII
 exponential format; that is, anything matching the regex
 <code>\d+(\.\d+)?([eE][\+\-]?\d+)?</code>. Returns <code>Nothing</code> if there
 is no such number at the beginning of the string, otherwise
 returns <code>Just</code> the number read and the remainder of the string.</p><p>N.B., the current implementation assumes the exponent is small
 enough to fit into an <code><a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a></code>. This gives a significant performance
 increase for <code>a ~ Float</code> and <code>a ~ Double</code> and agrees with the
 <code><a href="../base-4.7.0.2/Prelude.html#t:RealFloat">RealFloat</a></code> class which has <code><a href="../base-4.7.0.2/Prelude.html#v:exponent">exponent</a></code> returning an <code><a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a></code>. If
 you need a larger exponent, contact the maintainer.</p><p>N.B., see <code><a href="Data-ByteString-Lex-Fractional.html#v:readExponentialLimited">readExponentialLimited</a></code> if your fractional type has
 limited precision and you expect your inputs to have greater
 precision than can be represented. Even for types with unlimited
 precision, you may want to check out <code><a href="Data-ByteString-Lex-Fractional.html#v:readExponentialLimited">readExponentialLimited</a></code>.</p></div></div><h1 id="g:6">Precision-limited conversions</h1><div class="top"><p class="src"><a name="v:decimalPrecision" class="def">decimalPrecision</a> :: <span class="keyword">forall</span> proxy a. <a href="../base-4.7.0.2/Prelude.html#t:RealFloat">RealFloat</a> a =&gt; proxy a -&gt; <a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a></p><div class="doc"><p>Return the <code><a href="../base-4.7.0.2/Prelude.html#t:RealFloat">RealFloat</a></code> type's inherent decimal precision
 limitation. This is the number of decimal digits in <code>floatRadix
 proxy ^ floatDigits proxy</code>.</p></div></div><div class="top"><p class="src"><a name="v:readDecimalLimited" class="def">readDecimalLimited</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a> -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>A variant of <code><a href="Data-ByteString-Lex-Fractional.html#v:readDecimal">readDecimal</a></code> which only reads up to some limited
 precision. The first argument gives the number of decimal digits
 at which to limit the precision.</p><p>For types with inherently limited precision (e.g., <code><a href="../base-4.7.0.2/Prelude.html#t:Float">Float</a></code> and
 <code><a href="../base-4.7.0.2/Prelude.html#t:Double">Double</a></code>), when you pass in the precision limit (cf.,
 <code><a href="Data-ByteString-Lex-Fractional.html#v:decimalPrecision">decimalPrecision</a></code>) this is far more efficient than <code><a href="Data-ByteString-Lex-Fractional.html#v:readDecimal">readDecimal</a></code>.
 However, passing in a precision limit which is greater than the
 type's inherent limitation will degrate performance compared to
 <code><a href="Data-ByteString-Lex-Fractional.html#v:readDecimal">readDecimal</a></code>.</p><p>For types with unlimited precision (e.g., <code><a href="../base-4.7.0.2/Prelude.html#t:Rational">Rational</a></code>) this may
 still be far more efficient than <code><a href="Data-ByteString-Lex-Fractional.html#v:readDecimal">readDecimal</a></code> (it is for
 <code><a href="../base-4.7.0.2/Prelude.html#t:Rational">Rational</a></code>, in fact). The reason being that it delays the scaling
 the significand/mantissa by the exponent, thus allowing you to
 further adjust the exponent before computing the final value
 (e.g., as in <code><a href="Data-ByteString-Lex-Fractional.html#v:readExponentialLimited">readExponentialLimited</a></code>). This avoids the need to
 renormalize intermediate results, and allows faster computation
 of the scaling factor by doing it all at once.</p></div></div><div class="top"><p class="src"><a name="v:readExponentialLimited" class="def">readExponentialLimited</a> :: <a href="../base-4.7.0.2/Prelude.html#t:Fractional">Fractional</a> a =&gt; <a href="../base-4.7.0.2/Data-Int.html#t:Int">Int</a> -&gt; <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="../base-4.7.0.2/Data-Maybe.html#t:Maybe">Maybe</a> (a, <a href="../bytestring-0.10.4.0/Data-ByteString.html#t:ByteString">ByteString</a>)</p><div class="doc"><p>A variant of <code><a href="Data-ByteString-Lex-Fractional.html#v:readExponential">readExponential</a></code> which only reads up to some limited
 precision. The first argument gives the number of decimal digits
 at which to limit the precision. See <code><a href="Data-ByteString-Lex-Fractional.html#v:readDecimalLimited">readDecimalLimited</a></code> for
 more discussion of the performance benefits of using this function.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>