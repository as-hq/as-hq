
==================== FINAL INTERFACE ====================
2015-08-20 07:10:35.640615 UTC

interface alphasheets-0.1.0.0:AS.DAG [orphan module] 7084
  interface hash: cb1f2b99402c14dca872eda8a892204c
  ABI hash: 0220c8f9ab658f790741e16a6fb1054c
  export-list hash: b862f78ad2799c5db977b9ac3cb01a18
  orphan hash: 1eda94703e3fe8b45769c18ee70a6ae7
  flag hash: f8b866267ce58dc6290b8020b2e82f8c
  used TH splices: False
  where
exports:
  AS.DAG.descendants
  AS.DAG.getDescendants
  AS.DAG.getImmediateAncestors
  AS.DAG.image
  AS.DAG.immediateAncestors
  AS.DAG.inverse
  AS.DAG.reachableSet
  AS.DAG.toposort
  AS.DAG.Relation
module dependencies: AS.DB AS.Types AS.Util
package dependencies: SHA-1.6.4.2 aeson-0.8.0.2 array-0.5.0.0
                      attoparsec-0.12.1.6 base base64-bytestring-1.0.0.1 binary-0.7.1.0
                      blaze-builder-0.4.0.1 bytestring-0.10.4.0 case-insensitive-1.2.0.4
                      containers-0.5.5.1 deepseq-1.3.0.2 dlist-0.7.1.1 entropy-0.3.7
                      ghc-prim hashable-1.2.3.3 integer-gmp mtl-2.1.3.1 network-2.6.2.0
                      old-locale-1.0.0.6 primitive-0.6 random-1.1 scientific-0.3.3.8
                      text-1.2.0.6 time-1.4.2 transformers-0.3.0.0 unix-2.7.0.1
                      unordered-containers-0.2.5.1 vector-0.10.12.3 websockets-0.9.5.0
orphans: aeson-0.8.0.2:Data.Aeson.Types.Generic
         aeson-0.8.0.2:Data.Aeson.Types.Instances
         aeson-0.8.0.2:Data.Aeson.Types.Internal
         attoparsec-0.12.1.6:Data.Attoparsec.ByteString.Char8 base:GHC.Base
         base:GHC.Float base:GHC.Real binary-0.7.1.0:Data.Binary.Generic
         bytestring-0.10.4.0:Data.ByteString.Builder
         hashable-1.2.3.3:Data.Hashable.Generic
         network-2.6.2.0:Network.Socket network-2.6.2.0:Network.Socket.Types
         random-1.1:System.Random text-1.2.0.6:Data.Text
         text-1.2.0.6:Data.Text.Lazy time-1.4.2:Data.Time.Calendar.Gregorian
         time-1.4.2:Data.Time.Format.Parse
         time-1.4.2:Data.Time.LocalTime.LocalTime
         transformers-0.3.0.0:Control.Monad.Trans.Error
         vector-0.10.12.3:Data.Vector.Fusion.Stream
         vector-0.10.12.3:Data.Vector.Unboxed
family instance modules: alphasheets-0.1.0.0:AS.Types
                         attoparsec-0.12.1.6:Data.Attoparsec.Internal.Types
                         base:Control.Applicative base:Data.Either base:Data.Monoid
                         base:Data.Type.Equality base:GHC.Exts base:GHC.Generics
                         dlist-0.7.1.1:Data.DList primitive-0.6:Control.Monad.Primitive
                         text-1.2.0.6:Data.Text text-1.2.0.6:Data.Text.Lazy
                         unordered-containers-0.2.5.1:Data.HashMap.Base
                         unordered-containers-0.2.5.1:Data.HashSet
                         vector-0.10.12.3:Data.Vector vector-0.10.12.3:Data.Vector.Primitive
                         vector-0.10.12.3:Data.Vector.Storable
                         vector-0.10.12.3:Data.Vector.Unboxed
                         vector-0.10.12.3:Data.Vector.Unboxed.Base
import  -/  AS.DB b12b1d3c11d94c6f9f9b9f3592040d65
  exports: 3c362108996cc5146ac2250c1b1c6210
  getDAG 143855947bb9e585222d918122997131
import  -/  AS.Types b606c3629b6c721cf8b97ba4ece45fb1
  exports: 66ecab93115eea25472e439473866aa8
  ASLocation c3999fef437ba89bfafc0ba56adaa4e1
import  -/  base:Control.Applicative 30b769206cb5c020684e1bda0d7e7dd3
import  -/  base:Control.Arrow 2ab1918996c07e39950ba6b2c8eaba3e
import  -/  base:Control.Monad 483e787e07c2e49f1fb1c1b88665cb92
import  -/  base:Data.List 8b77870d02d66076337587b759b7ee19
import  -/  base:Data.Tuple cac4e06c48274e85317bd3e59867ef5b
import  -/  base:GHC.Base 5d7c5f596f9a4c8a8abd8517c8bcd5dd
import  -/  base:GHC.List 4cff382327e59a5787355ca0a4174450
import  -/  base:Prelude 74043f272d60acec1777d3461cfe5ef4
import  -/  containers-0.5.5.1:Data.Set 05b98b00cb8b74ae1d4a7864b7acb535
import  -/  containers-0.5.5.1:Data.Set.Base 0a2eac2391f9f760c63f6dd3d84c75e7
import  -/  ghc-prim:GHC.Classes 3e6cbe1e7e80480408cfa8d5450726a0
import  -/  ghc-prim:GHC.Types dcba736fa3dfba12d307ab18354845d2
import  -/  mtl-2.1.3.1:Control.Monad.RWS bc18979e953369b7a525786ffe7fd936
import  -/  mtl-2.1.3.1:Control.Monad.Writer 12775e8d6bf6e36ad1e53bcc01866947
import  -/  mtl-2.1.3.1:Control.Monad.Writer.Class e004b4cb53262ec62aff099025b365e0
import  -/  transformers-0.3.0.0:Control.Monad.Trans.Writer.Lazy 285f7c0f38506f0a36af3e5438ca942b
eebca5e67814b775bce1e2434557d2d1
  $sinsert :: AS.Types.ASLocation
              -> Data.Set.Base.Set AS.Types.ASLocation
              -> Data.Set.Base.Set AS.Types.ASLocation
    {- Arity: 2, Strictness: <S,1*U><S,1*U>,
       Unfolding: (\ eta :: AS.Types.ASLocation
                     eta1 :: Data.Set.Base.Set AS.Types.ASLocation ->
                   AS.DAG.$sinsert_$sgo5 eta eta1) -}
b6112e3b011e3b3b3104ed2d3de353f7
  $sinsert_$sgo5 :: AS.Types.ASLocation
                    -> Data.Set.Base.Set AS.Types.ASLocation
                    -> Data.Set.Base.Set AS.Types.ASLocation
    {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
a17367892443661a0d2efb211c221a8c
  $smember :: AS.Types.ASLocation
              -> Data.Set.Base.Set AS.Types.ASLocation
              -> GHC.Types.Bool
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
       Unfolding: (\ eta :: AS.Types.ASLocation
                     eta1 :: Data.Set.Base.Set AS.Types.ASLocation ->
                   AS.DAG.$smember_go5 eta eta1) -}
2c373b4c5d72d03143981a4226533a6a
  $smember_go5 :: AS.Types.ASLocation
                  -> Data.Set.Base.Set AS.Types.ASLocation
                  -> GHC.Types.Bool
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
368def52035a22e669264b3e4605ca8c
  $wdescendants :: GHC.Classes.Ord a
                   -> [a]
                   -> AS.DAG.Relation a
                   -> [a]
    {- Arity: 3,
       Strictness: <L,U(U(U,U),C(C1(U)),A,A,A,A,A,A)><L,U><S,U>,
       Unfolding: (\ @ a
                     w :: GHC.Classes.Ord a
                     w1 :: [a]
                     w2 :: AS.DAG.Relation a ->
                   case Data.List.intersectBy
                          @ a
                          (GHC.Classes.== @ a (GHC.Classes.$p1Ord @ a w))
                          (AS.DAG.toposort @ a w w2)
                          (Data.Set.Base.toAscList1
                             @ a
                             (GHC.Types.[] @ a)
                             (AS.DAG.reachableSet @ a w w1 w2)) of wild {
                     [] -> w1 : x xs -> wild }) -}
c7056151d81ead33ff4e9b828a724bbd
  $wimmediateAncestors :: GHC.Classes.Ord a
                          -> [a]
                          -> AS.DAG.Relation a
                          -> [a]
    {- Arity: 3, HasNoCafRefs,
       Strictness: <L,1*U(1*U(U,U),A,A,A,A,A,A,A)><S,1*U><L,U>,
       Unfolding: (\ @ a
                     w :: GHC.Classes.Ord a
                     w1 :: [a]
                     w2 :: AS.DAG.Relation a ->
                   let {
                     $dEq :: GHC.Classes.Eq a = GHC.Classes.$p1Ord @ a w
                   } in
                   let {
                     lvl :: a -> a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq
                   } in
                   letrec {
                     go :: [a] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [a] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ a
                         : y ys
                         -> letrec {
                              go1 :: [(a, a)] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                              = \ ds1 :: [(a, a)] ->
                                case ds1 of wild1 {
                                  [] -> GHC.Types.[] @ a
                                  : y1 ys1
                                  -> case y1 of wild2 { (,) x y2 ->
                                     case lvl y2 y of wild3 {
                                       GHC.Types.False -> go1 ys1
                                       GHC.Types.True -> GHC.Types.: @ a x (go1 ys1) } } }
                            } in
                            GHC.Base.++ @ a (go1 w2) (go ys) }
                   } in
                   go w1) -}
7e52c5fd2a10ea14d97fee9b52582709
  type Relation a = [(a, a)]
c113759364febdefa7af105e5a4e228d
  descendants :: GHC.Classes.Eq a
                 -> GHC.Classes.Ord a
                 -> [a]
                 -> AS.DAG.Relation a
                 -> [a]
    {- Arity: 4,
       Strictness: <L,A><L,U(U(U,U),C(C1(U)),A,A,A,A,A,A)><L,U><S,U>,
       Inline: INLINE[0],
       Unfolding: InlineRule (4, True, True)
                  (\ @ a
                     w :: GHC.Classes.Eq a
                     w1 :: GHC.Classes.Ord a
                     w2 :: [a]
                     w3 :: AS.DAG.Relation a ->
                   AS.DAG.$wdescendants @ a w1 w2 w3) -}
cd8426d116da690b06d53949de21131b
  descendants1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                      [AS.Types.ASLocation] Data.Functor.Identity.Identity a1
                  -> (a1
                      -> Control.Monad.Trans.Writer.Lazy.WriterT
                             [AS.Types.ASLocation] Data.Functor.Identity.Identity b)
                  -> Data.Functor.Identity.Identity (b, [AS.Types.ASLocation])
    {- Arity: 2, HasNoCafRefs,
       Unfolding: (\ @ a1
                     @ b
                     w3 :: Control.Monad.Trans.Writer.Lazy.WriterT
                               [AS.Types.ASLocation] Data.Functor.Identity.Identity a1
                     w4 :: a1
                           -> Control.Monad.Trans.Writer.Lazy.WriterT
                                  [AS.Types.ASLocation] Data.Functor.Identity.Identity b ->
                   let {
                     a :: Control.Monad.Trans.Writer.Lazy.WriterT
                              [AS.Types.ASLocation] Data.Functor.Identity.Identity b
                     = w4
                         (case w3
                                 `cast`
                               (Trans
                                    (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                         <[AS.Types.ASLocation]>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <a1>_N)
                                    (Data.Functor.Identity.NTCo:Identity[0]
                                         <(a1, [AS.Types.ASLocation])>_R)) of wild { (,) a2 w5 ->
                          a2 })
                   } in
                   (case a `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[AS.Types.ASLocation]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <b>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(b, [AS.Types.ASLocation])>_R)) of wild { (,) b1 w' ->
                    b1 },
                    case w3
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[AS.Types.ASLocation]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <a1>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(a1, [AS.Types.ASLocation])>_R)) of wild { (,) a2 w5 ->
                    GHC.Base.++
                      @ AS.Types.ASLocation
                      w5
                      (case a `cast`
                            (Trans
                                 (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                      <[AS.Types.ASLocation]>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <b>_N)
                                 (Data.Functor.Identity.NTCo:Identity[0]
                                      <(b, [AS.Types.ASLocation])>_R)) of wild1 { (,) b1 w' ->
                       w' }) })
                     `cast`
                   (Sym (Data.Functor.Identity.NTCo:Identity[0]
                             <(b, [AS.Types.ASLocation])>_R))) -}
75de629f57cabc434c9780c143b23ca1
  descendants2 :: a1 -> (a1, [AS.Types.ASLocation])
    {- Arity: 1, HasNoCafRefs,
       Unfolding: (\ @ a1 a2 :: a1 ->
                   (a2, GHC.Types.[] @ AS.Types.ASLocation)) -}
23168943032c545667785190de491bc0
  descendants3 :: Control.Monad.Trans.Writer.Lazy.WriterT
                      [AS.Types.ASLocation] Data.Functor.Identity.Identity a1
                  -> (a1
                      -> Control.Monad.Trans.Writer.Lazy.WriterT
                             [AS.Types.ASLocation] Data.Functor.Identity.Identity b)
                  -> Data.Functor.Identity.Identity (b, [AS.Types.ASLocation])
    {- Arity: 2, HasNoCafRefs,
       Unfolding: (\ @ a1
                     @ b
                     w3 :: Control.Monad.Trans.Writer.Lazy.WriterT
                               [AS.Types.ASLocation] Data.Functor.Identity.Identity a1
                     w4 :: a1
                           -> Control.Monad.Trans.Writer.Lazy.WriterT
                                  [AS.Types.ASLocation] Data.Functor.Identity.Identity b ->
                   let {
                     a :: Control.Monad.Trans.Writer.Lazy.WriterT
                              [AS.Types.ASLocation] Data.Functor.Identity.Identity b
                     = w4
                         (case w3
                                 `cast`
                               (Trans
                                    (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                         <[AS.Types.ASLocation]>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <a1>_N)
                                    (Data.Functor.Identity.NTCo:Identity[0]
                                         <(a1, [AS.Types.ASLocation])>_R)) of wild { (,) a2 w5 ->
                          a2 })
                   } in
                   (case a `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[AS.Types.ASLocation]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <b>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(b, [AS.Types.ASLocation])>_R)) of wild { (,) b1 w' ->
                    b1 },
                    case w3
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[AS.Types.ASLocation]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <a1>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(a1, [AS.Types.ASLocation])>_R)) of wild { (,) a2 w5 ->
                    GHC.Base.++
                      @ AS.Types.ASLocation
                      w5
                      (case a `cast`
                            (Trans
                                 (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                      <[AS.Types.ASLocation]>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <b>_N)
                                 (Data.Functor.Identity.NTCo:Identity[0]
                                      <(b, [AS.Types.ASLocation])>_R)) of wild1 { (,) b1 w' ->
                       w' }) })
                     `cast`
                   (Sym (Data.Functor.Identity.NTCo:Identity[0]
                             <(b, [AS.Types.ASLocation])>_R))) -}
17e0b97c58c9efc3d42658752c918a55
  descendants_$sdescendants :: [AS.Types.ASLocation]
                               -> AS.DAG.Relation AS.Types.ASLocation
                               -> [AS.Types.ASLocation]
    {- Arity: 2, Strictness: <L,U><S,U>,
       Unfolding: (\ eta :: [AS.Types.ASLocation]
                     eta1 :: AS.DAG.Relation AS.Types.ASLocation ->
                   case Data.List.intersectBy
                          @ AS.Types.ASLocation
                          AS.Types.$fEqASCell_$c==3
                          (AS.DAG.descendants_$stoposort eta1)
                          (Data.Set.Base.toAscList1
                             @ AS.Types.ASLocation
                             (GHC.Types.[] @ AS.Types.ASLocation)
                             (AS.DAG.descendants_$sreachableSet eta eta1)) of wild {
                     [] -> eta : x xs -> wild }) -}
1469a84f6f2021530590a9987c5da8cb
  descendants_$simage :: AS.Types.ASLocation
                         -> AS.DAG.Relation AS.Types.ASLocation
                         -> [AS.Types.ASLocation]
    {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
       Unfolding: (\ x :: AS.Types.ASLocation
                     rel :: AS.DAG.Relation AS.Types.ASLocation ->
                   letrec {
                     go :: [(AS.Types.ASLocation, AS.Types.ASLocation)]
                           -> [AS.Types.ASLocation]
                       {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [(AS.Types.ASLocation, AS.Types.ASLocation)] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ AS.Types.ASLocation
                         : y ys
                         -> case y of wild1 { (,) x' y' ->
                            case AS.Types.$fEqASCell_$c==3 x x' of wild2 {
                              GHC.Types.False -> go ys
                              GHC.Types.True
                              -> GHC.Types.: @ AS.Types.ASLocation y' (go ys) } } }
                   } in
                   go rel) -}
2adcb8c8028f0a82aae7693d42b197bc
  descendants_$sreachableSet :: [AS.Types.ASLocation]
                                -> [(AS.Types.ASLocation, AS.Types.ASLocation)]
                                -> Data.Set.Base.Set AS.Types.ASLocation
    {- Arity: 2, Strictness: <S,1*U><L,U>,
       Unfolding: (\ eta :: [AS.Types.ASLocation]
                     eta1 :: [(AS.Types.ASLocation, AS.Types.ASLocation)] ->
                   letrec {
                     lgo :: Data.Set.Base.Set AS.Types.ASLocation
                            -> [AS.Types.ASLocation]
                            -> Data.Set.Base.Set AS.Types.ASLocation
                       {- Arity: 2, Strictness: <S,U><S,1*U> -}
                     = \ z :: Data.Set.Base.Set AS.Types.ASLocation
                         ds :: [AS.Types.ASLocation] ->
                       case ds of wild {
                         [] -> z : x xs -> case visit z x of z' { DEFAULT -> lgo z' xs } }
                     visit :: Data.Set.Base.Set AS.Types.ASLocation
                              -> AS.Types.ASLocation
                              -> Data.Set.Base.Set AS.Types.ASLocation
                       {- Arity: 2, Strictness: <S,U><S,U> -}
                     = \ visited :: Data.Set.Base.Set AS.Types.ASLocation
                         x :: AS.Types.ASLocation ->
                       case AS.DAG.$smember_go5 x visited of wild {
                         GHC.Types.False
                         -> lgo
                              (AS.DAG.$sinsert_$sgo5 x visited)
                              (AS.DAG.descendants_$simage x eta1)
                         GHC.Types.True -> visited }
                   } in
                   letrec {
                     lgo1 :: Data.Set.Base.Set AS.Types.ASLocation
                             -> [AS.Types.ASLocation]
                             -> Data.Set.Base.Set AS.Types.ASLocation
                       {- Arity: 2, Strictness: <S,U><S,1*U> -}
                     = \ z :: Data.Set.Base.Set AS.Types.ASLocation
                         ds :: [AS.Types.ASLocation] ->
                       case ds of wild {
                         [] -> z : x xs -> case visit z x of z' { DEFAULT -> lgo1 z' xs } }
                   } in
                   lgo1 (Data.Set.Base.Tip @ AS.Types.ASLocation) eta) -}
29a741fdde9e1fe2531bcb16687545e9
  descendants_$stoposort :: [(AS.Types.ASLocation,
                              AS.Types.ASLocation)]
                            -> [AS.Types.ASLocation]
    {- Arity: 1, Strictness: <S,U>,
       Unfolding: (\ dag :: [(AS.Types.ASLocation,
                              AS.Types.ASLocation)] ->
                   let {
                     lvl :: AS.DAG.Relation AS.Types.ASLocation
                     = AS.DAG.descendants_go dag
                   } in
                   let {
                     z :: [AS.Types.ASLocation]
                     = GHC.Base.map
                         @ (AS.Types.ASLocation, AS.Types.ASLocation)
                         @ AS.Types.ASLocation
                         (Data.Tuple.snd @ AS.Types.ASLocation @ AS.Types.ASLocation)
                         dag
                   } in
                   letrec {
                     go :: [(AS.Types.ASLocation, AS.Types.ASLocation)]
                           -> [AS.Types.ASLocation]
                       {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [(AS.Types.ASLocation, AS.Types.ASLocation)] ->
                       case ds of wild {
                         [] -> z
                         : y ys
                         -> GHC.Types.:
                              @ AS.Types.ASLocation
                              (Data.Tuple.fst @ AS.Types.ASLocation @ AS.Types.ASLocation y)
                              (go ys) }
                   } in
                   case (Control.Monad.$wfoldM
                           @ (Data.Set.Base.Set AS.Types.ASLocation)
                           @ AS.Types.ASLocation
                           @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                  [AS.Types.ASLocation] Data.Functor.Identity.Identity)
                           AS.DAG.descendants3
                             `cast`
                           (forall a1 b.
                            <Control.Monad.Trans.Writer.Lazy.WriterT
                                 [AS.Types.ASLocation] Data.Functor.Identity.Identity a1>_R
                            ->_R <a1
                                  -> Control.Monad.Trans.Writer.Lazy.WriterT
                                         [AS.Types.ASLocation] Data.Functor.Identity.Identity b>_R
                            ->_R Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                          <[AS.Types.ASLocation]>_N
                                          <Data.Functor.Identity.Identity>_R
                                          <b>_N))
                           AS.DAG.descendants2
                             `cast`
                           (forall a1.
                            <a1>_R
                            ->_R Trans
                                     (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                               <(a1, [AS.Types.ASLocation])>_R))
                                     (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                               <[AS.Types.ASLocation]>_N
                                               <Data.Functor.Identity.Identity>_R
                                               <a1>_N)))
                           (letrec {
                              visit :: Data.Set.Base.Set AS.Types.ASLocation
                                       -> AS.Types.ASLocation
                                       -> Control.Monad.Trans.Writer.Lazy.WriterT
                                              [AS.Types.ASLocation]
                                              Data.Functor.Identity.Identity
                                              (Data.Set.Base.Set AS.Types.ASLocation)
                                {- Arity: 2, Strictness: <S,U><S,U>m, Inline: INLINE[0],
                                   Unfolding: InlineRule (2, True, False)
                                              (\ w :: Data.Set.Base.Set AS.Types.ASLocation
                                                 w1 :: AS.Types.ASLocation ->
                                               case $wvisit w w1 of ww { (#,#) ww1 ww2 ->
                                               (ww1, ww2)
                                                 `cast`
                                               (Trans
                                                    (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                                              <(Data.Set.Base.Set
                                                                    AS.Types.ASLocation,
                                                                [AS.Types.ASLocation])>_R))
                                                    (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                              <[AS.Types.ASLocation]>_N
                                                              <Data.Functor.Identity.Identity>_R
                                                              <Data.Set.Base.Set
                                                                   AS.Types.ASLocation>_N))) }) -}
                              = \ w :: Data.Set.Base.Set AS.Types.ASLocation
                                  w1 :: AS.Types.ASLocation ->
                                case $wvisit w w1 of ww { (#,#) ww1 ww2 ->
                                (ww1, ww2)
                                  `cast`
                                (Trans
                                     (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                               <(Data.Set.Base.Set AS.Types.ASLocation,
                                                 [AS.Types.ASLocation])>_R))
                                     (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                               <[AS.Types.ASLocation]>_N
                                               <Data.Functor.Identity.Identity>_R
                                               <Data.Set.Base.Set AS.Types.ASLocation>_N))) }
                              $wvisit :: Data.Set.Base.Set AS.Types.ASLocation
                                         -> AS.Types.ASLocation
                                         -> (# Data.Set.Base.Set AS.Types.ASLocation,
                                               [AS.Types.ASLocation] #)
                                {- Arity: 2, Strictness: <S,U><S,U> -}
                              = \ w :: Data.Set.Base.Set AS.Types.ASLocation
                                  w1 :: AS.Types.ASLocation ->
                                case AS.DAG.$smember_go5 w1 w of wild {
                                  GHC.Types.False
                                  -> let {
                                       a :: Control.Monad.Trans.Writer.Lazy.WriterT
                                                [AS.Types.ASLocation]
                                                Data.Functor.Identity.Identity
                                                (Data.Set.Base.Set AS.Types.ASLocation)
                                       = letrec {
                                           go1 :: [(AS.Types.ASLocation, AS.Types.ASLocation)]
                                                  -> [AS.Types.ASLocation]
                                             {- Arity: 1, Strictness: <S,1*U> -}
                                           = \ ds :: [(AS.Types.ASLocation, AS.Types.ASLocation)] ->
                                             case ds of wild1 {
                                               [] -> GHC.Types.[] @ AS.Types.ASLocation
                                               : y ys
                                               -> case y of wild2 { (,) x' y' ->
                                                  case AS.Types.$fEqASCell_$c==3 w1 x' of wild3 {
                                                    GHC.Types.False -> go1 ys
                                                    GHC.Types.True
                                                    -> GHC.Types.:
                                                         @ AS.Types.ASLocation
                                                         y'
                                                         (go1 ys) } } }
                                         } in
                                         Control.Monad.$wfoldM
                                           @ (Data.Set.Base.Set AS.Types.ASLocation)
                                           @ AS.Types.ASLocation
                                           @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                  [AS.Types.ASLocation]
                                                  Data.Functor.Identity.Identity)
                                           AS.DAG.descendants1
                                             `cast`
                                           (forall a1 b.
                                            <Control.Monad.Trans.Writer.Lazy.WriterT
                                                 [AS.Types.ASLocation]
                                                 Data.Functor.Identity.Identity
                                                 a1>_R
                                            ->_R <a1
                                                  -> Control.Monad.Trans.Writer.Lazy.WriterT
                                                         [AS.Types.ASLocation]
                                                         Data.Functor.Identity.Identity
                                                         b>_R
                                            ->_R Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                          <[AS.Types.ASLocation]>_N
                                                          <Data.Functor.Identity.Identity>_R
                                                          <b>_N))
                                           AS.DAG.descendants2
                                             `cast`
                                           (forall a1.
                                            <a1>_R
                                            ->_R Trans
                                                     (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                                               <(a1, [AS.Types.ASLocation])>_R))
                                                     (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                               <[AS.Types.ASLocation]>_N
                                                               <Data.Functor.Identity.Identity>_R
                                                               <a1>_N)))
                                           visit
                                           (AS.DAG.$sinsert_$sgo5 w1 w)
                                           (go1 lvl)
                                     } in
                                     (# case a `cast`
                                             (Trans
                                                  (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                       <[AS.Types.ASLocation]>_N
                                                       <Data.Functor.Identity.Identity>_R
                                                       <Data.Set.Base.Set AS.Types.ASLocation>_N)
                                                  (Data.Functor.Identity.NTCo:Identity[0]
                                                       <(Data.Set.Base.Set AS.Types.ASLocation,
                                                         [AS.Types.ASLocation])>_R)) of wild1 { (,) a2 w2 ->
                                        a2 },
                                        case a `cast`
                                             (Trans
                                                  (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                       <[AS.Types.ASLocation]>_N
                                                       <Data.Functor.Identity.Identity>_R
                                                       <Data.Set.Base.Set AS.Types.ASLocation>_N)
                                                  (Data.Functor.Identity.NTCo:Identity[0]
                                                       <(Data.Set.Base.Set AS.Types.ASLocation,
                                                         [AS.Types.ASLocation])>_R)) of wild1 { (,) a2 w2 ->
                                        GHC.Base.++
                                          @ AS.Types.ASLocation
                                          w2
                                          (GHC.Types.:
                                             @ AS.Types.ASLocation
                                             w1
                                             (GHC.Types.[] @ AS.Types.ASLocation)) } #)
                                  GHC.Types.True -> (# w, GHC.Types.[] @ AS.Types.ASLocation #) }
                            } in
                            visit)
                           (Data.Set.Base.Tip @ AS.Types.ASLocation)
                           (go dag))
                          `cast`
                        (Trans
                             (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                  <[AS.Types.ASLocation]>_N
                                  <Data.Functor.Identity.Identity>_R
                                  <Data.Set.Base.Set AS.Types.ASLocation>_N)
                             (Data.Functor.Identity.NTCo:Identity[0]
                                  <(Data.Set.Base.Set AS.Types.ASLocation,
                                    [AS.Types.ASLocation])>_R)) of wild { (,) ds1 y ->
                   y }) -}
4053e151852ee55b7b05aa7b942de97c
  descendants_go :: [(AS.Types.ASLocation, AS.Types.ASLocation)]
                    -> [(AS.Types.ASLocation, AS.Types.ASLocation)]
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
fed2e42a11a18e5324128ed6f8f005bb
  getDescendants :: [AS.Types.ASLocation]
                    -> GHC.Types.IO [AS.Types.ASLocation]
    {- Arity: 2, Strictness: <L,U><L,U>,
       Unfolding: (AS.DAG.getDescendants1
                     `cast`
                   (<[AS.Types.ASLocation]>_R
                    ->_R Sym (GHC.Types.NTCo:IO[0] <[AS.Types.ASLocation]>_R))) -}
59df18933c293e0e811817c18bf2fb3c
  getDescendants1 :: [AS.Types.ASLocation]
                     -> GHC.Prim.State# GHC.Prim.RealWorld
                     -> (# GHC.Prim.State# GHC.Prim.RealWorld, [AS.Types.ASLocation] #)
    {- Arity: 2, Strictness: <L,U><L,U>,
       Unfolding: (\ locs :: [AS.Types.ASLocation]
                     eta :: GHC.Prim.State# GHC.Prim.RealWorld ->
                   (# eta,
                      AS.DAG.descendants_$sdescendants
                        locs
                        (GHC.Types.[] @ (AS.Types.ASLocation, AS.Types.ASLocation)) #)) -}
7a7eca0d5e8d357899029001d87949dd
  getImmediateAncestors :: [AS.Types.ASLocation]
                           -> GHC.Types.IO [AS.Types.ASLocation]
    {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,U>,
       Unfolding: (AS.DAG.getImmediateAncestors1
                     `cast`
                   (<[AS.Types.ASLocation]>_R
                    ->_R Sym (GHC.Types.NTCo:IO[0] <[AS.Types.ASLocation]>_R))) -}
f81acaa28b4f361d5abe968351ced094
  getImmediateAncestors1 :: [AS.Types.ASLocation]
                            -> GHC.Prim.State# GHC.Prim.RealWorld
                            -> (# GHC.Prim.State# GHC.Prim.RealWorld, [AS.Types.ASLocation] #)
    {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><L,U>,
       Unfolding: (\ locs :: [AS.Types.ASLocation]
                     eta :: GHC.Prim.State# GHC.Prim.RealWorld ->
                   (# eta,
                      AS.DAG.getImmediateAncestors_$simmediateAncestors
                        locs
                        (GHC.Types.[] @ (AS.Types.ASLocation, AS.Types.ASLocation)) #)) -}
d6a76fa17b49da8234a7cd1cb70fc9bb
  getImmediateAncestors_$simmediateAncestors :: [AS.Types.ASLocation]
                                                -> AS.DAG.Relation AS.Types.ASLocation
                                                -> [AS.Types.ASLocation]
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
       Unfolding: (\ eta :: [AS.Types.ASLocation]
                     eta1 :: AS.DAG.Relation AS.Types.ASLocation ->
                   letrec {
                     go :: [AS.Types.ASLocation] -> [AS.Types.ASLocation]
                       {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [AS.Types.ASLocation] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ AS.Types.ASLocation
                         : y ys
                         -> letrec {
                              go1 :: [(AS.Types.ASLocation, AS.Types.ASLocation)]
                                     -> [AS.Types.ASLocation]
                                {- Arity: 1, Strictness: <S,1*U> -}
                              = \ ds1 :: [(AS.Types.ASLocation, AS.Types.ASLocation)] ->
                                case ds1 of wild1 {
                                  [] -> GHC.Types.[] @ AS.Types.ASLocation
                                  : y1 ys1
                                  -> case y1 of wild2 { (,) x y2 ->
                                     case AS.Types.$fEqASCell_$c==3 y2 y of wild3 {
                                       GHC.Types.False -> go1 ys1
                                       GHC.Types.True
                                       -> GHC.Types.: @ AS.Types.ASLocation x (go1 ys1) } } }
                            } in
                            GHC.Base.++ @ AS.Types.ASLocation (go1 eta1) (go ys) }
                   } in
                   go eta) -}
902f7f7c9fea9028c29cfeb2b8292f0c
  image :: GHC.Classes.Eq a -> a -> AS.DAG.Relation a -> [a]
    {- Arity: 3, HasNoCafRefs,
       Strictness: <L,U(C(C1(U)),A)><L,U><S,1*U>,
       Unfolding: (\ @ a
                     $dEq :: GHC.Classes.Eq a
                     x :: a
                     rel :: AS.DAG.Relation a ->
                   let {
                     lvl :: a -> a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq
                   } in
                   letrec {
                     go :: [(a, a)] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [(a, a)] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ a
                         : y ys
                         -> case y of wild1 { (,) x' y' ->
                            case lvl x x' of wild2 {
                              GHC.Types.False -> go ys
                              GHC.Types.True -> GHC.Types.: @ a y' (go ys) } } }
                   } in
                   go rel) -}
d3abb31b7178b8a2cbafa0c53d45241a
  immediateAncestors :: GHC.Classes.Eq a
                        -> GHC.Classes.Ord a
                        -> [a]
                        -> AS.DAG.Relation a
                        -> [a]
    {- Arity: 4, HasNoCafRefs,
       Strictness: <L,A><L,1*U(1*U(U,U),A,A,A,A,A,A,A)><S,1*U><L,U>,
       Inline: INLINE[0],
       Unfolding: InlineRule (4, True, True)
                  (\ @ a
                     w :: GHC.Classes.Eq a
                     w1 :: GHC.Classes.Ord a
                     w2 :: [a]
                     w3 :: AS.DAG.Relation a ->
                   AS.DAG.$wimmediateAncestors @ a w1 w2 w3) -}
2c56bdfa5eb0fb00dc48b9605f34f3dc
  inverse :: AS.DAG.Relation a -> AS.DAG.Relation a
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ @ a rel :: AS.DAG.Relation a ->
                   AS.DAG.inverse1 @ a rel) -}
fbf69997e1bb45e011148a4cd411fe05
  inverse1 :: [(a, a)] -> [(a, a)]
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
e1325973f4173e4f3d4b46c73f3a88cc
  reachableSet :: GHC.Classes.Ord a
                  -> [a]
                  -> [(a, a)]
                  -> Data.Set.Base.Set a
    {- Arity: 3,
       Strictness: <L,U(1*U(U,U),C(C1(U)),A,A,A,A,A,A)><S,1*U><L,U>,
       Unfolding: (\ @ a
                     $dOrd :: GHC.Classes.Ord a
                     eta :: [a]
                     eta1 :: [(a, a)] ->
                   let {
                     $dEq :: GHC.Classes.Eq a = GHC.Classes.$p1Ord @ a $dOrd
                   } in
                   letrec {
                     lgo :: Data.Set.Base.Set a -> [a] -> Data.Set.Base.Set a
                       {- Arity: 2, Strictness: <S,U><S,1*U> -}
                     = \ z :: Data.Set.Base.Set a ds :: [a] ->
                       case ds of wild {
                         [] -> z : x xs -> case visit z x of z' { DEFAULT -> lgo z' xs } }
                     visit :: Data.Set.Base.Set a -> a -> Data.Set.Base.Set a
                       {- Arity: 2, Strictness: <S,U><S,U> -}
                     = \ visited :: Data.Set.Base.Set a x :: a ->
                       case Data.Set.Base.member @ a $dOrd x visited of wild {
                         GHC.Types.False
                         -> lgo
                              (Data.Set.Base.insert @ a $dOrd x visited)
                              (AS.DAG.image @ a $dEq x eta1)
                         GHC.Types.True -> visited }
                   } in
                   letrec {
                     lgo1 :: Data.Set.Base.Set a -> [a] -> Data.Set.Base.Set a
                       {- Arity: 2, Strictness: <S,U><S,1*U> -}
                     = \ z :: Data.Set.Base.Set a ds :: [a] ->
                       case ds of wild {
                         [] -> z : x xs -> case visit z x of z' { DEFAULT -> lgo1 z' xs } }
                   } in
                   lgo1 (Data.Set.Base.Tip @ a) eta) -}
15254119a443fe2252562e1a577ebdf7
  toposort :: GHC.Classes.Ord a -> [(a, a)] -> [a]
    {- Arity: 2, Strictness: <L,U(1*U(U,U),C(C1(U)),A,A,A,A,A,A)><S,U>,
       Unfolding: (\ @ a $dOrd :: GHC.Classes.Ord a eta :: [(a, a)] ->
                   let {
                     lvl :: AS.DAG.Relation a = AS.DAG.toposort4 @ a eta
                   } in
                   let {
                     $dEq :: GHC.Classes.Eq a = GHC.Classes.$p1Ord @ a $dOrd
                   } in
                   let {
                     z :: [a] = GHC.Base.map @ (a, a) @ a (Data.Tuple.snd @ a @ a) eta
                   } in
                   letrec {
                     go :: [(a, a)] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [(a, a)] ->
                       case ds of wild {
                         [] -> z
                         : y ys -> GHC.Types.: @ a (Data.Tuple.fst @ a @ a y) (go ys) }
                   } in
                   case (Control.Monad.$wfoldM
                           @ (Data.Set.Base.Set a)
                           @ a
                           @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                  [a] Data.Functor.Identity.Identity)
                           (AS.DAG.toposort3 @ a)
                             `cast`
                           (forall a1 b.
                            <Control.Monad.Trans.Writer.Lazy.WriterT
                                 [a] Data.Functor.Identity.Identity a1>_R
                            ->_R <a1
                                  -> Control.Monad.Trans.Writer.Lazy.WriterT
                                         [a] Data.Functor.Identity.Identity b>_R
                            ->_R Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                          <[a]>_N <Data.Functor.Identity.Identity>_R <b>_N))
                           (AS.DAG.toposort2 @ a)
                             `cast`
                           (forall a1.
                            <a1>_R
                            ->_R Trans
                                     (Sym (Data.Functor.Identity.NTCo:Identity[0] <(a1, [a])>_R))
                                     (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                               <[a]>_N <Data.Functor.Identity.Identity>_R <a1>_N)))
                           (letrec {
                              visit :: Data.Set.Base.Set a
                                       -> a
                                       -> Control.Monad.Trans.Writer.Lazy.WriterT
                                              [a]
                                              Data.Functor.Identity.Identity
                                              (Data.Set.Base.Set a)
                                {- Arity: 2, Strictness: <S,U><S,U>m, Inline: INLINE[0],
                                   Unfolding: InlineRule (2, True, False)
                                              (\ w :: Data.Set.Base.Set a w1 :: a ->
                                               case $wvisit w w1 of ww { (#,#) ww1 ww2 ->
                                               (ww1, ww2)
                                                 `cast`
                                               (Trans
                                                    (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                                              <(Data.Set.Base.Set a, [a])>_R))
                                                    (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                              <[a]>_N
                                                              <Data.Functor.Identity.Identity>_R
                                                              <Data.Set.Base.Set a>_N))) }) -}
                              = \ w :: Data.Set.Base.Set a w1 :: a ->
                                case $wvisit w w1 of ww { (#,#) ww1 ww2 ->
                                (ww1, ww2)
                                  `cast`
                                (Trans
                                     (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                               <(Data.Set.Base.Set a, [a])>_R))
                                     (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                               <[a]>_N
                                               <Data.Functor.Identity.Identity>_R
                                               <Data.Set.Base.Set a>_N))) }
                              $wvisit :: Data.Set.Base.Set a
                                         -> a
                                         -> (# Data.Set.Base.Set a, [a] #)
                                {- Arity: 2, Strictness: <S,U><S,U> -}
                              = \ w :: Data.Set.Base.Set a w1 :: a ->
                                case Data.Set.Base.member @ a $dOrd w1 w of wild {
                                  GHC.Types.False
                                  -> let {
                                       a1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                                                 [a]
                                                 Data.Functor.Identity.Identity
                                                 (Data.Set.Base.Set a)
                                       = Control.Monad.$wfoldM
                                           @ (Data.Set.Base.Set a)
                                           @ a
                                           @ (Control.Monad.Trans.Writer.Lazy.WriterT
                                                  [a] Data.Functor.Identity.Identity)
                                           (AS.DAG.toposort1 @ a)
                                             `cast`
                                           (forall a2 b.
                                            <Control.Monad.Trans.Writer.Lazy.WriterT
                                                 [a] Data.Functor.Identity.Identity a2>_R
                                            ->_R <a2
                                                  -> Control.Monad.Trans.Writer.Lazy.WriterT
                                                         [a] Data.Functor.Identity.Identity b>_R
                                            ->_R Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                          <[a]>_N
                                                          <Data.Functor.Identity.Identity>_R
                                                          <b>_N))
                                           (AS.DAG.toposort2 @ a)
                                             `cast`
                                           (forall a2.
                                            <a2>_R
                                            ->_R Trans
                                                     (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                                               <(a2, [a])>_R))
                                                     (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                               <[a]>_N
                                                               <Data.Functor.Identity.Identity>_R
                                                               <a2>_N)))
                                           visit
                                           (Data.Set.Base.insert @ a $dOrd w1 w)
                                           (AS.DAG.image @ a $dEq w1 lvl)
                                     } in
                                     (# case a1
                                               `cast`
                                             (Trans
                                                  (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                       <[a]>_N
                                                       <Data.Functor.Identity.Identity>_R
                                                       <Data.Set.Base.Set a>_N)
                                                  (Data.Functor.Identity.NTCo:Identity[0]
                                                       <(Data.Set.Base.Set a,
                                                         [a])>_R)) of wild1 { (,) a2 w2 ->
                                        a2 },
                                        case a1
                                               `cast`
                                             (Trans
                                                  (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                       <[a]>_N
                                                       <Data.Functor.Identity.Identity>_R
                                                       <Data.Set.Base.Set a>_N)
                                                  (Data.Functor.Identity.NTCo:Identity[0]
                                                       <(Data.Set.Base.Set a,
                                                         [a])>_R)) of wild1 { (,) a2 w2 ->
                                        GHC.Base.++
                                          @ a
                                          w2
                                          (GHC.Types.: @ a w1 (GHC.Types.[] @ a)) } #)
                                  GHC.Types.True -> (# w, GHC.Types.[] @ a #) }
                            } in
                            visit)
                           (Data.Set.Base.Tip @ a)
                           (go eta))
                          `cast`
                        (Trans
                             (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                  <[a]>_N
                                  <Data.Functor.Identity.Identity>_R
                                  <Data.Set.Base.Set a>_N)
                             (Data.Functor.Identity.NTCo:Identity[0]
                                  <(Data.Set.Base.Set a, [a])>_R)) of wild { (,) ds1 y ->
                   y }) -}
06c3908a5857d8f767ad3d6d7121c0a4
  toposort1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                   [a] Data.Functor.Identity.Identity a1
               -> (a1
                   -> Control.Monad.Trans.Writer.Lazy.WriterT
                          [a] Data.Functor.Identity.Identity b)
               -> Data.Functor.Identity.Identity (b, [a])
    {- Arity: 2, HasNoCafRefs,
       Unfolding: (\ @ a
                     @ a1
                     @ b
                     w3 :: Control.Monad.Trans.Writer.Lazy.WriterT
                               [a] Data.Functor.Identity.Identity a1
                     w4 :: a1
                           -> Control.Monad.Trans.Writer.Lazy.WriterT
                                  [a] Data.Functor.Identity.Identity b ->
                   let {
                     a2 :: Control.Monad.Trans.Writer.Lazy.WriterT
                               [a] Data.Functor.Identity.Identity b
                     = w4
                         (case w3
                                 `cast`
                               (Trans
                                    (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                         <[a]>_N <Data.Functor.Identity.Identity>_R <a1>_N)
                                    (Data.Functor.Identity.NTCo:Identity[0]
                                         <(a1, [a])>_R)) of wild { (,) a3 w5 ->
                          a3 })
                   } in
                   (case a2
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[a]>_N <Data.Functor.Identity.Identity>_R <b>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(b, [a])>_R)) of wild { (,) b1 w' ->
                    b1 },
                    case w3
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[a]>_N <Data.Functor.Identity.Identity>_R <a1>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(a1, [a])>_R)) of wild { (,) a3 w5 ->
                    GHC.Base.++
                      @ a
                      w5
                      (case a2
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                      <[a]>_N <Data.Functor.Identity.Identity>_R <b>_N)
                                 (Data.Functor.Identity.NTCo:Identity[0]
                                      <(b, [a])>_R)) of wild1 { (,) b1 w' ->
                       w' }) })
                     `cast`
                   (Sym (Data.Functor.Identity.NTCo:Identity[0] <(b, [a])>_R))) -}
96b186a9c688a1e9d6729e55888b0296
  toposort2 :: a1 -> (a1, [a])
    {- Arity: 1, HasNoCafRefs,
       Unfolding: (\ @ a @ a1 a2 :: a1 -> (a2, GHC.Types.[] @ a)) -}
4dbb3d96daa45658984219a729ebbe00
  toposort3 :: Control.Monad.Trans.Writer.Lazy.WriterT
                   [a] Data.Functor.Identity.Identity a1
               -> (a1
                   -> Control.Monad.Trans.Writer.Lazy.WriterT
                          [a] Data.Functor.Identity.Identity b)
               -> Data.Functor.Identity.Identity (b, [a])
    {- Arity: 2, HasNoCafRefs,
       Unfolding: (\ @ a
                     @ a1
                     @ b
                     w3 :: Control.Monad.Trans.Writer.Lazy.WriterT
                               [a] Data.Functor.Identity.Identity a1
                     w4 :: a1
                           -> Control.Monad.Trans.Writer.Lazy.WriterT
                                  [a] Data.Functor.Identity.Identity b ->
                   let {
                     a2 :: Control.Monad.Trans.Writer.Lazy.WriterT
                               [a] Data.Functor.Identity.Identity b
                     = w4
                         (case w3
                                 `cast`
                               (Trans
                                    (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                         <[a]>_N <Data.Functor.Identity.Identity>_R <a1>_N)
                                    (Data.Functor.Identity.NTCo:Identity[0]
                                         <(a1, [a])>_R)) of wild { (,) a3 w5 ->
                          a3 })
                   } in
                   (case a2
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[a]>_N <Data.Functor.Identity.Identity>_R <b>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(b, [a])>_R)) of wild { (,) b1 w' ->
                    b1 },
                    case w3
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[a]>_N <Data.Functor.Identity.Identity>_R <a1>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(a1, [a])>_R)) of wild { (,) a3 w5 ->
                    GHC.Base.++
                      @ a
                      w5
                      (case a2
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                      <[a]>_N <Data.Functor.Identity.Identity>_R <b>_N)
                                 (Data.Functor.Identity.NTCo:Identity[0]
                                      <(b, [a])>_R)) of wild1 { (,) b1 w' ->
                       w' }) })
                     `cast`
                   (Sym (Data.Functor.Identity.NTCo:Identity[0] <(b, [a])>_R))) -}
7c726e5db7974600578c2014135aaa9d
  toposort4 :: [(a, a)] -> [(a, a)]
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
"SPEC AS.DAG.descendants [AS.Types.ASLocation]" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                                            AS.Types.ASLocation
                                                                $dOrd :: GHC.Classes.Ord
                                                                             AS.Types.ASLocation
  AS.DAG.descendants @ AS.Types.ASLocation $dEq $dOrd
  = AS.DAG.descendants_$sdescendants
"SPEC AS.DAG.image [AS.Types.ASLocation]" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                                      AS.Types.ASLocation
  AS.DAG.image @ AS.Types.ASLocation $dEq
  = AS.DAG.descendants_$simage
"SPEC AS.DAG.immediateAncestors [AS.Types.ASLocation]" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                                                   AS.Types.ASLocation
                                                                       $dOrd :: GHC.Classes.Ord
                                                                                    AS.Types.ASLocation
  AS.DAG.immediateAncestors @ AS.Types.ASLocation $dEq $dOrd
  = AS.DAG.getImmediateAncestors_$simmediateAncestors
"SPEC AS.DAG.reachableSet [AS.Types.ASLocation]" [ALWAYS] forall $dOrd :: GHC.Classes.Ord
                                                                              AS.Types.ASLocation
  AS.DAG.reachableSet @ AS.Types.ASLocation $dOrd
  = AS.DAG.descendants_$sreachableSet
"SPEC AS.DAG.toposort [AS.Types.ASLocation]" [ALWAYS] forall $dOrd :: GHC.Classes.Ord
                                                                          AS.Types.ASLocation
  AS.DAG.toposort @ AS.Types.ASLocation $dOrd
  = AS.DAG.descendants_$stoposort
"SPEC Data.Set.Base.insert [AS.Types.ASLocation]" [ALWAYS] forall $dOrd :: GHC.Classes.Ord
                                                                               AS.Types.ASLocation
  Data.Set.Base.insert @ AS.Types.ASLocation $dOrd = AS.DAG.$sinsert
"SPEC Data.Set.Base.member [AS.Types.ASLocation]" [ALWAYS] forall $dOrd :: GHC.Classes.Ord
                                                                               AS.Types.ASLocation
  Data.Set.Base.member @ AS.Types.ASLocation $dOrd = AS.DAG.$smember
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

