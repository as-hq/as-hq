
==================== FINAL INTERFACE ====================
2015-09-25 00:27:12.198782 UTC

interface alphasheets-0.1.0.0:AS.Util 7084
  interface hash: 11ed56d698bb9ca8aae8e8ed8bfd4293
  ABI hash: 417e4f2db7aca39e7f1871a4d7aab2a3
  export-list hash: 061da0521eb01812fd74bf75a38cb988
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f8b866267ce58dc6290b8020b2e82f8c
  used TH splices: False
  where
exports:
  AS.Util.<++>
  AS.Util.<:>
  AS.Util.addToAL
  AS.Util.containsTrackingTag
  AS.Util.containsVolatileTag
  AS.Util.decomposeLocs
  AS.Util.delFromAL
  AS.Util.deleteSubset
  AS.Util.every
  AS.Util.filterNothing
  AS.Util.fromJustList
  AS.Util.fromRight
  AS.Util.generateErrorMessage
  AS.Util.getASTime
  AS.Util.getAllUserWindows
  AS.Util.getBadLocs
  AS.Util.getCellMessage
  AS.Util.getDBCellMessage
  AS.Util.getOffsetBetweenLocs
  AS.Util.getScrolledLocs
  AS.Util.getStreamTag
  AS.Util.getStreamTagFromExpression
  AS.Util.getTime
  AS.Util.getTopLeft
  AS.Util.getUncoveredLocs
  AS.Util.getUniqueId
  AS.Util.getWindow
  AS.Util.hasPermissions
  AS.Util.hasVolatileTag
  AS.Util.intersectViewingWindows
  AS.Util.intersectViewingWindowsLocs
  AS.Util.isAllRight
  AS.Util.isColumn
  AS.Util.isGroupAdmin
  AS.Util.isGroupMember
  AS.Util.isInEntity
  AS.Util.isJust
  AS.Util.isRight
  AS.Util.isSubsetOf
  AS.Util.isoFilter
  AS.Util.lastN
  AS.Util.lastN'
  AS.Util.lookupLambda
  AS.Util.matchSheets
  AS.Util.max'
  AS.Util.maxBy
  AS.Util.min'
  AS.Util.minBy
  AS.Util.printTimed
  AS.Util.sendMessage
  AS.Util.shiftLoc
  AS.Util.updateMessageUser
  AS.Util.updateWindow
module dependencies: AS.Types
package dependencies: BoundedChan-1.0.3.0 SHA-1.6.4.2 aeson-0.8.1.1
                      array-0.5.0.0 attoparsec-0.13.0.1 base base64-bytestring-1.0.0.1
                      binary-0.7.1.0 blaze-builder-0.4.0.1 bytestring-0.10.4.0
                      bytestring-lexing-0.5.0.2 case-insensitive-1.2.0.4
                      containers-0.5.5.1 deepseq-1.3.0.2 dlist-0.7.1.1 entropy-0.3.7
                      ghc-prim hashable-1.2.3.3 hedis-0.6.9 integer-gmp
                      monad-control-1.0.0.4 mtl-2.2.1 network-2.6.2.1 primitive-0.6
                      random-1.1 resource-pool-0.2.3.2 scientific-0.3.3.8 stm-2.4.4
                      text-1.2.1.1 time-1.5.0.1 transformers-0.4.3.0
                      transformers-base-0.4.4 unix-2.7.1.0 unordered-containers-0.2.5.1
                      uuid-1.3.10 uuid-types-1.0.1 vector-0.11.0.0 websockets-0.9.5.0
orphans: aeson-0.8.1.1:Data.Aeson.Types.Generic
         aeson-0.8.1.1:Data.Aeson.Types.Instances
         aeson-0.8.1.1:Data.Aeson.Types.Internal
         attoparsec-0.13.0.1:Data.Attoparsec.ByteString.Char8 base:GHC.Base
         base:GHC.Float base:GHC.Real binary-0.7.1.0:Data.Binary.Generic
         bytestring-0.10.4.0:Data.ByteString.Builder
         bytestring-lexing-0.5.0.2:Data.ByteString.Lex.Fractional
         hashable-1.2.3.3:Data.Hashable.Generic
         network-2.6.2.1:Network.Socket network-2.6.2.1:Network.Socket.Types
         random-1.1:System.Random resource-pool-0.2.3.2:Data.Pool
         stm-2.4.4:Control.Monad.STM text-1.2.1.1:Data.Text
         text-1.2.1.1:Data.Text.Lazy text-1.2.1.1:Data.Text.Show
         time-1.5.0.1:Data.Time.Calendar.Gregorian
         time-1.5.0.1:Data.Time.Format.Parse
         time-1.5.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.4.3.0:Control.Monad.Trans.Error
         vector-0.11.0.0:Data.Vector.Fusion.Bundle
         vector-0.11.0.0:Data.Vector.Unboxed
family instance modules: alphasheets-0.1.0.0:AS.Types
                         attoparsec-0.13.0.1:Data.Attoparsec.Internal.Types
                         base:Control.Applicative base:Data.Either base:Data.Monoid
                         base:Data.Type.Equality base:GHC.Exts base:GHC.Generics
                         dlist-0.7.1.1:Data.DList
                         monad-control-1.0.0.4:Control.Monad.Trans.Control
                         primitive-0.6:Control.Monad.Primitive text-1.2.1.1:Data.Text
                         text-1.2.1.1:Data.Text.Lazy
                         unordered-containers-0.2.5.1:Data.HashMap.Base
                         unordered-containers-0.2.5.1:Data.HashSet
                         uuid-types-1.0.1:Data.UUID.Types.Internal
                         uuid-types-1.0.1:Data.UUID.Types.Internal.Builder
                         vector-0.11.0.0:Data.Vector vector-0.11.0.0:Data.Vector.Primitive
                         vector-0.11.0.0:Data.Vector.Storable
                         vector-0.11.0.0:Data.Vector.Unboxed
                         vector-0.11.0.0:Data.Vector.Unboxed.Base
import  -/  aeson-0.8.1.1:Data.Aeson 4717cd565317ade519445bba111351ae
import  -/  aeson-0.8.1.1:Data.Aeson.Encode.ByteString 0b7a0357ab6c702b385f6d74bfdda8e2
import  -/  AS.Types ac0aeb8d2661160e6345f7fec8fc36e5
  exports: 4f33e2305e9f32540a30fe3603c0662c
  ASCell bede131762bf9e6165d28069305c9a8f
  ASCellTag 41914e4ed00db1adb7aa05558d91cd06
  ASEntity c718e8f93c15da8eb67c72089ab671c4
  ASExecError ac2b16a41a3fdddbc18d87357a01cd53
  ASExpression 64e605941635d5560dadb6b522a83662
  ASLocation 42b88bd590b6186a8f42af5a0deb461a
  ASMessage b488c6e303af3ec316847aa09e9ef416
  ASPermissions 4e2fdc3425c5d9cb0fcfc5baa7b7c726
  ASSheet e94846da4cf11f1951bc25078de1fc76
  ASSheetId 4ed60fa4a266e9c370748b465970547f
  ASTime a93fd4de05ce0fb004b03e7de05eebb0
  ASUser 8f65613dded3aab26fae493435f0f314
  ASUserGroup 57b6c6e41a576bc76a2027508b202d20
  ASUserId 3094df477896c468afcf617b4934d3e3
  ASWindow 7f874813d50ca675a8d1e51d62497852
  ASWorkbook dc570e9d01415111185b1ff1b63cbb38
  Blacklist 3b40a7cf8ec9baef8a042ba812d96d6a
  Cell cf2ab8ae076f48bff57c162753f8fec8
  Column 2c1479dadfed776d27f89a4215e28321
  CopyNonexistentDependencies 455a8cd8ce200827158d3e62707c0369
  DBNothingException a2fedf534617a8e871d31936d55eb10c
  EntityGroup 23f1bf9f72eaa2a968b4151cbfc3e2f4
  EntityUser afb51e70b7bac6e0aef5d1408cf8fa19
  Evaluate 0016d98b7ff475be6a9673f425925dbc
  Failure 9946650b22bb6e567b42b8da3b105d7a
  Index 32bc2c9c50c80ae6c93286c30ef7b208
  Message 84f4a46e37fa757190dd82d855281e02
  PayloadCL 986b2bbb852717bf17df4cc79495cabe
  PayloadN b41903296b9876a7e39be149f2893a16
  Range 1619818a9064827107fb6d04d8e72cf3
  ServerState 9ce35b4af6c18edb38f6401544fc8edb
  Stream 6c81d33552c532c9efe28662ad204551
  StreamTag 1f95a2a2a84067b901c5bc5824094c7d
  Success caf3e41f68e7099b0d98b6a27765d4ec
  Time 2db5192f621558c54fe429a9c5aca82c
  Tracking 076b29a2eba9457cd2e9048ba7e3fb88
  UserClient cace6434106bd6cda012c66a0b1ec25f
  Volatile 46192d243b46f997121704cd92ad9fa7
  Whitelist a552e92a107f5fddb8f107b9f1900de3
  Window d6d144a36289253b6319bb291a9275d2
  WorkbookSheet 5597d2398faf32cb9835f468c56e0c68
  WorkbookSheet 4d833f52853e533ceb1fb336e970e4f5
  cellTags 5949cba85c1e509f832ed1017c3f9981
  groupAdmins e21c7c5d82046346cc7959e17bce244f
  groupMembers 56b351a8bc166b251704f46186cfe277
  sheetId b59632ae8c59173b4c3b1b899644d078
  userClients c3860e81961e3eb9b4ad94244e8b11b1
  userId 85217dd9f2d9550b6e0817800ca98d66
  windowSheetId 63930e183ffb681090da00d843f4e165
  windows 515a1209c81b93b4e7054b1ad120a76f
  workbookName 94e7971a7eb0201351e161b545d4bebe
  workbookSheets 26d6100b8bd17c2ca420063ca816064d
import  -/  base:Control.Applicative 30b769206cb5c020684e1bda0d7e7dd3
import  -/  base:Control.Monad 483e787e07c2e49f1fb1c1b88665cb92
import  -/  base:Data.Either d1c890129a7c6a9ec02a642c6c2f4ed3
import  -/  base:Data.Functor 2a75672109006aa68920c9629500622a
import  -/  base:Data.List 8b77870d02d66076337587b759b7ee19
import  -/  base:Data.Maybe 5034d40e23c3a7110309f188001df4ca
import  -/  base:Data.Tuple cac4e06c48274e85317bd3e59867ef5b
import  -/  base:GHC.Base 5d7c5f596f9a4c8a8abd8517c8bcd5dd
import  -/  base:GHC.List 4cff382327e59a5787355ca0a4174450
import  -/  base:GHC.Num 5e7786970581cacc802bf850d458a30b
import  -/  base:GHC.Show cf1a7ff9edb0f41528085aad04d33753
import  -/  base:Prelude 74043f272d60acec1777d3461cfe5ef4
import  -/  base:System.IO cadd0efb01c47ddd8f52d750739fdbdf
import  -/  ghc-prim:GHC.Classes 3e6cbe1e7e80480408cfa8d5450726a0
import  -/  ghc-prim:GHC.Types dcba736fa3dfba12d307ab18354845d2
import  -/  text-1.2.1.1:Data.Text ddf865ef7152d1de0d03707558cc6523
import  -/  text-1.2.1.1:Data.Text.Internal 5c7132affaaf11c5fb226a9fff83be01
import  -/  time-1.5.0.1:Data.Time.Clock f41c6b331f55aebceef7fdef0c152e53
import  -/  time-1.5.0.1:Data.Time.Clock.UTC 7927937dd12ffaa17ee662d46375a511
import  -/  uuid-1.3.10:Data.UUID 395d991de21b28ec4fbe226664b86083
import  -/  uuid-1.3.10:Data.UUID.V4 bd7a477668faee84c8b59694fd2e4e3f
import  -/  uuid-types-1.0.1:Data.UUID.Types.Internal 012f81cee28268edb831bd70b73da23e
import  -/  websockets-0.9.5.0:Network.WebSockets c11cd6465abe4dc4c3ad51897e46aaa0
import  -/  websockets-0.9.5.0:Network.WebSockets.Connection ae39d52893470d43c0bc592e95fce2c0
f7815de7e630a4d2443f2ee95084de39
  $wgetOffsetBetweenLocs :: AS.Types.ASLocation
                            -> AS.Types.ASLocation
                            -> (# GHC.Types.Int, GHC.Types.Int #)
    {- Arity: 2, Strictness: <S,1*U><S,1*U>,
       Unfolding: (\ w :: AS.Types.ASLocation w1 :: AS.Types.ASLocation ->
                   let {
                     $w$j :: GHC.Types.Int
                             -> GHC.Types.Int
                             -> (# GHC.Types.Int, GHC.Types.Int #)
                       {- Arity: 2, Strictness: <L,1*U(U)><L,1*U(U)> -}
                     = \ ww :: GHC.Types.Int ww1 :: GHC.Types.Int ->
                       case w1 of wild {
                         AS.Types.Index ds ds1
                         -> case ds1 of wild1 { (,) y' x' ->
                            (# GHC.Num.$fNumInt_$c- y' ww, GHC.Num.$fNumInt_$c- x' ww1 #) }
                         AS.Types.Range sh ds
                         -> case ds of wild1 { (,) tl ds1 ->
                            case tl of wild2 { (,) y' x' ->
                            (# GHC.Num.$fNumInt_$c- y' ww, GHC.Num.$fNumInt_$c- x' ww1 #) } }
                         AS.Types.Column ipv ipv1
                         -> case AS.Util.getOffsetBetweenLocs1
                            ret_ty (# GHC.Types.Int, GHC.Types.Int #)
                            of {} }
                   } in
                   case w of wild {
                     AS.Types.Index ds ds1
                     -> case ds1 of ww { (,) ww1 ww2 -> $w$j ww1 ww2 }
                     AS.Types.Range sh ds
                     -> case ds of wild1 { (,) tl ds1 ->
                        case tl of ww { (,) ww1 ww2 -> $w$j ww1 ww2 } }
                     AS.Types.Column ipv ipv1
                     -> case AS.Util.getOffsetBetweenLocs1
                        ret_ty (# GHC.Types.Int, GHC.Types.Int #)
                        of {} }) -}
2f23170678b043c93d4b4a608ab1a705
  $wgetScrolledLocs :: GHC.Prim.Int#
                       -> GHC.Types.Int
                       -> GHC.Types.Int
                       -> GHC.Types.Int
                       -> AS.Types.ASSheetId
                       -> (GHC.Types.Int, GHC.Types.Int)
                       -> (GHC.Types.Int, GHC.Types.Int)
                       -> [AS.Types.ASLocation]
    {- Arity: 7, HasNoCafRefs,
       Strictness: <S,U><L,U(U)><L,U(U)><L,U(U)><L,U><L,U(U(U),U(U))><L,U(U(U),U(U))>,
       Unfolding: (\ ww :: GHC.Prim.Int#
                     ww1 :: GHC.Types.Int
                     ww2 :: GHC.Types.Int
                     ww3 :: GHC.Types.Int
                     ww4 :: AS.Types.ASSheetId
                     ww5 :: (GHC.Types.Int, GHC.Types.Int)
                     ww6 :: (GHC.Types.Int, GHC.Types.Int) ->
                   let {
                     fail1 :: GHC.Prim.Void# -> [AS.Types.ASLocation]
                       {- Arity: 1, Strictness: <L,A> -}
                     = \ ds :: GHC.Prim.Void# ->
                       case ww5 of wild { (,) y' x' ->
                       case ww6 of wild1 { (,) y2' x2' ->
                       case AS.Util.$wgetUncoveredLocs
                              ww4
                              (case y' of wild2 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.># ww y) of wild3 {
                                 GHC.Types.False -> wild2 GHC.Types.True -> GHC.Types.I# ww } },
                               case ww1 of wild2 { GHC.Types.I# x ->
                               case x' of wild3 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.># x y) of wild4 {
                                 GHC.Types.False -> wild3 GHC.Types.True -> wild2 } } })
                              (case ww2 of wild2 { GHC.Types.I# x ->
                               case y2' of wild3 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<# x y) of wild4 {
                                 GHC.Types.False -> wild3 GHC.Types.True -> wild2 } } },
                               case ww3 of wild2 { GHC.Types.I# x ->
                               case x2' of wild3 { GHC.Types.I# y ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<# x y) of wild4 {
                                 GHC.Types.False -> wild3 GHC.Types.True -> wild2 } } })
                              wild
                              wild1 of ww7 { (#,#) ww8 ww9 ->
                       GHC.Types.: @ AS.Types.ASLocation ww8 ww9 } } }
                   } in
                   case ww of ds {
                     DEFAULT -> fail1 GHC.Prim.void#
                     (-1)
                     -> case ww1 of wild { GHC.Types.I# ds1 ->
                        case ds1 of ds2 {
                          DEFAULT -> fail1 GHC.Prim.void#
                          (-1)
                          -> case ww2 of wild1 { GHC.Types.I# ds3 ->
                             case ds3 of ds4 {
                               DEFAULT -> fail1 GHC.Prim.void#
                               (-1)
                               -> case ww3 of wild2 { GHC.Types.I# ds5 ->
                                  case ds5 of ds6 {
                                    DEFAULT -> fail1 GHC.Prim.void#
                                    (-1)
                                    -> GHC.Types.:
                                         @ AS.Types.ASLocation
                                         (AS.Types.Range ww4 (ww5, ww6))
                                         (GHC.Types.[] @ AS.Types.ASLocation) } } } } } } }) -}
c8fc13b9687e9f7e352f267b2acc7f83
  $wgetUncoveredLocs :: AS.Types.ASSheetId
                        -> (GHC.Types.Int, GHC.Types.Int)
                        -> (GHC.Types.Int, GHC.Types.Int)
                        -> (GHC.Types.Int, GHC.Types.Int)
                        -> (GHC.Types.Int, GHC.Types.Int)
                        -> (# AS.Types.ASLocation, [AS.Types.ASLocation] #)
    {- Arity: 5, HasNoCafRefs,
       Strictness: <L,U><L,U(U,U)><L,U(U,U)><L,U(U,U)><L,U(U,U)>,
       Unfolding: (\ w :: AS.Types.ASSheetId
                     ww :: (GHC.Types.Int, GHC.Types.Int)
                     ww1 :: (GHC.Types.Int, GHC.Types.Int)
                     ww2 :: (GHC.Types.Int, GHC.Types.Int)
                     ww3 :: (GHC.Types.Int, GHC.Types.Int) ->
                   (# AS.Types.Range
                        w
                        (ww2,
                         (Data.Tuple.fst @ GHC.Types.Int @ GHC.Types.Int ww1,
                          Data.Tuple.snd @ GHC.Types.Int @ GHC.Types.Int ww)),
                      GHC.Types.:
                        @ AS.Types.ASLocation
                        (AS.Types.Range
                           w
                           ((Data.Tuple.fst @ GHC.Types.Int @ GHC.Types.Int ww3,
                             Data.Tuple.snd @ GHC.Types.Int @ GHC.Types.Int ww2),
                            ww1))
                        (GHC.Types.:
                           @ AS.Types.ASLocation
                           (AS.Types.Range
                              w
                              (ww3,
                               (Data.Tuple.fst @ GHC.Types.Int @ GHC.Types.Int ww,
                                Data.Tuple.snd @ GHC.Types.Int @ GHC.Types.Int ww1)))
                           (GHC.Types.:
                              @ AS.Types.ASLocation
                              (AS.Types.Range
                                 w
                                 ((Data.Tuple.fst @ GHC.Types.Int @ GHC.Types.Int ww2,
                                   Data.Tuple.snd @ GHC.Types.Int @ GHC.Types.Int ww3),
                                  ww))
                              (GHC.Types.[] @ AS.Types.ASLocation))) #)) -}
8ab5dde5ccf1441735a7cc30d28479c5
  $wgetWindow :: AS.Types.ASSheetId
                 -> [AS.Types.ASWindow]
                 -> Data.Maybe.Maybe AS.Types.ASWindow
    {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,U,U)><S,1*U>,
       Unfolding: (\ w :: AS.Types.ASSheetId ww :: [AS.Types.ASWindow] ->
                   case GHC.List.filter
                          @ AS.Types.ASWindow
                          (\ x :: AS.Types.ASWindow ->
                           case w of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                           case x of wild1 { AS.Types.Window ds1 ds2 ds3 ->
                           case ds1 of wild2 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# dt2 dt5) of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case {__pkg_ccall text-1.2.1.1 _hs_text_memcmp GHC.Prim.ByteArray#
                                                                               -> GHC.Prim.Word#
                                                                               -> GHC.Prim.ByteArray#
                                                                               -> GHC.Prim.Word#
                                                                               -> GHC.Prim.Word#
                                                                               -> GHC.Prim.State#
                                                                                      GHC.Prim.RealWorld
                                                                               -> (# GHC.Prim.State#
                                                                                         GHC.Prim.RealWorld,
                                                                                     GHC.Prim.Int# #)}
                                       dt
                                       (GHC.Prim.int2Word# dt1)
                                       dt3
                                       (GHC.Prim.int2Word# dt4)
                                       (GHC.Prim.int2Word# dt2)
                                       GHC.Prim.realWorld# of wild4 { (#,#) ds11 ds12 ->
                                case GHC.Prim.narrow32Int# ds12 of wild5 {
                                  DEFAULT -> GHC.Types.False 0 -> GHC.Types.True } } } } } })
                          ww of wild {
                     [] -> Data.Maybe.Nothing @ AS.Types.ASWindow
                     : x xs -> Data.Maybe.Just @ AS.Types.ASWindow x }) -}
21bac58ab24702b7be8ff8a8700b564a
  $wlastN :: GHC.Prim.Int# -> [a] -> [a]
    {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
       Unfolding: (\ @ a ww :: GHC.Prim.Int# w :: [a] ->
                   case GHC.List.$wlenAcc @ a w 0 of ww1 { DEFAULT ->
                   let {
                     n# :: GHC.Prim.Int# = GHC.Prim.-# ww1 ww
                   } in
                   case GHC.Prim.tagToEnum#
                          @ GHC.Types.Bool
                          (GHC.Prim.<# n# 0) of wild1 {
                     GHC.Types.False -> GHC.List.drop_drop# @ a n# w
                     GHC.Types.True -> w } }) -}
3fda1b5944e675bf944aa581f0fb294c
  $wlastN' :: GHC.Prim.Int# -> [a] -> [a]
    {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
       Unfolding: (\ @ a ww :: GHC.Prim.Int# w :: [a] ->
                   case GHC.Prim.tagToEnum#
                          @ GHC.Types.Bool
                          (GHC.Prim.<# ww 0) of wild1 {
                     GHC.Types.False
                     -> AS.Util.lastN'1 @ a w (GHC.List.drop_drop# @ a ww w)
                     GHC.Types.True -> AS.Util.lastN'1 @ a w w }) -}
e942831c7cc40e1a4cb88ff51c7b97d9
  $wshiftLoc :: GHC.Types.Int
                -> GHC.Types.Int
                -> AS.Types.ASLocation
                -> AS.Types.ASLocation
    {- Arity: 3, Strictness: <L,U(U)><L,U(U)><S,1*U>,
       Unfolding: (\ ww :: GHC.Types.Int
                     ww1 :: GHC.Types.Int
                     w :: AS.Types.ASLocation ->
                   case w of wild {
                     AS.Types.Index sh ds
                     -> case ds of wild1 { (,) y x ->
                        AS.Types.Index
                          sh
                          (GHC.Num.$fNumInt_$c+ y ww, GHC.Num.$fNumInt_$c+ x ww1) }
                     AS.Types.Range sh ds
                     -> case ds of wild1 { (,) ds1 ds2 ->
                        case ds1 of wild2 { (,) y x ->
                        case ds2 of wild3 { (,) y2 x2 ->
                        AS.Types.Range
                          sh
                          ((GHC.Num.$fNumInt_$c+ y ww, GHC.Num.$fNumInt_$c+ x ww1),
                           (GHC.Num.$fNumInt_$c+ y2 ww, GHC.Num.$fNumInt_$c+ x2 ww1)) } } }
                     AS.Types.Column ipv ipv1 -> AS.Util.shiftLoc1 }) -}
669f4194f5a33ab2b0832c88b0a25223
  $wupdateWindow :: AS.Types.ASWindow
                    -> AS.Types.ASUserId
                    -> Network.WebSockets.Connection.Connection
                    -> [AS.Types.ASWindow]
                    -> (# AS.Types.ASUserId,
                          Network.WebSockets.Connection.Connection,
                          [AS.Types.ASWindow] #)
    {- Arity: 4, HasNoCafRefs,
       Strictness: <L,U(U(U,U,U),U,U)><L,U><L,U><L,1*U>,
       Unfolding: (\ w :: AS.Types.ASWindow
                     ww :: AS.Types.ASUserId
                     ww1 :: Network.WebSockets.Connection.Connection
                     ww2 :: [AS.Types.ASWindow] ->
                   (# ww,
                      ww1,
                      GHC.Base.map
                        @ AS.Types.ASWindow
                        @ AS.Types.ASWindow
                        (\ w1 :: AS.Types.ASWindow ->
                         case w1 of wild { AS.Types.Window ds1 ds2 ds3 ->
                         case ds1 of wild1 { Data.Text.Internal.Text dt dt1 dt2 ->
                         case w of wild2 { AS.Types.Window ds4 ds5 ds6 ->
                         case ds4 of wild3 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.==# dt2 dt5) of wild4 {
                           GHC.Types.False -> wild
                           GHC.Types.True
                           -> case {__pkg_ccall text-1.2.1.1 _hs_text_memcmp GHC.Prim.ByteArray#
                                                                             -> GHC.Prim.Word#
                                                                             -> GHC.Prim.ByteArray#
                                                                             -> GHC.Prim.Word#
                                                                             -> GHC.Prim.Word#
                                                                             -> GHC.Prim.State#
                                                                                    GHC.Prim.RealWorld
                                                                             -> (# GHC.Prim.State#
                                                                                       GHC.Prim.RealWorld,
                                                                                   GHC.Prim.Int# #)}
                                     dt
                                     (GHC.Prim.int2Word# dt1)
                                     dt3
                                     (GHC.Prim.int2Word# dt4)
                                     (GHC.Prim.int2Word# dt2)
                                     GHC.Prim.realWorld# of wild5 { (#,#) ds11 ds12 ->
                              case GHC.Prim.narrow32Int# ds12 of wild6 {
                                DEFAULT -> wild 0 -> wild2 } } } } } } })
                        ww2 #)) -}
54de46b97b92869b2708595c03113312
  (<++>) :: Control.Applicative.Applicative f
            -> f [a]
            -> f [a]
            -> f [a]
    {- Arity: 3, HasNoCafRefs,
       Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A)><L,U><L,U>,
       Unfolding: InlineRule (3, True, False)
                  (\ @ (f::* -> *)
                     @ a
                     $dApplicative :: Control.Applicative.Applicative f
                     eta :: f [a]
                     eta1 :: f [a] ->
                   Control.Applicative.<*>
                     @ f
                     $dApplicative
                     @ [a]
                     @ [a]
                     (GHC.Base.fmap
                        @ f
                        (Control.Applicative.$p1Applicative @ f $dApplicative)
                        @ [a]
                        @ ([a] -> [a])
                        (GHC.Base.++ @ a)
                        eta)
                     eta1) -}
f315b93a3f6b3b1c6bb44d252a0a0b4d
  (<:>) :: Control.Applicative.Applicative f -> f a -> f [a] -> f [a]
    {- Arity: 3, HasNoCafRefs,
       Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A)><L,U><L,U>,
       Unfolding: InlineRule (3, True, False)
                  (\ @ (f::* -> *)
                     @ a
                     $dApplicative :: Control.Applicative.Applicative f
                     eta :: f a
                     eta1 :: f [a] ->
                   Control.Applicative.<*>
                     @ f
                     $dApplicative
                     @ [a]
                     @ [a]
                     (GHC.Base.fmap
                        @ f
                        (Control.Applicative.$p1Applicative @ f $dApplicative)
                        @ a
                        @ ([a] -> [a])
                        (GHC.Types.: @ a)
                        eta)
                     eta1) -}
cf97f4fdfa397bafbd170d2fbe9685eb
  addToAL :: GHC.Classes.Eq key
             -> [(key, elt)]
             -> key
             -> elt
             -> [(key, elt)]
    {- Arity: 4, HasNoCafRefs,
       Strictness: <L,U(A,C(C1(U)))><L,1*U><L,U><L,U>m2,
       Unfolding: InlineRule (4, True, False)
                  (\ @ key
                     @ elt
                     $dEq :: GHC.Classes.Eq key
                     l :: [(key, elt)]
                     key1 :: key
                     value :: elt ->
                   GHC.Types.:
                     @ (key, elt)
                     (key1, value)
                     (AS.Util.delFromAL @ key @ elt $dEq l key1)) -}
2196c333077ef38aff8753db9bcff343
  containsTrackingTag :: [AS.Types.ASCellTag] -> GHC.Types.Bool
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ce47ccb3bf5d1bf172caffa3afb8e1ac
  containsVolatileTag :: [AS.Types.ASCellTag] -> GHC.Types.Bool
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
029ee6d579cad48c88473e01acb70f98
  decomposeLocs :: AS.Types.ASLocation -> [AS.Types.ASLocation]
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ loc :: AS.Types.ASLocation ->
                   case loc of wild {
                     AS.Types.Index sheet a
                     -> GHC.Types.:
                          @ AS.Types.ASLocation
                          wild
                          (GHC.Types.[] @ AS.Types.ASLocation)
                     AS.Types.Range sheet ds
                     -> case ds of wild1 { (,) ul lr ->
                        case ul of wild2 { (,) x ds1 ->
                        case x of wild3 { GHC.Types.I# x1 ->
                        case lr of wild4 { (,) x2 ds2 ->
                        case x2 of wild5 { GHC.Types.I# y ->
                        let {
                          $j :: GHC.Prim.Int# -> [AS.Types.ASLocation]
                            {- Arity: 1, Strictness: <L,U> -}
                          = \ x3 :: GHC.Prim.Int# ->
                            let {
                              $j1 :: GHC.Prim.Int# -> [AS.Types.ASLocation]
                                {- Arity: 1, Strictness: <L,U> -}
                              = \ y1 :: GHC.Prim.Int# ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.># x3 y1) of wild6 {
                                  GHC.Types.False
                                  -> let {
                                       lvl :: [GHC.Types.Int]
                                       = case ds1 of wild7 { GHC.Types.I# x4 ->
                                         case ds2 of wild8 { GHC.Types.I# y2 ->
                                         let {
                                           $j2 :: GHC.Prim.Int# -> [GHC.Types.Int]
                                             {- Arity: 1, Strictness: <L,U> -}
                                           = \ x5 :: GHC.Prim.Int# ->
                                             case GHC.Prim.tagToEnum#
                                                    @ GHC.Types.Bool
                                                    (GHC.Prim.># x4 y2) of wild9 {
                                               GHC.Types.False -> GHC.Enum.eftInt x5 y2
                                               GHC.Types.True -> GHC.Enum.eftInt x5 x4 }
                                         } in
                                         case GHC.Prim.tagToEnum#
                                                @ GHC.Types.Bool
                                                (GHC.Prim.<# x4 y2) of wild9 {
                                           GHC.Types.False -> $j2 y2 GHC.Types.True -> $j2 x4 } } }
                                     } in
                                     letrec {
                                       go1 :: GHC.Prim.Int# -> [AS.Types.ASLocation]
                                         {- Arity: 1, Strictness: <L,U> -}
                                       = \ x4 :: GHC.Prim.Int# ->
                                         let {
                                           z :: [AS.Types.ASLocation]
                                           = case GHC.Prim.tagToEnum#
                                                    @ GHC.Types.Bool
                                                    (GHC.Prim.==# x4 y1) of wild7 {
                                               GHC.Types.False -> go1 (GHC.Prim.+# x4 1)
                                               GHC.Types.True
                                               -> GHC.Types.[] @ AS.Types.ASLocation }
                                         } in
                                         let {
                                           ds3 :: GHC.Types.Int {- Strictness: m -}
                                           = GHC.Types.I# x4
                                         } in
                                         letrec {
                                           go2 :: [GHC.Types.Int] -> [AS.Types.ASLocation]
                                             {- Arity: 1, Strictness: <S,1*U> -}
                                           = \ ds4 :: [GHC.Types.Int] ->
                                             case ds4 of wild7 {
                                               [] -> z
                                               : y2 ys
                                               -> GHC.Types.:
                                                    @ AS.Types.ASLocation
                                                    (AS.Types.Index sheet (ds3, y2))
                                                    (go2 ys) }
                                         } in
                                         go2 lvl
                                     } in
                                     go1 x3
                                  GHC.Types.True -> GHC.Types.[] @ AS.Types.ASLocation }
                            } in
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.># x1 y) of wild6 {
                              GHC.Types.False -> $j1 y GHC.Types.True -> $j1 x1 }
                        } in
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<# x1 y) of wild6 {
                          GHC.Types.False -> $j y GHC.Types.True -> $j x1 } } } } } }
                     AS.Types.Column ipv ipv1 -> AS.Util.decomposeLocs1 }) -}
d0c7c701cf9d21fbbcec51af10d2805c
  decomposeLocs1 :: [AS.Types.ASLocation] {- Strictness: b -}
ed18fe0d4597960d488cf61c5d9c4cfe
  delFromAL :: GHC.Classes.Eq key -> [(key, a)] -> key -> [(key, a)]
    {- Arity: 3, HasNoCafRefs,
       Strictness: <L,U(A,C(C1(U)))><S,1*U><L,U>,
       Unfolding: (\ @ key
                     @ a
                     $dEq :: GHC.Classes.Eq key
                     l :: [(key, a)]
                     key1 :: key ->
                   GHC.List.filter
                     @ (key, a)
                     (\ a1 :: (key, a) ->
                      GHC.Classes./=
                        @ key
                        $dEq
                        (case a1 of wild { (,) x ds1 -> x })
                        key1)
                     l) -}
118ce46cb867d1c8609a416db4079cfd
  deleteSubset :: GHC.Classes.Eq a -> [a] -> [a] -> [a]
    {- Arity: 3, HasNoCafRefs,
       Strictness: <L,U(A,C(C1(U)))><L,U><S,1*U>,
       Unfolding: (\ @ a
                     $dEq :: GHC.Classes.Eq a
                     subset :: [a]
                     eta :: [a] ->
                   GHC.List.filter
                     @ a
                     (\ e :: a -> GHC.List.notElem @ a $dEq e subset)
                     eta) -}
df1be5e7593df247ae94bb0d63bcc510
  every :: GHC.Types.Int -> [a] -> [a]
    {- Arity: 2, Strictness: <L,U(U)><L,U>,
       Unfolding: (\ @ a n :: GHC.Types.Int eta :: [a] ->
                   case GHC.List.$witerate
                          @ [a]
                          (GHC.List.drop @ a n)
                          eta of ww { (#,#) ww1 ww2 ->
                   GHC.Base.map
                     @ [a]
                     @ a
                     (GHC.List.head @ a)
                     (GHC.List.takeWhile
                        @ [a]
                        (AS.Util.every1 @ a)
                        (GHC.Types.: @ [a] ww1 ww2)) }) -}
651c9c1aa23160c87468ff0c8b7b300c
  every1 :: [a] -> GHC.Types.Bool
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ @ a x :: [a] ->
                   case x of wild {
                     [] -> GHC.Types.False : ds1 ds2 -> GHC.Types.True }) -}
fe7e1f608e50ce271b2415f3a19f7abe
  filterNothing :: [Data.Maybe.Maybe a] -> [a]
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ @ a l :: [Data.Maybe.Maybe a] ->
                   AS.Util.filterNothing1 @ a l) -}
8945d4169100bbc72011c3203f5b5c3a
  filterNothing1 :: [Data.Maybe.Maybe a] -> [a]
    {- Arity: 1, Strictness: <S,1*U> -}
11e560cad18f43ed5fbccc630a5926b2
  fromJustList :: [Data.Maybe.Maybe a] -> [a]
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ @ a l :: [Data.Maybe.Maybe a] ->
                   GHC.Base.map
                     @ (Data.Maybe.Maybe a)
                     @ a
                     (AS.Util.fromJustList1 @ a)
                     l) -}
4116d9664c759eee96e8315d3f37dbd9
  fromJustList1 :: Data.Maybe.Maybe a -> a
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ @ a ds :: Data.Maybe.Maybe a ->
                   case ds of wild {
                     Data.Maybe.Nothing
                     -> Control.Exception.Base.patError
                          @ a
                          "src/AS/Util.hs:57:23-36|lambda"#
                     Data.Maybe.Just x -> x }) -}
d0b1ec9e971d90745b6b8595595a2478
  fromRight :: Data.Either.Either a b -> b
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ @ a @ b ds :: Data.Either.Either a b ->
                   case ds of wild {
                     Data.Either.Left ipv -> AS.Util.fromRight1 @ b
                     Data.Either.Right b1 -> b1 }) -}
d43cde4d2bc504368a9e9f32d3b75bc6
  fromRight1 :: b {- Strictness: b -}
4b74e131547a8909b0158ddcb9c53148
  generateErrorMessage :: AS.Types.ASExecError -> GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ ds :: AS.Types.ASExecError ->
                   case ds of wild {
                     DEFAULT -> AS.Util.generateErrorMessage3
                     AS.Types.DBNothingException ds1 -> AS.Util.generateErrorMessage2
                     AS.Types.CopyNonexistentDependencies
                     -> AS.Util.generateErrorMessage1 }) -}
a1809184260d1ad46da2be4e22373e17
  generateErrorMessage1 :: [GHC.Types.Char]
    {- Unfolding: (GHC.CString.unpackCString#
                     "Some dependencies nonexistent in copied cell expressions."#) -}
efe044ff8305c2b08c3322674eec54f7
  generateErrorMessage2 :: [GHC.Types.Char]
    {- Unfolding: (GHC.CString.unpackCString#
                     "Unable to fetch cells from database."#) -}
5c04b221d04dd85d14d5b13675e92e58
  generateErrorMessage3 :: GHC.Base.String {- Strictness: b -}
71ef0640d6461997bd3b7be8f3ac5b5d
  getASTime :: GHC.Types.IO AS.Types.ASTime
    {- Arity: 1, Strictness: <L,U>,
       Unfolding: (AS.Util.getASTime1
                     `cast`
                   (Sym (GHC.Types.NTCo:IO[0] <AS.Types.ASTime>_R))) -}
0ffdabd2aa0deba4e4bcb2c355064e86
  getASTime1 :: GHC.Prim.State# GHC.Prim.RealWorld
                -> (# GHC.Prim.State# GHC.Prim.RealWorld, AS.Types.ASTime #)
    {- Arity: 1, Strictness: <L,U>,
       Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld ->
                   (# s, AS.Util.getASTime2 #)) -}
93488408d56074c5b7629c666225ac63
  getASTime2 :: AS.Types.ASTime
    {- Unfolding: (AS.Types.Time
                     AS.Util.getASTime6
                     AS.Util.getASTime5
                     AS.Util.getASTime4
                     AS.Util.getASTime3) -}
28e5c213dbb9c45ba628f5b7ea3b0709
  getASTime3 :: GHC.Types.Int
    {- HasNoCafRefs, Unfolding: (GHC.Types.I# 3) -}
00a49bf54709b4baabb4d299c22932d8
  getASTime4 :: GHC.Types.Int
    {- HasNoCafRefs, Unfolding: (GHC.Types.I# 2) -}
438426c99e41ae4bf454cfeb589aa6e8
  getASTime5 :: GHC.Types.Int
    {- HasNoCafRefs, Unfolding: (GHC.Types.I# 1) -}
ddc4e71db8e969f26514daeaa0ce1cb3
  getASTime6 :: [GHC.Types.Char]
    {- Unfolding: (GHC.CString.unpackCString# "hi"#) -}
2a3878525365095f0ad9585e2e368d2b
  getAllUserWindows :: AS.Types.ServerState
                       -> [(AS.Types.ASUserId, [AS.Types.ASWindow])]
    {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
       Unfolding: InlineRule (1, True, False)
                  (\ state :: AS.Types.ServerState ->
                   case state of wild { AS.Types.State ds1 ds2 ds3 ->
                   GHC.Base.build
                     @ (AS.Types.ASUserId, [AS.Types.ASWindow])
                     (\ @ b1
                        c :: (AS.Types.ASUserId, [AS.Types.ASWindow]) -> b1 -> b1
                        n :: b1 ->
                      GHC.Base.foldr
                        @ AS.Types.ASUser
                        @ b1
                        (GHC.Base.mapFB
                           @ (AS.Types.ASUserId, [AS.Types.ASWindow])
                           @ b1
                           @ AS.Types.ASUser
                           c
                           AS.Util.getAllUserWindows1)
                        n
                        ds1) }) -}
22829989eb42c9e992eaaf815c4079a3
  getAllUserWindows1 :: AS.Types.ASUser
                        -> (AS.Types.ASUserId, [AS.Types.ASWindow])
    {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U(U,U,U),A,1*U)>m,
       Unfolding: InlineRule (1, True, False)
                  (\ u :: AS.Types.ASUser ->
                   (AS.Types.userId u, AS.Types.windows u)) -}
a25a0d69c5a1aa819af9e03cd08fd1d4
  getBadLocs :: [AS.Types.ASLocation]
                -> [Data.Maybe.Maybe AS.Types.ASCell]
                -> [AS.Types.ASLocation]
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
       Unfolding: (\ locs :: [AS.Types.ASLocation]
                     mcells :: [Data.Maybe.Maybe AS.Types.ASCell] ->
                   AS.Util.getBadLocs_go locs mcells) -}
f5ea8b102b97744f04af1f4be4c044a3
  getBadLocs_go :: [AS.Types.ASLocation]
                   -> [Data.Maybe.Maybe AS.Types.ASCell]
                   -> [AS.Types.ASLocation]
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
475635160056f0516e3393a653499730
  getCellMessage :: AS.Types.ASUserId
                    -> Data.Either.Either AS.Types.ASExecError [AS.Types.ASCell]
                    -> AS.Types.ASMessage
    {- Arity: 2, Strictness: <L,U><S,1*U>m,
       Unfolding: InlineRule (2, True, False)
                  (\ uid :: AS.Types.ASUserId
                     ds :: Data.Either.Either AS.Types.ASExecError [AS.Types.ASCell] ->
                   case ds of wild {
                     Data.Either.Left e
                     -> AS.Types.Message
                          uid
                          AS.Types.Evaluate
                          (AS.Types.Failure (AS.Util.generateErrorMessage e))
                          AS.Util.getCellMessage1
                     Data.Either.Right cells
                     -> AS.Types.Message
                          uid
                          AS.Types.Evaluate
                          AS.Types.Success
                          (AS.Types.PayloadCL cells) }) -}
ff05502a27e8d8f1d3016e2266b01b99
  getCellMessage1 :: AS.Types.ASPayload
    {- HasNoCafRefs, Strictness: m1,
       Unfolding: (AS.Types.PayloadN GHC.Tuple.()) -}
c3e7a66f93259db8bbb69c6e7c1ad1a5
  getDBCellMessage :: AS.Types.ASUser
                      -> [AS.Types.ASLocation]
                      -> [Data.Maybe.Maybe AS.Types.ASCell]
                      -> AS.Types.ASMessage
    {- Arity: 3, HasNoCafRefs,
       Strictness: <L,1*U(1*U,A,A)><L,A><L,1*U>m, Inline: INLINE[0],
       Unfolding: InlineRule (3, True, False)
                  (\ w :: AS.Types.ASUser
                     w1 :: [AS.Types.ASLocation]
                     w2 :: [Data.Maybe.Maybe AS.Types.ASCell] ->
                   AS.Types.Message
                     (case w of wild { AS.Types.UserClient ds1 ds2 ds3 -> ds1 })
                     AS.Types.Evaluate
                     AS.Types.Success
                     (AS.Types.PayloadCL
                        (letrec {
                           go1 :: [Data.Maybe.Maybe AS.Types.ASCell] -> [AS.Types.ASCell]
                             {- Arity: 1, Strictness: <S,1*U> -}
                           = \ ds :: [Data.Maybe.Maybe AS.Types.ASCell] ->
                             case ds of wild {
                               [] -> GHC.Types.[] @ AS.Types.ASCell
                               : y ys
                               -> case y of wild1 {
                                    Data.Maybe.Nothing -> go1 ys
                                    Data.Maybe.Just ipv
                                    -> GHC.Types.: @ AS.Types.ASCell ipv (go1 ys) } }
                         } in
                         go1 w2))) -}
a6607d93da5d86670e923e68c1680f29
  getOffsetBetweenLocs :: AS.Types.ASLocation
                          -> AS.Types.ASLocation
                          -> (GHC.Types.Int, GHC.Types.Int)
    {- Arity: 2, Strictness: <S,1*U><S,1*U>m, Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ w :: AS.Types.ASLocation w1 :: AS.Types.ASLocation ->
                   case AS.Util.$wgetOffsetBetweenLocs w w1 of ww { (#,#) ww1 ww2 ->
                   (ww1, ww2) }) -}
60254a2791ba7e5656f6563c5caaf432
  getOffsetBetweenLocs1 :: (GHC.Types.Int, GHC.Types.Int)
    {- Strictness: b -}
39e5e61832aeb02226917a0b7f89dca3
  getScrolledLocs :: AS.Types.ASWindow
                     -> AS.Types.ASWindow
                     -> [AS.Types.ASLocation]
    {- Arity: 2, HasNoCafRefs,
       Strictness: <S(LS(S(S)L)S),1*U(A,1*U(1*U(U),U(U)),U(U(U),U(U)))><S,1*U(U,U(U(U),U(U)),U(U(U),U(U)))>,
       Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ w :: AS.Types.ASWindow w1 :: AS.Types.ASWindow ->
                   case w of ww { AS.Types.Window ww1 ww2 ww3 ->
                   case ww2 of ww4 { (,) ww5 ww6 ->
                   case ww5 of ww7 { GHC.Types.I# ww8 ->
                   case ww3 of ww9 { (,) ww10 ww11 ->
                   case w1 of ww12 { AS.Types.Window ww13 ww14 ww15 ->
                   AS.Util.$wgetScrolledLocs
                     ww8
                     ww6
                     ww10
                     ww11
                     ww13
                     ww14
                     ww15 } } } } }) -}
74bc43d8d661010b1e29214632bf275f
  getStreamTag :: [AS.Types.ASCellTag]
                  -> Data.Maybe.Maybe AS.Types.Stream
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
df969df1b164014d22a7e1d5c349f9b1
  getStreamTagFromExpression :: AS.Types.ASExpression
                                -> Data.Maybe.Maybe AS.Types.Stream
    {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
       Unfolding: InlineRule (1, True, True)
                  (\ xp :: AS.Types.ASExpression ->
                   Data.Maybe.Nothing @ AS.Types.Stream) -}
296217294380759d6260576c395bb091
  getTime :: GHC.Types.IO GHC.Base.String
    {- Arity: 1, Strictness: <L,U>,
       Unfolding: (AS.Util.getTime1
                     `cast`
                   (Sym (GHC.Types.NTCo:IO[0] <GHC.Base.String>_R))) -}
35addb6a373e713dc0b4a5ec84f6d43d
  getTime1 :: GHC.Prim.State# GHC.Prim.RealWorld
              -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Base.String #)
    {- Arity: 1, Strictness: <L,U>,
       Unfolding: (\ eta :: GHC.Prim.State# GHC.Prim.RealWorld ->
                   case Data.Time.Clock.POSIX.getPOSIXTime1
                          eta of ds1 { (#,#) ipv ipv1 ->
                   (# ipv,
                      case Data.Time.Clock.POSIX.$wposixSecondsToUTCTime
                             ipv1 of ww { (#,#) ww1 ww2 ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        (Data.Fixed.showFixed
                           @ Data.Fixed.E12
                           Data.Fixed.$fHasResolutionE12_$cresolution
                             `cast`
                           (Sym (Data.Fixed.NTCo:HasResolution[0] <Data.Fixed.E12>_N))
                           GHC.Types.True
                           ww2 `cast` (Data.Time.Clock.Scale.NTCo:DiffTime[0]))
                        Data.Time.Clock.Scale.$fShowDiffTime3 } #) }) -}
6aa67f1d6f0ee7316219cfce39868d6c
  getTopLeft :: AS.Types.ASLocation -> AS.Types.ASLocation
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ ds :: AS.Types.ASLocation ->
                   case ds of wild {
                     DEFAULT -> wild
                     AS.Types.Range sh ds1
                     -> case ds1 of wild1 { (,) tl ds2 -> AS.Types.Index sh tl } }) -}
8e19c210ca7e6b1726cb312026e96045
  getUncoveredLocs :: AS.Types.ASSheetId
                      -> ((GHC.Types.Int, GHC.Types.Int), (GHC.Types.Int, GHC.Types.Int))
                      -> ((GHC.Types.Int, GHC.Types.Int), (GHC.Types.Int, GHC.Types.Int))
                      -> [AS.Types.ASLocation]
    {- Arity: 3, HasNoCafRefs,
       Strictness: <L,U><S,1*U(U(U,U),U(U,U))><S,1*U(U(U,U),U(U,U))>m2,
       Inline: INLINE[0],
       Unfolding: InlineRule (3, True, False)
                  (\ w :: AS.Types.ASSheetId
                     w1 :: ((GHC.Types.Int, GHC.Types.Int),
                            (GHC.Types.Int, GHC.Types.Int))
                     w2 :: ((GHC.Types.Int, GHC.Types.Int),
                            (GHC.Types.Int, GHC.Types.Int)) ->
                   case w1 of ww { (,) ww1 ww2 ->
                   case w2 of ww3 { (,) ww4 ww5 ->
                   case AS.Util.$wgetUncoveredLocs
                          w
                          ww1
                          ww2
                          ww4
                          ww5 of ww6 { (#,#) ww7 ww8 ->
                   GHC.Types.: @ AS.Types.ASLocation ww7 ww8 } } }) -}
42a8534a1f39ca5218122892a4177e4c
  getUniqueId :: GHC.Types.IO Data.Text.Internal.Text
    {- Arity: 1, Strictness: <L,U>,
       Unfolding: (AS.Util.getUniqueId1
                     `cast`
                   (Sym (GHC.Types.NTCo:IO[0] <Data.Text.Internal.Text>_R))) -}
c8c138eba04330de7162e7c5b88b2543
  getUniqueId1 :: GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                        Data.Text.Internal.Text #)
    {- Arity: 1, Strictness: <L,U>,
       Unfolding: (\ s :: GHC.Prim.State# GHC.Prim.RealWorld ->
                   case System.Random.theStdGen
                          `cast`
                        (GHC.IORef.NTCo:IORef[0] <System.Random.StdGen>_N) of ww { GHC.STRef.STRef ww1 ->
                   case GHC.Prim.atomicModifyMutVar#
                          @ GHC.Prim.RealWorld
                          @ System.Random.StdGen
                          @ (System.Random.StdGen, Data.UUID.Types.Internal.UUID)
                          @ Data.UUID.Types.Internal.UUID
                          ww1
                          Data.UUID.Types.Internal.$fRandomUUID2
                          s of ds1 { (#,#) ipv ipv1 ->
                   case ipv1 of b1 { Data.UUID.Types.Internal.UUID ipv2 ipv3 ipv4 ipv5 ->
                   (# ipv,
                      case Data.UUID.Types.Internal.$wtoString
                             ipv2
                             ipv3
                             ipv4
                             ipv5 of ww5 { (#,#) ww6 ww7 ->
                      GHC.ST.runSTRep
                        @ Data.Text.Internal.Text
                        (\ @ s1 s2 :: GHC.Prim.State# s1 ->
                         case GHC.Prim.newByteArray# @ s1 8 s2 of ds2 { (#,#) ipv6 ipv7 ->
                         AS.Util.getUniqueId3
                           @ s1
                           (Data.Text.Array.MArray @ s1 ipv7)
                           AS.Util.getUniqueId2
                           (GHC.Types.: @ GHC.Types.Char ww6 ww7)
                           0
                           ipv6 }) } #) } } }) -}
0bcab81a56e11cef5d8a96571cb7a4d6
  getUniqueId2 :: GHC.Types.Int
    {- HasNoCafRefs, Unfolding: (GHC.Types.I# 4) -}
128a4d1f08e79101ab4078928503b247
  getUniqueId3 :: Data.Text.Array.MArray s1
                  -> GHC.Types.Int
                  -> [GHC.Types.Char]
                  -> GHC.Prim.Int#
                  -> GHC.Prim.State# s1
                  -> (# GHC.Prim.State# s1, Data.Text.Internal.Text #)
    {- Arity: 5, Strictness: <L,U(U)><L,U(U)><S,1*U><L,U><L,U> -}
eb52a544b59037659d20819a8d3d5a97
  getWindow :: AS.Types.ASSheetId
               -> AS.Types.ASUser
               -> Data.Maybe.Maybe AS.Types.ASWindow
    {- Arity: 2, HasNoCafRefs,
       Strictness: <L,U(U,U,U)><S(LLS),1*U(A,A,1*U)>, Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ w :: AS.Types.ASSheetId w1 :: AS.Types.ASUser ->
                   case w1 of ww { AS.Types.UserClient ww1 ww2 ww3 ->
                   AS.Util.$wgetWindow w ww3 }) -}
9f47a0b70f2205349a100a882f597d7d
  hasPermissions :: AS.Types.ASUserId
                    -> AS.Types.ASPermissions
                    -> GHC.Types.Bool
    {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,U,U)><S,1*U>,
       Unfolding: (\ uid :: AS.Types.ASUserId
                     ds :: AS.Types.ASPermissions ->
                   case ds of wild {
                     AS.Types.Blacklist entities
                     -> case GHC.List.any
                               @ AS.Types.ASEntity
                               (AS.Util.isInEntity uid)
                               entities of wild1 {
                          GHC.Types.False -> GHC.Types.True
                          GHC.Types.True -> GHC.Types.False }
                     AS.Types.Whitelist entities
                     -> GHC.List.any
                          @ AS.Types.ASEntity
                          (AS.Util.isInEntity uid)
                          entities }) -}
4b57ae6da4a9da6dfb64560add96b341
  hasVolatileTag :: AS.Types.ASCell -> GHC.Types.Bool
    {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
       Unfolding: InlineRule (1, True, False)
                  (\ x :: AS.Types.ASCell ->
                   AS.Util.containsVolatileTag (AS.Types.cellTags x)) -}
d3381cac645cb51ef129d9533269345c
  intersectViewingWindows :: [AS.Types.ASCell]
                             -> [AS.Types.ASWindow]
                             -> [AS.Types.ASCell]
    {- Arity: 2, Strictness: <L,U><S,1*U>,
       Unfolding: (\ cells :: [AS.Types.ASCell]
                     vws :: [AS.Types.ASWindow] ->
                   letrec {
                     go1 :: [AS.Types.ASWindow] -> [AS.Types.ASCell]
                       {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [AS.Types.ASWindow] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ AS.Types.ASCell
                         : y ys
                         -> GHC.Base.++
                              @ AS.Types.ASCell
                              (GHC.List.filter
                                 @ AS.Types.ASCell
                                 (\ ds1 :: AS.Types.ASCell ->
                                  case y of wild1 { AS.Types.Window wSheetId ds2 ds3 ->
                                  case ds2 of wild2 { (,) tlc tlr ->
                                  case ds3 of wild3 { (,) brc brr ->
                                  case ds1 of wild4 { AS.Types.Cell ds4 ds5 ds6 ds7 ->
                                  case ds4 of wild5 {
                                    DEFAULT -> AS.Util.intersectViewingWindows1
                                    AS.Types.Index cSheetId ds8
                                    -> case ds8 of wild6 { (,) col row ->
                                       case wSheetId of wild7 { Data.Text.Internal.Text dt dt1 dt2 ->
                                       case cSheetId of wild8 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                                       case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.==# dt2 dt5) of wild9 {
                                         GHC.Types.False -> GHC.Types.False
                                         GHC.Types.True
                                         -> case {__pkg_ccall text-1.2.1.1 _hs_text_memcmp GHC.Prim.ByteArray#
                                                                                           -> GHC.Prim.Word#
                                                                                           -> GHC.Prim.ByteArray#
                                                                                           -> GHC.Prim.Word#
                                                                                           -> GHC.Prim.Word#
                                                                                           -> GHC.Prim.State#
                                                                                                  GHC.Prim.RealWorld
                                                                                           -> (# GHC.Prim.State#
                                                                                                     GHC.Prim.RealWorld,
                                                                                                 GHC.Prim.Int# #)}
                                                   dt
                                                   (GHC.Prim.int2Word# dt1)
                                                   dt3
                                                   (GHC.Prim.int2Word# dt4)
                                                   (GHC.Prim.int2Word# dt2)
                                                   GHC.Prim.realWorld# of wild10 { (#,#) ds11 ds12 ->
                                            case GHC.Prim.narrow32Int# ds12 of wild11 {
                                              DEFAULT -> GHC.Types.False
                                              0
                                              -> case col of wild12 { GHC.Types.I# x ->
                                                 case tlc of wild13 { GHC.Types.I# y1 ->
                                                 case GHC.Prim.tagToEnum#
                                                        @ GHC.Types.Bool
                                                        (GHC.Prim.>=# x y1) of wild14 {
                                                   GHC.Types.False -> GHC.Types.False
                                                   GHC.Types.True
                                                   -> case brc of wild15 { GHC.Types.I# x1 ->
                                                      case GHC.Prim.tagToEnum#
                                                             @ GHC.Types.Bool
                                                             (GHC.Prim.<=#
                                                                x
                                                                (GHC.Prim.+#
                                                                   y1
                                                                   (GHC.Prim.-# x1 y1))) of wild16 {
                                                        GHC.Types.False -> GHC.Types.False
                                                        GHC.Types.True
                                                        -> case row of wild17 { GHC.Types.I# x2 ->
                                                           case tlr of wild18 { GHC.Types.I# y2 ->
                                                           case GHC.Prim.tagToEnum#
                                                                  @ GHC.Types.Bool
                                                                  (GHC.Prim.>=# x2 y2) of wild19 {
                                                             GHC.Types.False -> GHC.Types.False
                                                             GHC.Types.True
                                                             -> case brr of wild20 { GHC.Types.I# x3 ->
                                                                GHC.Prim.tagToEnum#
                                                                  @ GHC.Types.Bool
                                                                  (GHC.Prim.<=#
                                                                     x2
                                                                     (GHC.Prim.+#
                                                                        y2
                                                                        (GHC.Prim.-#
                                                                           x3
                                                                           y2))) } } } } } } } } } } } } } } } } } } } })
                                 cells)
                              (go1 ys) }
                   } in
                   go1 vws) -}
279f7a26829e12299f06212aa3cb8013
  intersectViewingWindows1 :: GHC.Types.Bool {- Strictness: b -}
f2f9c9e8adb608d9aebaee4b953514ef
  intersectViewingWindowsLocs :: [AS.Types.ASLocation]
                                 -> [AS.Types.ASWindow]
                                 -> [AS.Types.ASLocation]
    {- Arity: 2, Strictness: <L,1*U><S,1*U>,
       Unfolding: (\ locs :: [AS.Types.ASLocation]
                     vws :: [AS.Types.ASWindow] ->
                   let {
                     locs1 :: [AS.Types.ASLocation]
                     = AS.Util.intersectViewingWindowsLocs_go locs
                   } in
                   letrec {
                     go1 :: [AS.Types.ASWindow] -> [AS.Types.ASLocation]
                       {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [AS.Types.ASWindow] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ AS.Types.ASLocation
                         : y ys
                         -> GHC.Base.++
                              @ AS.Types.ASLocation
                              (GHC.List.filter
                                 @ AS.Types.ASLocation
                                 (\ ds1 :: AS.Types.ASLocation ->
                                  case y of wild1 { AS.Types.Window wSheetId ds2 ds3 ->
                                  case ds2 of wild2 { (,) tlc tlr ->
                                  case ds3 of wild3 { (,) brc brr ->
                                  case ds1 of wild4 {
                                    DEFAULT -> AS.Util.intersectViewingWindowsLocs1
                                    AS.Types.Index cSheetId ds4
                                    -> case ds4 of wild5 { (,) col row ->
                                       case wSheetId of wild6 { Data.Text.Internal.Text dt dt1 dt2 ->
                                       case cSheetId of wild7 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                                       case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.==# dt2 dt5) of wild8 {
                                         GHC.Types.False -> GHC.Types.False
                                         GHC.Types.True
                                         -> case {__pkg_ccall text-1.2.1.1 _hs_text_memcmp GHC.Prim.ByteArray#
                                                                                           -> GHC.Prim.Word#
                                                                                           -> GHC.Prim.ByteArray#
                                                                                           -> GHC.Prim.Word#
                                                                                           -> GHC.Prim.Word#
                                                                                           -> GHC.Prim.State#
                                                                                                  GHC.Prim.RealWorld
                                                                                           -> (# GHC.Prim.State#
                                                                                                     GHC.Prim.RealWorld,
                                                                                                 GHC.Prim.Int# #)}
                                                   dt
                                                   (GHC.Prim.int2Word# dt1)
                                                   dt3
                                                   (GHC.Prim.int2Word# dt4)
                                                   (GHC.Prim.int2Word# dt2)
                                                   GHC.Prim.realWorld# of wild9 { (#,#) ds11 ds12 ->
                                            case GHC.Prim.narrow32Int# ds12 of wild10 {
                                              DEFAULT -> GHC.Types.False
                                              0
                                              -> case col of wild11 { GHC.Types.I# x ->
                                                 case tlc of wild12 { GHC.Types.I# y1 ->
                                                 case GHC.Prim.tagToEnum#
                                                        @ GHC.Types.Bool
                                                        (GHC.Prim.>=# x y1) of wild13 {
                                                   GHC.Types.False -> GHC.Types.False
                                                   GHC.Types.True
                                                   -> case brc of wild14 { GHC.Types.I# x1 ->
                                                      case GHC.Prim.tagToEnum#
                                                             @ GHC.Types.Bool
                                                             (GHC.Prim.<=#
                                                                x
                                                                (GHC.Prim.+#
                                                                   y1
                                                                   (GHC.Prim.-# x1 y1))) of wild15 {
                                                        GHC.Types.False -> GHC.Types.False
                                                        GHC.Types.True
                                                        -> case row of wild16 { GHC.Types.I# x2 ->
                                                           case tlr of wild17 { GHC.Types.I# y2 ->
                                                           case GHC.Prim.tagToEnum#
                                                                  @ GHC.Types.Bool
                                                                  (GHC.Prim.>=# x2 y2) of wild18 {
                                                             GHC.Types.False -> GHC.Types.False
                                                             GHC.Types.True
                                                             -> case brr of wild19 { GHC.Types.I# x3 ->
                                                                GHC.Prim.tagToEnum#
                                                                  @ GHC.Types.Bool
                                                                  (GHC.Prim.<=#
                                                                     x2
                                                                     (GHC.Prim.+#
                                                                        y2
                                                                        (GHC.Prim.-#
                                                                           x3
                                                                           y2))) } } } } } } } } } } } } } } } } } } })
                                 locs1)
                              (go1 ys) }
                   } in
                   go1 vws) -}
ebedaa146c94522a8a7db03c6fa45124
  intersectViewingWindowsLocs1 :: GHC.Types.Bool {- Strictness: b -}
f203d11282db755f34c4ed9307750fcd
  intersectViewingWindowsLocs_go :: [AS.Types.ASLocation]
                                    -> [AS.Types.ASLocation]
    {- Arity: 1, Strictness: <S,1*U> -}
0bd7f01b0034be74037e4ac72c1d94a6
  isAllRight :: [Data.Either.Either a b] -> GHC.Types.Bool
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ @ a @ b results :: [Data.Either.Either a b] ->
                   AS.Util.isAllRight1 @ a @ b results) -}
ce1ca7f8c81026b0497c584312b39c60
  isAllRight1 :: [Data.Either.Either a b] -> GHC.Types.Bool
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
af7950958e920f07b68519d8f38dddb1
  isColumn :: AS.Types.ASLocation -> GHC.Types.Bool
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ ds :: AS.Types.ASLocation ->
                   case ds of wild {
                     DEFAULT -> GHC.Types.False
                     AS.Types.Column ds1 ds2 -> GHC.Types.True }) -}
3cefe10cc83df5d3e0d143989231e8a9
  isGroupAdmin :: AS.Types.ASUserId
                  -> AS.Types.ASUserGroup
                  -> GHC.Types.Bool
    {- Arity: 2, HasNoCafRefs,
       Strictness: <L,U(U,U,U)><S(LSL),1*U(A,1*U,A)>,
       Unfolding: InlineRule (2, True, False)
                  (\ uid :: AS.Types.ASUserId group :: AS.Types.ASUserGroup ->
                   case group of wild { AS.Types.Group ds1 ds2 ds3 ->
                   GHC.List.any
                     @ AS.Types.ASUserId
                     (Data.Text.$fEqText_$c== uid)
                     ds2 }) -}
f850abc97dbf2dbc96f3f3a6340f9525
  isGroupMember :: AS.Types.ASUserId
                   -> AS.Types.ASUserGroup
                   -> GHC.Types.Bool
    {- Arity: 2, HasNoCafRefs,
       Strictness: <L,U(U,U,U)><S(SLL),1*U(1*U,A,A)>,
       Unfolding: InlineRule (2, True, False)
                  (\ uid :: AS.Types.ASUserId group :: AS.Types.ASUserGroup ->
                   case group of wild { AS.Types.Group ds1 ds2 ds3 ->
                   GHC.List.any
                     @ AS.Types.ASUserId
                     (Data.Text.$fEqText_$c== uid)
                     ds1 }) -}
c35be6e9497ee7d96917e9de7725c64e
  isInEntity :: AS.Types.ASUserId
                -> AS.Types.ASEntity
                -> GHC.Types.Bool
    {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,U,U)><S,1*U>,
       Unfolding: (\ uid :: AS.Types.ASUserId ds :: AS.Types.ASEntity ->
                   case ds of wild {
                     AS.Types.EntityGroup group -> AS.Util.isGroupMember uid group
                     AS.Types.EntityUser userid
                     -> Data.Text.$fEqText_$c== uid userid }) -}
4f9c691262e596b530cd6b240e8680b6
  isJust :: Data.Maybe.Maybe AS.Types.ASCell -> GHC.Types.Bool
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ ds :: Data.Maybe.Maybe AS.Types.ASCell ->
                   case ds of wild {
                     Data.Maybe.Nothing -> GHC.Types.False
                     Data.Maybe.Just c -> GHC.Types.True }) -}
f7e4e956d5ac3d1b1e21cda3ea79cb4e
  isRight :: Data.Either.Either a b -> GHC.Types.Bool
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ @ a @ b ds :: Data.Either.Either a b ->
                   case ds of wild {
                     Data.Either.Left ipv -> GHC.Types.False
                     Data.Either.Right ds1 -> GHC.Types.True }) -}
82e5b136dfc8cfd4c920a761825edbb8
  isSubsetOf :: GHC.Classes.Eq a -> [a] -> [a] -> GHC.Types.Bool
    {- Arity: 3, HasNoCafRefs,
       Strictness: <L,U(C(C1(U)),A)><S,1*U><L,U>,
       Unfolding: (\ @ a $dEq :: GHC.Classes.Eq a ds :: [a] ds1 :: [a] ->
                   case ds of wild {
                     [] -> GHC.Types.True
                     : ipv ipv1
                     -> letrec {
                          go1 :: [a] -> GHC.Types.Bool {- Arity: 1, Strictness: <S,1*U> -}
                          = \ ds2 :: [a] ->
                            case ds2 of wild1 {
                              [] -> GHC.Types.True
                              : y ys
                              -> case GHC.List.elem @ a $dEq y ds1 of wild2 {
                                   GHC.Types.False -> GHC.Types.False GHC.Types.True -> go1 ys } }
                        } in
                        go1 wild }) -}
9a6dba2f2000b050cd4cfdc1f0c7dec0
  isoFilter :: (a -> GHC.Types.Bool) -> [a] -> [b] -> [b]
    {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><S,1*U><L,1*U>,
       Unfolding: (\ @ a
                     @ b
                     f :: a -> GHC.Types.Bool
                     pimg :: [a]
                     img :: [b] ->
                   letrec {
                     go1 :: [a] -> [b] -> [b] {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                     = \ ds :: [a] _ys :: [b] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ b
                         : ipv ipv1
                         -> case _ys of wild1 {
                              [] -> GHC.Types.[] @ b
                              : ipv2 ipv3
                              -> case f ipv of wild2 {
                                   GHC.Types.False -> go1 ipv1 ipv3
                                   GHC.Types.True -> GHC.Types.: @ b ipv2 (go1 ipv1 ipv3) } } }
                   } in
                   go1 pimg img) -}
b34a40e5995ddde33910fe92689624e3
  lastN :: GHC.Types.Int -> [a] -> [a]
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,U>,
       Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ @ a w :: GHC.Types.Int w1 :: [a] ->
                   case w of ww { GHC.Types.I# ww1 -> AS.Util.$wlastN @ a ww1 w1 }) -}
e3bc589698fce36756ea1f3192876d5f
  lastN' :: GHC.Types.Int -> [a] -> [a]
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,U>,
       Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ @ a w :: GHC.Types.Int w1 :: [a] ->
                   case w of ww { GHC.Types.I# ww1 ->
                   AS.Util.$wlastN' @ a ww1 w1 }) -}
fbce149fffd92fc4e0c6c6f1c7a34929
  lastN'1 :: [a] -> [a] -> [a]
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
ac2fe6e0c1174e913be6600e01795f1a
  lookupLambda :: GHC.Classes.Eq a
                  -> (b -> a)
                  -> a
                  -> [b]
                  -> Data.Maybe.Maybe b
    {- Arity: 4, HasNoCafRefs,
       Strictness: <L,1*U(1*C1(U),A)><L,C(U)><L,U><S,1*U>,
       Unfolding: (\ @ b
                     @ a
                     $dEq :: GHC.Classes.Eq a
                     func :: b -> a
                     elm :: a
                     lst :: [b] ->
                   case GHC.List.filter
                          @ b
                          (let {
                             f :: a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq elm
                           } in
                           \ x :: b -> f (func x))
                          lst of wild {
                     [] -> Data.Maybe.Nothing @ b : x xs -> Data.Maybe.Just @ b x }) -}
e9668b25b8d40b546a91c9ff3895e26f
  lookupLambda_$slookupLambda :: (b -> AS.Types.ASSheetId)
                                 -> AS.Types.ASSheetId
                                 -> [b]
                                 -> Data.Maybe.Maybe b
    {- Arity: 3, HasNoCafRefs,
       Strictness: <L,C(U(U,U,U))><L,U(U,U,U)><S,1*U>,
       Unfolding: (\ @ b
                     func :: b -> AS.Types.ASSheetId
                     elm :: AS.Types.ASSheetId
                     lst :: [b] ->
                   case GHC.List.filter
                          @ b
                          (\ x :: b ->
                           case elm of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                           case func x of wild1 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# dt2 dt5) of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case {__pkg_ccall text-1.2.1.1 _hs_text_memcmp GHC.Prim.ByteArray#
                                                                               -> GHC.Prim.Word#
                                                                               -> GHC.Prim.ByteArray#
                                                                               -> GHC.Prim.Word#
                                                                               -> GHC.Prim.Word#
                                                                               -> GHC.Prim.State#
                                                                                      GHC.Prim.RealWorld
                                                                               -> (# GHC.Prim.State#
                                                                                         GHC.Prim.RealWorld,
                                                                                     GHC.Prim.Int# #)}
                                       dt
                                       (GHC.Prim.int2Word# dt1)
                                       dt3
                                       (GHC.Prim.int2Word# dt4)
                                       (GHC.Prim.int2Word# dt2)
                                       GHC.Prim.realWorld# of wild3 { (#,#) ds11 ds12 ->
                                case GHC.Prim.narrow32Int# ds12 of wild4 {
                                  DEFAULT -> GHC.Types.False 0 -> GHC.Types.True } } } } })
                          lst of wild {
                     [] -> Data.Maybe.Nothing @ b : x xs -> Data.Maybe.Just @ b x }) -}
bde1481a9bbfbfac6514d9b29bebffcb
  matchSheets :: [AS.Types.ASWorkbook]
                 -> [AS.Types.ASSheet]
                 -> [AS.Types.WorkbookSheet]
    {- Arity: 2, Strictness: <S,1*U><L,U>,
       Unfolding: (\ ws :: [AS.Types.ASWorkbook]
                     ss :: [AS.Types.ASSheet] ->
                   let {
                     lvl :: Data.Text.Internal.Text -> AS.Types.ASSheet {- Arity: 1 -}
                     = \ x :: Data.Text.Internal.Text ->
                       case GHC.List.filter
                              @ AS.Types.ASSheet
                              (\ x1 :: AS.Types.ASSheet ->
                               case x of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                               case x1 of wild1 { AS.Types.Sheet ds1 ds2 ds3 ->
                               case ds1 of wild2 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.==# dt2 dt5) of wild3 {
                                 GHC.Types.False -> GHC.Types.False
                                 GHC.Types.True
                                 -> case {__pkg_ccall text-1.2.1.1 _hs_text_memcmp GHC.Prim.ByteArray#
                                                                                   -> GHC.Prim.Word#
                                                                                   -> GHC.Prim.ByteArray#
                                                                                   -> GHC.Prim.Word#
                                                                                   -> GHC.Prim.Word#
                                                                                   -> GHC.Prim.State#
                                                                                          GHC.Prim.RealWorld
                                                                                   -> (# GHC.Prim.State#
                                                                                             GHC.Prim.RealWorld,
                                                                                         GHC.Prim.Int# #)}
                                           dt
                                           (GHC.Prim.int2Word# dt1)
                                           dt3
                                           (GHC.Prim.int2Word# dt4)
                                           (GHC.Prim.int2Word# dt2)
                                           GHC.Prim.realWorld# of wild4 { (#,#) ds11 ds12 ->
                                    case GHC.Prim.narrow32Int# ds12 of wild5 {
                                      DEFAULT -> GHC.Types.False 0 -> GHC.Types.True } } } } } })
                              ss of wild {
                         [] -> AS.Util.matchSheets1
                         : x1 xs
                         -> AS.Util.fromJustList1
                              @ AS.Types.ASSheet
                              (Data.Maybe.Just @ AS.Types.ASSheet x1) }
                   } in
                   letrec {
                     go1 :: [AS.Types.ASWorkbook] -> [AS.Types.WorkbookSheet]
                       {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [AS.Types.ASWorkbook] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ AS.Types.WorkbookSheet
                         : y ys
                         -> GHC.Types.:
                              @ AS.Types.WorkbookSheet
                              (AS.Types.WorkbookSheet
                                 (AS.Types.workbookName y)
                                 (case y of wild1 { AS.Types.Workbook ds1 ds2 ->
                                  GHC.Base.map
                                    @ Data.Text.Internal.Text
                                    @ AS.Types.ASSheet
                                    lvl
                                    ds2 }))
                              (go1 ys) }
                   } in
                   go1 ws) -}
8caeda53f03a8bf51044a38e948a43b0
  matchSheets1 :: AS.Types.ASSheet
    {- Unfolding: (AS.Util.fromJustList1
                     @ AS.Types.ASSheet
                     (Data.Maybe.Nothing @ AS.Types.ASSheet)) -}
92015a86409f14c5c658a26b4083fce1
  max' :: GHC.Classes.Ord a -> a -> a -> a
    {- Arity: 3, HasNoCafRefs,
       Strictness: <S(LLLLC(C(S))LLL),1*U(A,A,A,A,1*C1(C1(U)),A,A,A)><L,U><L,U>,
       Unfolding: InlineRule (3, True, False)
                  (\ @ a $dOrd :: GHC.Classes.Ord a j :: a k :: a ->
                   case GHC.Classes.> @ a $dOrd j k of wild {
                     GHC.Types.False -> k GHC.Types.True -> j }) -}
aaaff3ac6991f3fec1b8e761ddafe036
  max'_$smax' :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
       Unfolding: InlineRule (2, True, False)
                  (\ j :: GHC.Types.Int k :: GHC.Types.Int ->
                   case j of wild { GHC.Types.I# x ->
                   case k of wild1 { GHC.Types.I# y ->
                   case GHC.Prim.tagToEnum#
                          @ GHC.Types.Bool
                          (GHC.Prim.># x y) of wild2 {
                     GHC.Types.False -> wild1 GHC.Types.True -> wild } } }) -}
6854e661462a46e1a6a60b68508e1eb4
  maxBy :: GHC.Classes.Ord a -> (b -> a) -> [b] -> b
    {- Arity: 3,
       Strictness: <L,U(A,A,A,A,C(C1(U)),A,A,A)><L,C(U)><S,1*U>,
       Unfolding: (\ @ b
                     @ a
                     $dOrd :: GHC.Classes.Ord a
                     f :: b -> a
                     ds :: [b] ->
                   case ds of wild {
                     [] -> AS.Util.maxBy2 @ b
                     : x xs
                     -> let {
                          lvl :: a -> a -> GHC.Types.Bool = GHC.Classes.> @ a $dOrd
                        } in
                        letrec {
                          helper :: b -> a -> [(a, b)] -> b
                            {- Arity: 3, Strictness: <L,1*U><L,U><S,1*U> -}
                          = \ m :: b ds1 :: a ds2 :: [(a, b)] ->
                            case ds2 of wild1 {
                              [] -> m
                              : ds3 fxs
                              -> case ds3 of wild2 { (,) fx x1 ->
                                 case lvl fx ds1 of wild3 {
                                   GHC.Types.False -> helper m ds1 fxs
                                   GHC.Types.True -> helper x1 fx fxs } } }
                        } in
                        letrec {
                          go1 :: [b] -> [b] -> [(a, b)] {- Arity: 1, Strictness: <S,1*U> -}
                          = \ ds1 :: [b] ->
                            case ds1 of wild1 {
                              [] -> AS.Util.maxBy1 @ b @ a
                              : y ys
                              -> let {
                                   _x :: a = f y
                                 } in
                                 let {
                                   ys1 :: [b] -> [(a, b)] = go1 ys
                                 } in
                                 \ ds2 :: [b] ->
                                 case ds2 of wild2 {
                                   [] -> GHC.Types.[] @ (a, b)
                                   : y1 ys2 -> GHC.Types.: @ (a, b) (_x, y1) (ys1 ys2) } }
                        } in
                        helper x (f x) (go1 xs xs) }) -}
e7e1d1296c100671ccdb010637180aeb
  maxBy1 :: [b] -> [(a, b)]
    {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
       Unfolding: (\ @ b @ a ds :: [b] -> GHC.Types.[] @ (a, b)) -}
09036876d05b87d09e3e283f80c9dc5d
  maxBy2 :: b {- Strictness: b -}
0dba983e633a5ea889723da9aefc571a
  min' :: GHC.Classes.Ord a -> a -> a -> a
    {- Arity: 3, HasNoCafRefs,
       Strictness: <S(LLC(C(S))LLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,U><L,U>,
       Unfolding: InlineRule (3, True, False)
                  (\ @ a $dOrd :: GHC.Classes.Ord a j :: a k :: a ->
                   case GHC.Classes.< @ a $dOrd j k of wild {
                     GHC.Types.False -> k GHC.Types.True -> j }) -}
c09545cd356e2e0e33b0b03efb045b13
  min'_$smin' :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>m,
       Unfolding: InlineRule (2, True, False)
                  (\ j :: GHC.Types.Int k :: GHC.Types.Int ->
                   case j of wild { GHC.Types.I# x ->
                   case k of wild1 { GHC.Types.I# y ->
                   case GHC.Prim.tagToEnum#
                          @ GHC.Types.Bool
                          (GHC.Prim.<# x y) of wild2 {
                     GHC.Types.False -> wild1 GHC.Types.True -> wild } } }) -}
2c307afd2345594083bac94e1d79d3a6
  minBy :: GHC.Classes.Ord a -> (b -> a) -> [b] -> b
    {- Arity: 3,
       Strictness: <L,U(A,A,C(C1(U)),A,A,A,A,A)><L,C(U)><S,1*U>,
       Unfolding: (\ @ b
                     @ a
                     $dOrd :: GHC.Classes.Ord a
                     f :: b -> a
                     ds :: [b] ->
                   case ds of wild {
                     [] -> AS.Util.minBy1 @ b
                     : x xs
                     -> let {
                          lvl :: a -> a -> GHC.Types.Bool = GHC.Classes.< @ a $dOrd
                        } in
                        letrec {
                          helper :: b -> a -> [(a, b)] -> b
                            {- Arity: 3, Strictness: <L,1*U><L,U><S,1*U> -}
                          = \ m :: b ds1 :: a ds2 :: [(a, b)] ->
                            case ds2 of wild1 {
                              [] -> m
                              : ds3 fxs
                              -> case ds3 of wild2 { (,) fx x1 ->
                                 case lvl fx ds1 of wild3 {
                                   GHC.Types.False -> helper m ds1 fxs
                                   GHC.Types.True -> helper x1 fx fxs } } }
                        } in
                        letrec {
                          go1 :: [b] -> [b] -> [(a, b)] {- Arity: 1, Strictness: <S,1*U> -}
                          = \ ds1 :: [b] ->
                            case ds1 of wild1 {
                              [] -> AS.Util.maxBy1 @ b @ a
                              : y ys
                              -> let {
                                   _x :: a = f y
                                 } in
                                 let {
                                   ys1 :: [b] -> [(a, b)] = go1 ys
                                 } in
                                 \ ds2 :: [b] ->
                                 case ds2 of wild2 {
                                   [] -> GHC.Types.[] @ (a, b)
                                   : y1 ys2 -> GHC.Types.: @ (a, b) (_x, y1) (ys1 ys2) } }
                        } in
                        helper x (f x) (go1 xs xs) }) -}
c65464f20488f15bea864de6cbc4cee4
  minBy1 :: b {- Strictness: b -}
35cb21e1f23638a3173441d7200c130f
  printTimed :: GHC.Base.String -> GHC.Types.IO ()
    {- Arity: 2, Strictness: <L,U><L,U>,
       Unfolding: (AS.Util.printTimed1
                     `cast`
                   (<GHC.Base.String>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R))) -}
5a1bfc9100077afa8f45f77cb50628b6
  printTimed1 :: GHC.Base.String
                 -> GHC.Prim.State# GHC.Prim.RealWorld
                 -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
    {- Arity: 2, Strictness: <L,U><L,U>,
       Unfolding: (\ str :: GHC.Base.String
                     eta :: GHC.Prim.State# GHC.Prim.RealWorld ->
                   case Data.Time.Clock.POSIX.getPOSIXTime1
                          eta of ds1 { (#,#) ipv ipv1 ->
                   GHC.IO.Handle.Text.hPutStr2
                     GHC.IO.Handle.FD.stdout
                     (GHC.Types.:
                        @ GHC.Types.Char
                        AS.Util.printTimed3
                        (GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.$fShowChar1
                              (case Data.Time.Clock.POSIX.$wposixSecondsToUTCTime
                                      ipv1 of ww { (#,#) ww1 ww2 ->
                               GHC.Show.showLitString
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    (Data.Fixed.showFixed
                                       @ Data.Fixed.E12
                                       Data.Fixed.$fHasResolutionE12_$cresolution
                                         `cast`
                                       (Sym (Data.Fixed.NTCo:HasResolution[0] <Data.Fixed.E12>_N))
                                       GHC.Types.True
                                       ww2 `cast` (Data.Time.Clock.Scale.NTCo:DiffTime[0]))
                                    Data.Time.Clock.Scale.$fShowDiffTime3)
                                 AS.Util.printTimed2 }))
                           (GHC.CString.unpackAppendCString# "] "# str)))
                     GHC.Types.True
                     ipv }) -}
6416766244a1a4c7311d95996a11a0c2
  printTimed2 :: [GHC.Types.Char]
    {- HasNoCafRefs,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     GHC.Show.$fShowChar1
                     (GHC.Types.[] @ GHC.Types.Char)) -}
a8d10502782038942e9023664728fad9
  printTimed3 :: GHC.Types.Char
    {- HasNoCafRefs, Unfolding: (GHC.Types.C# '[') -}
77465655c193647f9a51f8882bab535c
  sendMessage :: AS.Types.ASMessage
                 -> Network.WebSockets.Connection.Connection
                 -> GHC.Types.IO ()
    {- Arity: 3,
       Strictness: <L,1*U(1*U,1*U,1*U,1*U)><S(SSSC(C(S))L),1*U(1*H,1*H,1*H,C1(C1(U(U,U))),A)><L,U>,
       Unfolding: InlineRule (0, True, True)
                  AS.Util.sendMessage1
                    `cast`
                  (<AS.Types.ASMessage>_R
                   ->_R <Network.WebSockets.Connection.Connection>_R
                   ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
c958297494a336e0c45ece015498bb89
  sendMessage1 :: AS.Types.ASMessage
                  -> Network.WebSockets.Connection.Connection
                  -> GHC.Prim.State# GHC.Prim.RealWorld
                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
    {- Arity: 3,
       Strictness: <L,1*U(1*U,1*U,1*U,1*U)><S(SSSC(C(S))L),1*U(1*H,1*H,1*H,C1(C1(U(U,U))),A)><L,U>,
       Inline: INLINE[0],
       Unfolding: InlineRule (3, True, False)
                  (\ w :: AS.Types.ASMessage
                     w1 :: Network.WebSockets.Connection.Connection
                     w2 :: GHC.Prim.State# GHC.Prim.RealWorld ->
                   case w1 of ww { Network.WebSockets.Connection.Connection ww1 ww2 ww3 ww4 ww5 ->
                   (ww4
                      (Network.WebSockets.Types.DataMessage
                         (Network.WebSockets.Types.Text
                            (Data.ByteString.Builder.toLazyByteString
                               (Data.Aeson.Encode.ByteString.encodeToByteStringBuilder
                                  (AS.Types.$fToJSONASMessage_$ctoJSON w))))))
                     `cast`
                   (GHC.Types.NTCo:IO[0] <()>_R)
                     w2 }) -}
c2040badac463b15eadb7d547dbdd831
  shiftLoc :: (GHC.Types.Int, GHC.Types.Int)
              -> AS.Types.ASLocation
              -> AS.Types.ASLocation
    {- Arity: 2, Strictness: <S,1*U(U(U),U(U))><S,1*U>,
       Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ w :: (GHC.Types.Int, GHC.Types.Int) w1 :: AS.Types.ASLocation ->
                   case w of ww { (,) ww1 ww2 -> AS.Util.$wshiftLoc ww1 ww2 w1 }) -}
9264f2424ccb0d85fae175e133f8ee1a
  shiftLoc1 :: AS.Types.ASLocation {- Strictness: b -}
a4f40572f7d98429b194998fe54e662c
  updateMessageUser :: AS.Types.ASUserId
                       -> AS.Types.ASMessage
                       -> AS.Types.ASMessage
    {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(A,U,U,U)>m,
       Unfolding: InlineRule (2, True, False)
                  (\ uid :: AS.Types.ASUserId ds :: AS.Types.ASMessage ->
                   case ds of wild { AS.Types.Message ds1 a r p ->
                   AS.Types.Message uid a r p }) -}
d5d0ed20133a00f072c0d43e9a6ce529
  updateWindow :: AS.Types.ASWindow
                  -> AS.Types.ASUser
                  -> AS.Types.ASUser
    {- Arity: 2, HasNoCafRefs,
       Strictness: <L,U(U(U,U,U),U,U)><S,1*U(U,U,1*U)>m,
       Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ w :: AS.Types.ASWindow w1 :: AS.Types.ASUser ->
                   case w1 of ww { AS.Types.UserClient ww1 ww2 ww3 ->
                   case AS.Util.$wupdateWindow
                          w
                          ww1
                          ww2
                          ww3 of ww4 { (#,,#) ww5 ww6 ww7 ->
                   AS.Types.UserClient ww5 ww6 ww7 } }) -}
"SPEC AS.Util.lookupLambda [AS.Types.ASSheetId]" [ALWAYS] forall @ b
                                                                 $dEq :: GHC.Classes.Eq
                                                                             AS.Types.ASSheetId
  AS.Util.lookupLambda @ b @ Data.Text.Internal.Text $dEq
  = AS.Util.lookupLambda_$slookupLambda @ b
"SPEC AS.Util.max' [GHC.Types.Int]" [ALWAYS] forall $dOrd :: GHC.Classes.Ord
                                                                 GHC.Types.Int
  AS.Util.max' @ GHC.Types.Int $dOrd = AS.Util.max'_$smax'
"SPEC AS.Util.min' [GHC.Types.Int]" [ALWAYS] forall $dOrd :: GHC.Classes.Ord
                                                                 GHC.Types.Int
  AS.Util.min' @ GHC.Types.Int $dOrd = AS.Util.min'_$smin'
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

