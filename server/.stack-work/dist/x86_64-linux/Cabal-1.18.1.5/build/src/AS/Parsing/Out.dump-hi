
==================== FINAL INTERFACE ====================
2015-09-25 00:27:14.980497 UTC

interface alphasheets-0.1.0.0:AS.Parsing.Out 7084
  interface hash: 432c719cb2ce16b295addb62dc2e483e
  ABI hash: dd270cee574919ef59c3b5c824275231
  export-list hash: b4cc2ee9878e9c201d4134316c957a72
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 01dbfe2a4bc4387a8d0369737a5dc5cb
  used TH splices: False
  where
exports:
  AS.Parsing.Out.bool
  AS.Parsing.Out.colStrToInt
  AS.Parsing.Out.colon
  AS.Parsing.Out.dependenciesFromExceLLoc
  AS.Parsing.Out.dollar
  AS.Parsing.Out.exLocToASLocation
  AS.Parsing.Out.exLocToString
  AS.Parsing.Out.exc
  AS.Parsing.Out.excelMatch
  AS.Parsing.Out.getBlockDelim
  AS.Parsing.Out.getDependencies
  AS.Parsing.Out.getDependenciesAndExpressions
  AS.Parsing.Out.getInlineDelim
  AS.Parsing.Out.getMatchesWithContext
  AS.Parsing.Out.indexMatch
  AS.Parsing.Out.indexToExcel
  AS.Parsing.Out.intToColStr
  AS.Parsing.Out.jsonDeserialize
  AS.Parsing.Out.modifiedLists
  AS.Parsing.Out.parseMatches
  AS.Parsing.Out.parseMatchesWithContext
  AS.Parsing.Out.parseNext
  AS.Parsing.Out.rangeMatch
  AS.Parsing.Out.replaceMatches
  AS.Parsing.Out.sheetMatch
  AS.Parsing.Out.sheetRefMatch
  AS.Parsing.Out.shiftCell
  AS.Parsing.Out.shiftExLoc
  AS.Parsing.Out.shiftExLocs
  AS.Parsing.Out.showFilteredValue
  AS.Parsing.Out.showValue
  AS.Parsing.Out.toListStr
  AS.Parsing.Out.unpackExcelExprs
  AS.Parsing.Out.unpackExcelLocs
  AS.Parsing.Out.unpackExcelVals
module dependencies: AS.Parsing.Common AS.Types AS.Util
package dependencies: BoundedChan-1.0.3.0 SHA-1.6.4.2 aeson-0.8.1.1
                      array-0.5.0.0 attoparsec-0.13.0.1 base base64-bytestring-1.0.0.1
                      binary-0.7.1.0 blaze-builder-0.4.0.1 bytestring-0.10.4.0
                      bytestring-lexing-0.5.0.2 case-insensitive-1.2.0.4
                      containers-0.5.5.1 deepseq-1.3.0.2 dlist-0.7.1.1 entropy-0.3.7
                      ghc-prim hashable-1.2.3.3 hedis-0.6.9 integer-gmp
                      monad-control-1.0.0.4 mtl-2.2.1 network-2.6.2.1 parsec-3.1.9
                      primitive-0.6 random-1.1 regex-base-0.93.2 regex-posix-0.95.2
                      resource-pool-0.2.3.2 scientific-0.3.3.8 stm-2.4.4 text-1.2.1.1
                      time-1.5.0.1 transformers-0.4.3.0 transformers-base-0.4.4
                      unix-2.7.1.0 unordered-containers-0.2.5.1 uuid-1.3.10
                      uuid-types-1.0.1 vector-0.11.0.0 websockets-0.9.5.0
orphans: aeson-0.8.1.1:Data.Aeson.Types.Generic
         aeson-0.8.1.1:Data.Aeson.Types.Instances
         aeson-0.8.1.1:Data.Aeson.Types.Internal
         attoparsec-0.13.0.1:Data.Attoparsec.ByteString.Char8 base:GHC.Base
         base:GHC.Float base:GHC.Real binary-0.7.1.0:Data.Binary.Generic
         bytestring-0.10.4.0:Data.ByteString.Builder
         bytestring-lexing-0.5.0.2:Data.ByteString.Lex.Fractional
         hashable-1.2.3.3:Data.Hashable.Generic
         network-2.6.2.1:Network.Socket network-2.6.2.1:Network.Socket.Types
         random-1.1:System.Random regex-base-0.93.2:Text.Regex.Base.Context
         regex-posix-0.95.2:Text.Regex.Posix.ByteString
         regex-posix-0.95.2:Text.Regex.Posix.ByteString.Lazy
         regex-posix-0.95.2:Text.Regex.Posix.Sequence
         regex-posix-0.95.2:Text.Regex.Posix.String
         resource-pool-0.2.3.2:Data.Pool stm-2.4.4:Control.Monad.STM
         text-1.2.1.1:Data.Text text-1.2.1.1:Data.Text.Lazy
         text-1.2.1.1:Data.Text.Show
         time-1.5.0.1:Data.Time.Calendar.Gregorian
         time-1.5.0.1:Data.Time.Format.Parse
         time-1.5.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.4.3.0:Control.Monad.Trans.Error
         vector-0.11.0.0:Data.Vector.Fusion.Bundle
         vector-0.11.0.0:Data.Vector.Unboxed
family instance modules: alphasheets-0.1.0.0:AS.Types
                         attoparsec-0.13.0.1:Data.Attoparsec.Internal.Types
                         base:Control.Applicative base:Data.Either base:Data.Monoid
                         base:Data.Type.Equality base:GHC.Exts base:GHC.Generics
                         dlist-0.7.1.1:Data.DList
                         monad-control-1.0.0.4:Control.Monad.Trans.Control
                         primitive-0.6:Control.Monad.Primitive text-1.2.1.1:Data.Text
                         text-1.2.1.1:Data.Text.Lazy
                         unordered-containers-0.2.5.1:Data.HashMap.Base
                         unordered-containers-0.2.5.1:Data.HashSet
                         uuid-types-1.0.1:Data.UUID.Types.Internal
                         uuid-types-1.0.1:Data.UUID.Types.Internal.Builder
                         vector-0.11.0.0:Data.Vector vector-0.11.0.0:Data.Vector.Primitive
                         vector-0.11.0.0:Data.Vector.Storable
                         vector-0.11.0.0:Data.Vector.Unboxed
                         vector-0.11.0.0:Data.Vector.Unboxed.Base
import  -/  AS.Parsing.Common ceccfbae6a55ecc56f531616855b9b06
  exports: b53f07d91299e788b6ffa7cfbc3e8f8f
  normalizeRanges ea8463b15018b62a4936eafd37fe728a
import  -/  AS.Types ac0aeb8d2661160e6345f7fec8fc36e5
  exports: 4f33e2305e9f32540a30fe3603c0662c
  ASCell bede131762bf9e6165d28069305c9a8f
  ASExpression 64e605941635d5560dadb6b522a83662
  ASLanguage 37e5d158f6c905c972eb637f34e85db0
  ASLocation 42b88bd590b6186a8f42af5a0deb461a
  ASSheetId 4ed60fa4a266e9c370748b465970547f
  ASValue cf27945d6d550d5b2c4aa963af53bf25
  CPP b4a4c8f2505bf40c7d27cb4849687ddb
  Cell cf2ab8ae076f48bff57c162753f8fec8
  DisplayValue ce250046d7949b0ca02603fc44d9997a
  ExIndex c644aff9dc1dd85cd0a6260013b62c27
  ExLoc 1c738b5e9aed6a29a4156821b6a9e600
  ExRange c018d6a00a4a950589a526f02a04b63c
  ExSheet 2bda8322c0e7ea676abc7bbdede41aa3
  Excel 42d5319c0fb1ce752e5a0b3af0288451
  Expression f785db95121a6dab5f264f3d6c185f9b
  Index 32bc2c9c50c80ae6c93286c30ef7b208
  Java 8a2cf7ad3bb81f17585e28b4cccb5ba5
  OCaml 5b3b1ae20cfc4a6a1a4504a2b84e1b52
  ObjectValue df3e29fa59901f3e6e95cdff71d390ad
  Python ac7cdaae311730879724e4fbfab50a2b
  R 92cf8dcce290a7851ccef94628c17c64
  Range 1619818a9064827107fb6d04d8e72cf3
  Reference 07c3f14712d76d5812c8dbd70307f517
  SQL e4a5a897edfd83a9739604cfeb3dd472
  StyledValue 8d5a8eb26499897b4a9cf45699e34d75
  ValueB 33f610e15cbd5e9e087c42aecc2e4701
  ValueD e6e64d8e632dd1b9cb2ee51767927a07
  ValueI c681921b682c1f0b6fe327e999fff2ff
  ValueL 3869c969a355ac446978790d8e12a1f0
  ValueNaN 9e0f3faeba6e71df041fdc817c723f2a
  ValueS 97f070b8b9566616b532060fcfb55d89
  col 3989ab87b522626088fd9c93f21275d6
  dbl dbcaed1994de8e2c4e1eb9cbcc74cfea
  expression 6ea1c8a95a3119194a24a1b062d4f02c
  index cd41ef71099779885fc52a84e2e3be05
  language 96d4cc4ee6772e20c09c6cc6a5feae9a
  locSheetId 0eb45f0ce468cda62d570bcb8b46f9d1
  lst 6888a75abf96ee61d5f94e9dfa1944df
  row 3b28ea2638c6faaf0da7f6669c872531
  str 80baf2033a55f7bb10a3954c4c5024cd
import  -/  AS.Util 417e4f2db7aca39e7f1871a4d7aab2a3
  exports: 061da0521eb01812fd74bf75a38cb988
  decomposeLocs 029ee6d579cad48c88473e01acb70f98
  shiftLoc c2040badac463b15eadb7d547dbdd831
import  -/  base:Control.Applicative 30b769206cb5c020684e1bda0d7e7dd3
import  -/  base:Data.Char 1ace810ea04187cd227c9ed982bb7d15
import  -/  base:Data.Either d1c890129a7c6a9ec02a642c6c2f4ed3
import  -/  base:Data.List 8b77870d02d66076337587b759b7ee19
import  -/  base:Data.Maybe 5034d40e23c3a7110309f188001df4ca
import  -/  base:Data.Tuple cac4e06c48274e85317bd3e59867ef5b
import  -/  base:GHC.Base 5d7c5f596f9a4c8a8abd8517c8bcd5dd
import  -/  base:GHC.List 4cff382327e59a5787355ca0a4174450
import  -/  base:GHC.Num 5e7786970581cacc802bf850d458a30b
import  -/  base:GHC.Real 35345ccdfd774068d1f4418df87bd3c9
import  -/  base:GHC.Show cf1a7ff9edb0f41528085aad04d33753
import  -/  base:GHC.Unicode 328b8e1d86fa0b0f8b798c018561e9b0
import  -/  base:Prelude 74043f272d60acec1777d3461cfe5ef4
import  -/  base:Text.Read 6fe10a0a6d0a38c215de3b09e72ca556
import  -/  containers-0.5.5.1:Data.Map 39e9346954b9366e01d2c8afb617e216
import  -/  ghc-prim:GHC.Classes 3e6cbe1e7e80480408cfa8d5450726a0
import  -/  parsec-3.1.9:Text.Parsec 322f8fcdba25896960b8a72a57a6cc03
import  -/  parsec-3.1.9:Text.Parsec.Char 6856e7d60152a7853042a5131cb18a7e
import  -/  parsec-3.1.9:Text.Parsec.Combinator 8858326309ca87865b6d05ec2ac7042b
import  -/  parsec-3.1.9:Text.Parsec.Prim 83ec7b521fb5d9e360c8d0b0f45a255c
import  -/  parsec-3.1.9:Text.Parsec.Text cf960375745df33bb92b7c1e8c170e40
import  -/  regex-posix-0.95.2:Text.Regex.Posix ac2bb8a4caf67648cfb9326fa3deedd9
import  -/  text-1.2.1.1:Data.Text ddf865ef7152d1de0d03707558cc6523
import  -/  text-1.2.1.1:Data.Text.Lazy d1de7a4c761fe4714bb721abdba23755
f5d0b7dce27cbef47c010cca31209e51
  $wa :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
         -> (AS.Types.ExLoc
             -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
             -> Text.Parsec.Error.ParseError
             -> Data.Functor.Identity.Identity b)
         -> (AS.Types.ExLoc
             -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
             -> Text.Parsec.Error.ParseError
             -> Data.Functor.Identity.Identity b)
         -> (Text.Parsec.Error.ParseError
             -> Data.Functor.Identity.Identity b)
         -> Data.Functor.Identity.Identity b
    {- Arity: 4,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(C1(C1(U)))><L,C(U)> -}
2ac39dd920f09534530f6b66fef3875d
  $wa1 :: Text.Parsec.Text.Parser t
          -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
             -> ([t]
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> (Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> ([t]
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))>,
       Unfolding: (\ @ t
                     w :: Text.Parsec.Text.Parser t
                     @ b
                     w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     w2 :: [t]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w4 :: [t]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                   Text.Parsec.Prim.$wa10
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     @ t
                     (\ @ b1
                        s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        cok :: t
                               -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1
                        cerr :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b1
                        eok :: t
                               -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1
                        eerr :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b1 ->
                      AS.Parsing.Out.getMatchesWithContext7
                        @ t
                        w
                        @ b1
                        s1
                        (\ x :: (GHC.Base.String, t)
                           s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err :: Text.Parsec.Error.ParseError ->
                         case x of wild { (,) inter next ->
                         cok
                           next
                           s2
                           (case s2 of wild1 { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                            case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                            case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                            case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                            case Text.Parsec.Error.$wmergeError
                                   ww4
                                   ww5
                                   ww6
                                   ww2
                                   ww11
                                   ww12
                                   ww13
                                   (GHC.Types.[]
                                      @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                            Text.Parsec.Error.ParseError ww15 ww16 } } } } }) })
                        eerr
                        (\ x :: (GHC.Base.String, t)
                           s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err :: Text.Parsec.Error.ParseError ->
                         case x of wild { (,) inter next ->
                         eok
                           next
                           s2
                           (case s2 of wild1 { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                            case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                            case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                            case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                            case Text.Parsec.Error.$wmergeError
                                   ww4
                                   ww5
                                   ww6
                                   ww2
                                   ww11
                                   ww12
                                   ww13
                                   (GHC.Types.[]
                                      @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                            Text.Parsec.Error.ParseError ww15 ww16 } } } } }) })
                        eerr)
                       `cast`
                     (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                               <Data.Text.Internal.Text>_R
                               <()>_R
                               <Data.Functor.Identity.Identity>_R
                               <t>_R))
                     @ b
                     w1
                     w2
                     w3
                     w4) -}
b9c07856579a272c0161460a05e97a4f
  $wa2 :: GHC.Prim.ByteArray#
          -> GHC.Prim.Int#
          -> GHC.Prim.Int#
          -> Text.Parsec.Pos.SourceName
          -> GHC.Prim.Int#
          -> GHC.Prim.Int#
          -> ()
          -> (GHC.Types.Char
              -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
              -> Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (GHC.Types.Char
              -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
              -> Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> Data.Functor.Identity.Identity b
    {- Arity: 11,
       Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,C(C1(C1(U)))><L,C(U)> -}
dbd22b2d95f63261aa2c29684e214746
  $wcolStrToInt :: GHC.Base.String -> GHC.Prim.Int#
    {- Arity: 1, Strictness: <S,1*U> -}
d4745084cb8806e1904aca8725bdd367
  $wgetDependenciesAndExpressions :: AS.Types.ASSheetId
                                     -> AS.Types.ASExpression
                                     -> [(GHC.Types.Int, GHC.Types.Int)]
                                     -> (# [[AS.Types.ASLocation]], [AS.Types.ASExpression] #)
    {- Arity: 3, Strictness: <L,U><L,U><L,U>,
       Unfolding: (\ w :: AS.Types.ASSheetId
                     w1 :: AS.Types.ASExpression
                     w2 :: [(GHC.Types.Int, GHC.Types.Int)] ->
                   let {
                     ds :: ([GHC.Base.String], [AS.Types.ExLoc])
                     = AS.Parsing.Out.getMatchesWithContext
                         @ AS.Types.ExLoc
                         (case w1 of wild {
                            AS.Types.Expression ds1 ds2 -> ds1
                            AS.Types.Reference ipv3 ipv4 -> AS.Types.expression1 })
                         AS.Parsing.Out.excelMatch1
                           `cast`
                         (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                   <Data.Text.Internal.Text>_R
                                   <()>_R
                                   <Data.Functor.Identity.Identity>_R
                                   <AS.Types.ExLoc>_R))
                   } in
                   let {
                     exLocs :: [AS.Types.ExLoc]
                     = case ds of wild { (,) inter exLocs1 -> exLocs1 }
                   } in
                   (# AS.Parsing.Out.getDependencies w exLocs w2,
                      let {
                        inter :: [GHC.Base.String]
                        = case ds of wild { (,) inter1 exLocs1 -> inter1 }
                      } in
                      let {
                        lvl23 :: AS.Types.ASLanguage
                        = case w1 of wild {
                            AS.Types.Expression ds1 ds2 -> ds2
                            AS.Types.Reference ipv3 ipv4 -> AS.Types.language1 }
                      } in
                      letrec {
                        go :: [(GHC.Types.Int, GHC.Types.Int)] -> [AS.Types.ASExpression]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ ds1 :: [(GHC.Types.Int, GHC.Types.Int)] ->
                          case ds1 of wild {
                            [] -> GHC.Types.[] @ AS.Types.ASExpression
                            : y ys
                            -> GHC.Types.:
                                 @ AS.Types.ASExpression
                                 (AS.Types.Expression
                                    (AS.Parsing.Out.getDependenciesAndExpressions_blend
                                       inter
                                       (GHC.Base.map
                                          @ AS.Types.ExLoc
                                          @ [GHC.Types.Char]
                                          (\ x :: AS.Types.ExLoc ->
                                           AS.Parsing.Out.exLocToString
                                             (AS.Parsing.Out.shiftExLoc y x))
                                          exLocs))
                                    lvl23)
                                 (go ys) }
                      } in
                      go w2 #)) -}
ee3203749b87bf4fcc66c3d67277c5d5
  $windexToExcel :: GHC.Prim.Int# -> GHC.Types.Int -> GHC.Base.String
    {- Arity: 2, Strictness: <L,U><L,1*U(U)>,
       Unfolding: (\ ww :: GHC.Prim.Int# ww1 :: GHC.Types.Int ->
                   GHC.Base.++
                     @ GHC.Types.Char
                     (AS.Parsing.Out.$wintToColStr ww)
                     (case ww1 of ww2 { GHC.Types.I# ww3 ->
                      case GHC.Show.$wshowSignedInt
                             0
                             ww3
                             (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                      GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
9efddfc9822fd455baeb4418233d4a01
  $wintToColStr :: GHC.Prim.Int# -> [GHC.Types.Char]
    {- Arity: 1, Strictness: <L,U> -}
abbe78ed062ef82d6355afbc4cb3d791
  $wlvl :: AS.Types.ASValue -> (# GHC.Types.Int, GHC.Types.Int #)
    {- Arity: 1, Strictness: <L,1*U>,
       Unfolding: (\ w :: AS.Types.ASValue ->
                   let {
                     ints :: [GHC.Types.Int]
                     = case w of wild {
                         DEFAULT
                         -> GHC.Types.:
                              @ GHC.Types.Int
                              (case wild of wild1 {
                                 DEFAULT -> case AS.Types.dbl1 ret_ty GHC.Types.Int of {}
                                 AS.Types.ValueD d
                                 -> case d of wild2 { GHC.Types.D# x ->
                                    let {
                                      n :: GHC.Prim.Int# = GHC.Prim.double2Int# x
                                    } in
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.<## x (GHC.Prim.int2Double# n)) of wild3 {
                                      GHC.Types.False -> GHC.Types.I# n
                                      GHC.Types.True -> GHC.Types.I# (GHC.Prim.-# n 1) } } })
                              (GHC.Types.[] @ GHC.Types.Int)
                         AS.Types.ValueL l
                         -> GHC.Base.map
                              @ AS.Types.ASValue
                              @ GHC.Types.Int
                              AS.Parsing.Out.unpackExcelLocs2
                              l }
                   } in
                   (# GHC.List.!!_sub @ GHC.Types.Int ints 0,
                      GHC.List.!!_sub @ GHC.Types.Int ints 1 #)) -}
b5cc44aa09372ffe0d03e9ebbaa17a69
  $wshiftCell :: (GHC.Types.Int, GHC.Types.Int)
                 -> AS.Types.ASLocation
                 -> AS.Types.ASExpression
                 -> AS.Types.ASValue
                 -> [AS.Types.ASCellTag]
                 -> (# AS.Types.ASCell, [AS.Types.ASLocation] #)
    {- Arity: 5, Strictness: <L,U(U(U),U(U))><L,U><S,1*U><L,U><L,U>,
       Unfolding: (\ w :: (GHC.Types.Int, GHC.Types.Int)
                     ww :: AS.Types.ASLocation
                     ww1 :: AS.Types.ASExpression
                     ww2 :: AS.Types.ASValue
                     ww3 :: [AS.Types.ASCellTag] ->
                   case ww1 of wild {
                     AS.Types.Expression str lang
                     -> let {
                          ds :: ([GHC.Base.String], [AS.Types.ExLoc])
                          = AS.Parsing.Out.getMatchesWithContext
                              @ AS.Types.ExLoc
                              str
                              AS.Parsing.Out.excelMatch1
                                `cast`
                              (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                        <Data.Text.Internal.Text>_R
                                        <()>_R
                                        <Data.Functor.Identity.Identity>_R
                                        <AS.Types.ExLoc>_R))
                        } in
                        let {
                          shiftedExLocs :: [AS.Types.ExLoc]
                          = case ds of wild1 { (,) inter exLocs ->
                            GHC.Base.map
                              @ AS.Types.ExLoc
                              @ AS.Types.ExLoc
                              (AS.Parsing.Out.shiftExLoc w)
                              exLocs }
                        } in
                        (# AS.Types.Cell
                             (AS.Util.shiftLoc w ww)
                             (AS.Types.Expression
                                (case ds of wild1 { (,) inter exLocs ->
                                 AS.Parsing.Out.getDependenciesAndExpressions_blend
                                   inter
                                   (GHC.Base.map
                                      @ AS.Types.ExLoc
                                      @ [GHC.Types.Char]
                                      AS.Parsing.Out.exLocToString
                                      shiftedExLocs) })
                                lang)
                             ww2
                             ww3,
                           AS.Parsing.Out.shiftCell_go
                             (AS.Parsing.Out.getDependencies
                                (case ww of wild1 {
                                   AS.Types.Index ds1 ds2 -> ds1
                                   AS.Types.Range ds1 ds2 -> ds1
                                   AS.Types.Column ds1 ds2 -> ds1 })
                                shiftedExLocs
                                AS.Parsing.Out.shiftCell1) #)
                     AS.Types.Reference ds ds1
                     -> (# AS.Types.Cell
                             (AS.Util.shiftLoc w ww)
                             (AS.Types.Expression
                                (AS.Parsing.Out.showValue AS.Types.Python ww2)
                                AS.Types.Python)
                             ww2
                             ww3,
                           GHC.Types.[] @ AS.Types.ASLocation #) }) -}
dafb8cb5b2192955c8420960857e0af2
  bool :: AS.Types.ASLanguage -> GHC.Base.String -> GHC.Base.String
    {- Arity: 2, Strictness: <S,1*U><L,U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage str :: GHC.Base.String ->
                   case lang of wild {
                     DEFAULT
                     -> GHC.Types.:
                          @ GHC.Types.Char
                          (case str of wild1 {
                             [] -> case GHC.List.badHead ret_ty GHC.Types.Char of {}
                             : x ds1 -> GHC.Unicode.toLower x })
                          (case str of wild1 {
                             [] -> GHC.List.tail1 @ GHC.Types.Char : ds1 xs -> xs })
                     AS.Types.Python -> str
                     AS.Types.SQL -> str
                     AS.Types.Excel -> str }) -}
07e93e2061568c140fcc9a486b1d0dfb
  colStrToInt :: GHC.Base.String -> GHC.Types.Int
    {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: GHC.Base.String ->
                   case AS.Parsing.Out.$wcolStrToInt w of ww { DEFAULT ->
                   GHC.Types.I# ww }) -}
351bd0f9100d2535d161a64c31774a2b
  colon :: Text.Parsec.Text.Parser GHC.Base.String
    {- Unfolding: (AS.Parsing.Out.colon1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))) -}
f5d763726f73f9b2e74841ca8e2ce6fe
  colon1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
            -> ([GHC.Types.Char]
                -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                -> Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> (Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> ([GHC.Types.Char]
                -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                -> Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> (Text.Parsec.Error.ParseError
                -> Data.Functor.Identity.Identity b)
            -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Unfolding: (Text.Parsec.Char.string1
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     AS.Parsing.Out.colon4
                     AS.Parsing.Out.colon2) -}
0912b7a0d871bf9940e8b3c115a09ed6
  colon2 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.colon3
                     (GHC.Types.[] @ GHC.Types.Char)) -}
f0f0d015eabec6bc083a203ca36f959f
  colon3 :: GHC.Types.Char
    {- HasNoCafRefs, Unfolding: (GHC.Types.C# ':') -}
56bb4f059541d41d16695dc8ada6ee37
  colon4 :: Text.Parsec.Prim.Stream
                Data.Text.Internal.Text
                Data.Functor.Identity.Identity
                GHC.Types.Char
    {- Unfolding: (Text.Parsec.Prim.$fStreamTextmChar0
                     @ Data.Functor.Identity.Identity
                     Data.Functor.Identity.$fMonadIdentity) -}
b6cc75e3e096cc4acfebf01d4e021f42
  dependenciesFromExceLLoc :: AS.Types.ASSheetId
                              -> AS.Types.ExLoc
                              -> [AS.Types.ASLocation]
    {- Arity: 2, Strictness: <L,U><S,1*U> -}
c66ec198c15cc11bec7a15756482b05c
  dollar :: Text.Parsec.Text.Parser GHC.Base.String
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.dollar1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.String>_R))) -}
dbb2c6772b164b9dce7ab4380355fd6d
  dollar1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
             -> (GHC.Base.String
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> (Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> (GHC.Base.String
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> (Text.Parsec.Error.ParseError
                 -> Data.Functor.Identity.Identity b)
             -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,C(U)><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (\ @ b
                     s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     cok :: GHC.Base.String
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b
                     cerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eok :: GHC.Base.String
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b
                     eerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b ->
                   Text.Parsec.Char.string1
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     AS.Parsing.Out.colon4
                     AS.Parsing.Out.dollar2
                     @ b
                     s1
                     cok
                     cerr
                     eok
                     (\ err :: Text.Parsec.Error.ParseError ->
                      Text.Parsec.Char.string1
                        @ Data.Text.Internal.Text
                        @ ()
                        @ Data.Functor.Identity.Identity
                        AS.Parsing.Out.colon4
                        (GHC.Types.[] @ GHC.Types.Char)
                        @ b
                        s1
                        cok
                        cerr
                        (\ y :: GHC.Base.String
                           s' :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eok y s' (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eerr (Text.Parsec.Error.mergeError err err')))) -}
d27047bd88325757e9abfd143fd812c3
  dollar2 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.dollar3
                     (GHC.Types.[] @ GHC.Types.Char)) -}
07effcffb4fdae316a5cf2e07b09c560
  dollar3 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '$') -}
31e174c69836028e375c5dade213c1d6
  exLocToASLocation :: AS.Types.ASSheetId
                       -> AS.Types.ExLoc
                       -> AS.Types.ASLocation
    {- Arity: 2, Strictness: <L,U><S,1*U> -}
03bd8ad92542c75a26c7b5b0234a8652
  exLocToString :: AS.Types.ExLoc -> GHC.Base.String
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
34f6687ebeb11ed5c1709ac7800a1841
  exc :: Text.Parsec.Text.Parser GHC.Base.String
    {- Unfolding: (AS.Parsing.Out.exc1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))) -}
ced30c3ed072f5f5826134d81d903e8b
  exc1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
          -> ([GHC.Types.Char]
              -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
              -> Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> ([GHC.Types.Char]
              -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
              -> Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> (Text.Parsec.Error.ParseError
              -> Data.Functor.Identity.Identity b)
          -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Unfolding: (Text.Parsec.Char.string1
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     AS.Parsing.Out.colon4
                     AS.Parsing.Out.exc2) -}
a3ce1f58c63d7a1745a7da6833e3daa7
  exc2 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.exc3
                     (GHC.Types.[] @ GHC.Types.Char)) -}
51867d1380a2f5cb48734518dbf3a8a0
  exc3 :: GHC.Types.Char
    {- HasNoCafRefs, Unfolding: (GHC.Types.C# '!') -}
9b9ec9f71fb465c6567bd9be87fbfd23
  excelMatch :: Text.Parsec.Text.Parser AS.Types.ExLoc
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: InlineRule (0, True, True)
                  AS.Parsing.Out.excelMatch1
                    `cast`
                  (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                            <Data.Text.Internal.Text>_R
                            <()>_R
                            <Data.Functor.Identity.Identity>_R
                            <AS.Types.ExLoc>_R)) -}
218b240cc4176c4b7102fa2ddb0677d6
  excelMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,A><L,C(C1(C1(U)))><L,C(U)>,
       Inline: INLINE[0],
       Unfolding: InlineRule (5, True, True)
                  (\ @ b
                     w :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     w1 :: AS.Types.ExLoc
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w3 :: AS.Types.ExLoc
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                   AS.Parsing.Out.$wa @ b w w1 w3 w4) -}
99460ec4bb5c3904f438bbb01854e375
  getBlockDelim :: AS.Types.ASLanguage -> GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage ->
                   case lang of wild {
                     DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                     AS.Types.OCaml -> AS.Parsing.Out.getBlockDelim1 }) -}
d3852025989d192bacb058f382031f8e
  getBlockDelim1 :: [GHC.Types.Char]
    {- Unfolding: (GHC.CString.unpackCString# ";;"#) -}
bd407baacc7e9cb712c6a65739fd19c6
  getDependencies :: AS.Types.ASSheetId
                     -> [AS.Types.ExLoc]
                     -> [(GHC.Types.Int, GHC.Types.Int)]
                     -> [[AS.Types.ASLocation]]
    {- Arity: 3, Strictness: <L,U><L,U><S,1*U>,
       Unfolding: (\ sheetid :: AS.Types.ASSheetId
                     matches :: [AS.Types.ExLoc]
                     offsets :: [(GHC.Types.Int, GHC.Types.Int)] ->
                   letrec {
                     go :: [(GHC.Types.Int, GHC.Types.Int)] -> [[AS.Types.ASLocation]]
                       {- Arity: 1, Strictness: <S,1*U> -}
                     = \ ds :: [(GHC.Types.Int, GHC.Types.Int)] ->
                       case ds of wild {
                         [] -> GHC.Types.[] @ [AS.Types.ASLocation]
                         : y ys
                         -> GHC.Types.:
                              @ [AS.Types.ASLocation]
                              (letrec {
                                 go1 :: [AS.Types.ExLoc] -> [AS.Types.ASLocation]
                                   {- Arity: 1, Strictness: <S,1*U> -}
                                 = \ ds1 :: [AS.Types.ExLoc] ->
                                   case ds1 of wild1 {
                                     [] -> GHC.Types.[] @ AS.Types.ASLocation
                                     : y1 ys1
                                     -> GHC.Base.++
                                          @ AS.Types.ASLocation
                                          (AS.Parsing.Out.dependenciesFromExceLLoc
                                             sheetid
                                             (AS.Parsing.Out.shiftExLoc y y1))
                                          (go1 ys1) }
                               } in
                               AS.Parsing.Common.normalizeRanges_go (go1 matches))
                              (go ys) }
                   } in
                   go offsets) -}
3761b931ab014e1e7065360543d7d2a1
  getDependenciesAndExpressions :: AS.Types.ASSheetId
                                   -> AS.Types.ASExpression
                                   -> [(GHC.Types.Int, GHC.Types.Int)]
                                   -> ([[AS.Types.ASLocation]], [AS.Types.ASExpression])
    {- Arity: 3, Strictness: <L,U><L,U><L,U>m, Inline: INLINE[0],
       Unfolding: InlineRule (3, True, False)
                  (\ w :: AS.Types.ASSheetId
                     w1 :: AS.Types.ASExpression
                     w2 :: [(GHC.Types.Int, GHC.Types.Int)] ->
                   case AS.Parsing.Out.$wgetDependenciesAndExpressions
                          w
                          w1
                          w2 of ww { (#,#) ww1 ww2 ->
                   (ww1, ww2) }) -}
2e2f50b54343b30dc3ba92309afaee49
  getDependenciesAndExpressions_blend :: [[GHC.Types.Char]]
                                         -> [[GHC.Types.Char]]
                                         -> [GHC.Types.Char]
    {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
e99d28e9ee60e9c277dec9de78688056
  getInlineDelim :: AS.Types.ASLanguage -> GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage ->
                   case lang of wild {
                     DEFAULT -> AS.Parsing.Out.getInlineDelim1
                     AS.Types.OCaml -> AS.Parsing.Out.getBlockDelim1 }) -}
9afbc91216ad78d5e8c780c299d3059d
  getInlineDelim1 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.getInlineDelim2
                     (GHC.Types.[] @ GHC.Types.Char)) -}
3217b70f2b2f3d466ffcb7a8d9b5b28b
  getInlineDelim2 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ';') -}
577784235c207381cf34d48eb7d1e701
  getMatchesWithContext :: GHC.Base.String
                           -> Text.Parsec.Text.Parser t
                           -> ([GHC.Base.String], [t])
    {- Arity: 2,
       Strictness: <L,1*U><C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))>,
       Unfolding: (\ @ t
                     target :: GHC.Base.String
                     p :: Text.Parsec.Text.Parser t ->
                   case (Text.Parsec.Prim.runParsecT
                           @ Data.Text.Internal.Text
                           @ ()
                           @ Data.Functor.Identity.Identity
                           @ ([GHC.Base.String], [t])
                           AS.Parsing.Out.getMatchesWithContext8
                           (AS.Parsing.Out.getMatchesWithContext5 @ t p)
                             `cast`
                           (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                     <Data.Text.Internal.Text>_R
                                     <()>_R
                                     <Data.Functor.Identity.Identity>_R
                                     <([GHC.Base.String], [t])>_R))
                           (Text.Parsec.Prim.State
                              @ Data.Text.Internal.Text
                              @ ()
                              (case target of dt { DEFAULT ->
                               GHC.ST.runSTRep
                                 @ Data.Text.Internal.Text
                                 (\ @ s1 s2 :: GHC.Prim.State# s1 ->
                                  case GHC.Prim.newByteArray# @ s1 8 s2 of ds1 { (#,#) ipv ipv1 ->
                                  AS.Parsing.Out.getMatchesWithContext4
                                    @ s1
                                    (Data.Text.Array.MArray @ s1 ipv1)
                                    AS.Parsing.Out.getMatchesWithContext3
                                    dt
                                    0
                                    ipv }) })
                              AS.Parsing.Out.getMatchesWithContext2
                              GHC.Tuple.()))
                          `cast`
                        (Data.Functor.Identity.NTCo:Identity[0]
                             <Text.Parsec.Prim.Consumed
                                  (Data.Functor.Identity.Identity
                                       (Text.Parsec.Prim.Reply
                                            Data.Text.Internal.Text
                                            ()
                                            ([GHC.Base.String], [t])))>_R) of wild {
                     Text.Parsec.Prim.Consumed r
                     -> case r `cast`
                             (Data.Functor.Identity.NTCo:Identity[0]
                                  <Text.Parsec.Prim.Reply
                                       Data.Text.Internal.Text
                                       ()
                                       ([GHC.Base.String], [t])>_R) of wild1 {
                          Text.Parsec.Prim.Ok x ds ds1 -> x
                          Text.Parsec.Prim.Error err
                          -> AS.Parsing.Out.getMatchesWithContext1 @ t }
                     Text.Parsec.Prim.Empty r
                     -> case r `cast`
                             (Data.Functor.Identity.NTCo:Identity[0]
                                  <Text.Parsec.Prim.Reply
                                       Data.Text.Internal.Text
                                       ()
                                       ([GHC.Base.String], [t])>_R) of wild1 {
                          Text.Parsec.Prim.Ok x ds ds1 -> x
                          Text.Parsec.Prim.Error err
                          -> AS.Parsing.Out.getMatchesWithContext1 @ t } }) -}
ceb41e2ab3f2d9c6b87bcc2fdc8c0fdc
  getMatchesWithContext1 :: ([GHC.Base.String], [t])
    {- Strictness: b -}
75adb0cbca1ad104715b446f3fd024dc
  getMatchesWithContext2 :: Text.Parsec.Pos.SourcePos
    {- HasNoCafRefs,
       Unfolding: (Text.Parsec.Pos.SourcePos
                     (GHC.Types.[] @ GHC.Types.Char)
                     1
                     1) -}
8e8e5c91c90ab8257465755e8880874d
  getMatchesWithContext3 :: GHC.Types.Int
    {- HasNoCafRefs, Unfolding: (GHC.Types.I# 4) -}
39dd9ea2b8c8a2d2dbc6346fdd18fc6e
  getMatchesWithContext4 :: Data.Text.Array.MArray s1
                            -> GHC.Types.Int
                            -> [GHC.Types.Char]
                            -> GHC.Prim.Int#
                            -> GHC.Prim.State# s1
                            -> (# GHC.Prim.State# s1, Data.Text.Internal.Text #)
    {- Arity: 5, Strictness: <L,U(U)><L,U(U)><S,1*U><L,U><L,U> -}
5f6f457200ca570a0b872fb4214b6131
  getMatchesWithContext5 :: Text.Parsec.Text.Parser t
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> (([GHC.Base.String], [t])
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (([GHC.Base.String], [t])
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (\ @ t
                     a4 :: Text.Parsec.Text.Parser t
                     @ b
                     eta :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     eta1 :: ([GHC.Base.String], [t])
                             -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                             -> Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eta2 :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eta3 :: ([GHC.Base.String], [t])
                             -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                             -> Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eta4 :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b ->
                   Text.Parsec.Prim.$wa10
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     @ (GHC.Base.String, t)
                     (\ @ b1
                        s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        cok :: (GHC.Base.String, t)
                               -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1
                        ds :: Text.Parsec.Error.ParseError
                              -> Data.Functor.Identity.Identity b1
                        eok :: (GHC.Base.String, t)
                               -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> Text.Parsec.Error.ParseError
                               -> Data.Functor.Identity.Identity b1
                        eerr :: Text.Parsec.Error.ParseError
                                -> Data.Functor.Identity.Identity b1 ->
                      AS.Parsing.Out.getMatchesWithContext7
                        @ t
                        a4
                        @ b1
                        s1
                        cok
                        eerr
                        eok
                        eerr)
                       `cast`
                     (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                               <Data.Text.Internal.Text>_R
                               <()>_R
                               <Data.Functor.Identity.Identity>_R
                               <(GHC.Base.String, t)>_R))
                     @ b
                     eta
                     (\ x :: [(GHC.Base.String, t)]
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.getMatchesWithContext6
                        @ t
                        x
                        @ b
                        s2
                        eta1
                        eta2
                        (\ x1 :: ([GHC.Base.String], [t])
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eta1 x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eta2 (Text.Parsec.Error.mergeError err err')))
                     eta2
                     (\ x :: [(GHC.Base.String, t)]
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.getMatchesWithContext6
                        @ t
                        x
                        @ b
                        s2
                        eta1
                        eta2
                        (\ x1 :: ([GHC.Base.String], [t])
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eta3 x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eta4 (Text.Parsec.Error.mergeError err err')))) -}
7ebe2313504824ccd7dd89f42c7b02f6
  getMatchesWithContext6 :: [(GHC.Base.String, t)]
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> (([GHC.Base.String], [t])
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (([GHC.Base.String], [t])
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <L,U><L,U(U,U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)> -}
585513ced3eea4e312b40e6b494b78f0
  getMatchesWithContext7 :: Text.Parsec.Text.Parser t
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                               -> ((GHC.Base.String, t)
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> ((GHC.Base.String, t)
                                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                                   -> Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> (Text.Parsec.Error.ParseError
                                   -> Data.Functor.Identity.Identity b)
                               -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
4f400d3f7aace1033036e5b43d6ba094
  getMatchesWithContext8 :: GHC.Base.Monad
                                Data.Functor.Identity.Identity
    {- Unfolding: (GHC.Base.D:Monad
                     @ Data.Functor.Identity.Identity
                     Data.Functor.Identity.$fMonadIdentity_$c>>=
                     (Text.Parsec.Prim.runPT2 @ Data.Functor.Identity.Identity)
                     AS.Parsing.Out.getMatchesWithContext9
                       `cast`
                     (forall a4.
                      <a4>_R ->_R Sym (Data.Functor.Identity.NTCo:Identity[0] <a4>_R))
                     (Text.Parsec.Prim.runPT1 @ Data.Functor.Identity.Identity)) -}
900976c8396d362551dc946c36d5e7d3
  getMatchesWithContext9 :: a -> a
    {- Arity: 1, HasNoCafRefs, Unfolding: (\ @ a4 tpl :: a4 -> tpl) -}
04d790867e8eda97742361fd887a579c
  indexMatch :: Text.Parsec.Text.Parser AS.Types.ExLoc
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.indexMatch1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <AS.Types.ExLoc>_R))) -}
1d00b6a54958bc58028deba124f3fafb
  indexMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> Data.Functor.Identity.Identity b1
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (\ @ b1
                     s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     cok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     cerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1
                     eok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     eerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1 ->
                   AS.Parsing.Out.dollar1
                     @ b1
                     s1
                     (\ x :: GHC.Base.String
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.indexMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         cok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         cerr (Text.Parsec.Error.mergeError err err')))
                     cerr
                     (\ x :: GHC.Base.String
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.indexMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eerr (Text.Parsec.Error.mergeError err err')))
                     eerr) -}
6e9548fa63fabf490a33586a52262191
  indexMatch2 :: GHC.Base.String
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <L,U><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U> -}
9ce715ffe88cc3088d066ceb117a5253
  indexToExcel :: (GHC.Types.Int, GHC.Types.Int) -> GHC.Base.String
    {- Arity: 1, Strictness: <S(SL),1*U(1*U(U),1*U(U))>,
       Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: (GHC.Types.Int, GHC.Types.Int) ->
                   case w of ww { (,) ww1 ww2 ->
                   case ww1 of ww3 { GHC.Types.I# ww4 ->
                   AS.Parsing.Out.$windexToExcel ww4 ww2 } }) -}
5f8159895092510996ffbdcc0eb0e3d6
  intToColStr :: GHC.Types.Int -> GHC.Base.String
    {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: GHC.Types.Int ->
                   case w of ww { GHC.Types.I# ww1 ->
                   AS.Parsing.Out.$wintToColStr ww1 }) -}
d4f37d36f9bd896d7e8b5ddc43a497ce
  jsonDeserialize :: AS.Types.ASLanguage
                     -> GHC.Base.String
                     -> GHC.Base.String
                     -> GHC.Base.String
    {- Arity: 3, Strictness: <S,1*U><L,1*U><L,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage
                     objType :: GHC.Base.String
                     jsonRep :: GHC.Base.String ->
                   case lang of wild {
                     DEFAULT -> AS.Parsing.Out.jsonDeserialize4
                     AS.Types.R
                     -> GHC.Base.++
                          @ GHC.Types.Char
                          objType
                          (GHC.CString.unpackAppendCString#
                             "$("#
                             (GHC.Base.++
                                @ GHC.Types.Char
                                jsonRep
                                AS.Parsing.Out.jsonDeserialize2))
                     AS.Types.Python
                     -> GHC.Base.++
                          @ GHC.Types.Char
                          objType
                          (GHC.CString.unpackAppendCString#
                             ".deserialize("#
                             (GHC.Base.++
                                @ GHC.Types.Char
                                jsonRep
                                AS.Parsing.Out.jsonDeserialize2))
                     AS.Types.OCaml
                     -> GHC.CString.unpackAppendCString#
                          "Serialization# "#
                          (GHC.Base.++
                             @ GHC.Types.Char
                             objType
                             (GHC.Types.:
                                @ GHC.Types.Char
                                AS.Parsing.Out.jsonDeserialize1
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   jsonRep
                                   AS.Parsing.Out.getBlockDelim1)))
                     AS.Types.SQL
                     -> GHC.Base.++
                          @ GHC.Types.Char
                          objType
                          (GHC.CString.unpackAppendCString#
                             ".deserialize("#
                             (GHC.Base.++
                                @ GHC.Types.Char
                                jsonRep
                                AS.Parsing.Out.jsonDeserialize2)) }) -}
34a8e2a81efc7644a57f5e69a1ea02e6
  jsonDeserialize1 :: GHC.Types.Char
    {- HasNoCafRefs, Unfolding: (GHC.Types.C# ' ') -}
af65d7fe30963ed2639f09f227f4449a
  jsonDeserialize2 :: [GHC.Types.Char]
    {- HasNoCafRefs,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.jsonDeserialize3
                     (GHC.Types.[] @ GHC.Types.Char)) -}
dbb5d5342a8e93bafd79f1a34e377d8e
  jsonDeserialize3 :: GHC.Types.Char
    {- HasNoCafRefs, Unfolding: (GHC.Types.C# ')') -}
6d2b24de28bdf99630b626e6b7872284
  jsonDeserialize4 :: GHC.Base.String {- Strictness: b -}
d5eb139460c0dd6fbc979cde07dd23d4
  modifiedLists :: AS.Types.ASLanguage
                   -> GHC.Base.String
                   -> GHC.Base.String
    {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage str :: GHC.Base.String ->
                   case lang of wild {
                     DEFAULT -> str
                     AS.Types.Python
                     -> GHC.CString.unpackAppendCString#
                          "arr("#
                          (GHC.Base.++ @ GHC.Types.Char str AS.Parsing.Out.jsonDeserialize2)
                     AS.Types.Excel
                     -> GHC.CString.unpackAppendCString#
                          "arr("#
                          (GHC.Base.++
                             @ GHC.Types.Char
                             str
                             AS.Parsing.Out.jsonDeserialize2) }) -}
72b03bf6b81e412de884bd1700fc253f
  parseMatches :: Text.Parsec.Text.Parser t
                  -> Text.Parsec.Text.Parser [t]
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
       Unfolding: InlineRule (0, True, True)
                  AS.Parsing.Out.parseMatches1
                    `cast`
                  (forall t.
                   <Text.Parsec.Text.Parser t>_R
                   ->_R Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                 <Data.Text.Internal.Text>_R
                                 <()>_R
                                 <Data.Functor.Identity.Identity>_R
                                 <[t]>_R)) -}
4500c87c3aaa2c448d2ebbf089d6816d
  parseMatches1 :: Text.Parsec.Text.Parser t
                   -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                      -> ([t]
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                      -> (Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                      -> ([t]
                          -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                          -> Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                      -> (Text.Parsec.Error.ParseError
                          -> Data.Functor.Identity.Identity b)
                      -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,A>,
       Inline: INLINE[0],
       Unfolding: InlineRule (6, True, True)
                  (\ @ t
                     w :: Text.Parsec.Text.Parser t
                     @ b
                     w1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     w2 :: [t]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w3 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w4 :: [t]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w5 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                   AS.Parsing.Out.$wa1 @ t w @ b w1 w2 w3 w4) -}
676e298013ff9ca142b1b082ae8cce34
  parseMatchesWithContext :: Text.Parsec.Text.Parser t
                             -> Text.Parsec.Text.Parser ([GHC.Base.String], [t])
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U(U,U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.getMatchesWithContext5
                     `cast`
                   (forall t.
                    <Text.Parsec.Text.Parser t>_R
                    ->_R Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                  <Data.Text.Internal.Text>_R
                                  <()>_R
                                  <Data.Functor.Identity.Identity>_R
                                  <([GHC.Base.String], [t])>_R))) -}
bb1fa579b6ca61da8604a3abb176b7bf
  parseNext :: Text.Parsec.Text.Parser t
               -> Text.Parsec.Text.Parser (GHC.Base.String, t)
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),C(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.getMatchesWithContext7
                     `cast`
                   (forall t.
                    <Text.Parsec.Text.Parser t>_R
                    ->_R Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                  <Data.Text.Internal.Text>_R
                                  <()>_R
                                  <Data.Functor.Identity.Identity>_R
                                  <(GHC.Base.String, t)>_R))) -}
aed54f08e0611eb419f98798b6e947d1
  rangeMatch :: Text.Parsec.Text.Parser AS.Types.ExLoc
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (AS.Parsing.Out.rangeMatch1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <AS.Types.ExLoc>_R))) -}
4a1b689f0c7aea024bb8adaf527c02f9
  rangeMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (AS.Types.ExLoc
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b1)
                 -> Data.Functor.Identity.Identity b1
    {- Arity: 5,
       Strictness: <L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Unfolding: (\ @ b1
                     s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     cok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     cerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1
                     eok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     eerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1 ->
                   AS.Parsing.Out.indexMatch1
                     @ b1
                     s1
                     (\ x :: AS.Types.ExLoc
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.rangeMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         cok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         cerr (Text.Parsec.Error.mergeError err err')))
                     cerr
                     (\ x :: AS.Types.ExLoc
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.rangeMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eerr (Text.Parsec.Error.mergeError err err')))
                     eerr) -}
07b80cef505b5dcd99d4ffdc96a19825
  rangeMatch2 :: AS.Types.ExLoc
                 -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b)
                    -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <L,U><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
efc937eaa950cd7daac838c89238cffe
  replaceMatches :: ([GHC.Base.String], [t])
                    -> (t -> GHC.Base.String)
                    -> GHC.Base.String
                    -> GHC.Base.String
    {- Arity: 3, Strictness: <S(SL),1*U(1*U,1*U)><L,C(U)><L,A>,
       Unfolding: InlineRule (3, True, False)
                  (\ @ t
                     ds :: ([GHC.Base.String], [t])
                     f :: t -> GHC.Base.String
                     target :: GHC.Base.String ->
                   case ds of wild { (,) inter matches ->
                   AS.Parsing.Out.getDependenciesAndExpressions_blend
                     inter
                     (GHC.Base.build
                        @ [GHC.Types.Char]
                        (\ @ b1 c :: [GHC.Types.Char] -> b1 -> b1 n :: b1 ->
                         GHC.Base.foldr
                           @ t
                           @ b1
                           (GHC.Base.mapFB @ [GHC.Types.Char] @ b1 @ t c f)
                           n
                           matches)) }) -}
de938fc3c3e53a9dcf634dfe1b3422f6
  sheetMatch :: Text.Parsec.Text.Parser GHC.Base.String
    {- Arity: 5,
       Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (AS.Parsing.Out.sheetMatch1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Types.Char]>_R))) -}
1ebccaaa51edea1e0c7f2a63ab946698
  sheetMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> ([GHC.Types.Char]
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> ([GHC.Types.Char]
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (\ @ b
                     w2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     w3 :: [GHC.Types.Char]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w5 :: [GHC.Types.Char]
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w6 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                   Text.Parsec.Combinator.$wa11
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     @ GHC.Types.Char
                     @ GHC.Types.Char
                     AS.Parsing.Out.sheetMatch2
                       `cast`
                     (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                               <Data.Text.Internal.Text>_R
                               <()>_R
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Char>_R))
                     @ b
                     w2
                     w3
                     w4
                     w5
                     w6) -}
0854a45536640464a8e265289132ec4f
  sheetMatch2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                 -> (GHC.Types.Char
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (GHC.Types.Char
                     -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     -> Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> (Text.Parsec.Error.ParseError
                     -> Data.Functor.Identity.Identity b)
                 -> Data.Functor.Identity.Identity b
    {- Arity: 5,
       Strictness: <S(SSS),1*U(U(U,U,U),U(U,U,U),U)><L,U><L,U><L,C(C1(C1(U)))><L,C(U)>,
       Inline: INLINE[0],
       Unfolding: InlineRule (5, True, False)
                  (\ @ b
                     w :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     w1 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w2 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w3 :: GHC.Types.Char
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b
                     w4 :: Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b ->
                   case w of ww { Text.Parsec.Prim.State ww1 ww2 ww3 ->
                   case ww1 of ww4 { Data.Text.Internal.Text ww5 ww6 ww7 ->
                   case ww2 of ww8 { Text.Parsec.Pos.SourcePos ww9 ww10 ww11 ->
                   AS.Parsing.Out.$wa2
                     @ b
                     ww5
                     ww6
                     ww7
                     ww9
                     ww10
                     ww11
                     ww3
                     w1
                     w2
                     w3
                     w4 } } }) -}
259c8db5781acf203ed068235b3ebbd5
  sheetRefMatch :: Text.Parsec.Text.Parser AS.Types.ExLoc
    {- Arity: 5,
       Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (AS.Parsing.Out.sheetRefMatch1
                     `cast`
                   (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                             <Data.Text.Internal.Text>_R
                             <()>_R
                             <Data.Functor.Identity.Identity>_R
                             <AS.Types.ExLoc>_R))) -}
0cb1e8db62b2a8cc699a37cb82824c58
  sheetRefMatch1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b1)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b1)
                    -> (AS.Types.ExLoc
                        -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        -> Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b1)
                    -> (Text.Parsec.Error.ParseError
                        -> Data.Functor.Identity.Identity b1)
                    -> Data.Functor.Identity.Identity b1
    {- Arity: 5,
       Strictness: <L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (\ @ b1
                     s1 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     cok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     cerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1
                     eok :: AS.Types.ExLoc
                            -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                            -> Text.Parsec.Error.ParseError
                            -> Data.Functor.Identity.Identity b1
                     eerr :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b1 ->
                   Text.Parsec.Combinator.$wa11
                     @ Data.Text.Internal.Text
                     @ ()
                     @ Data.Functor.Identity.Identity
                     @ GHC.Types.Char
                     @ GHC.Types.Char
                     AS.Parsing.Out.sheetMatch2
                       `cast`
                     (Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                               <Data.Text.Internal.Text>_R
                               <()>_R
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Char>_R))
                     @ b1
                     s1
                     (\ x :: GHC.Base.String
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.sheetRefMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         cok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         cerr (Text.Parsec.Error.mergeError err err')))
                     cerr
                     (\ x :: GHC.Base.String
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      AS.Parsing.Out.sheetRefMatch2
                        x
                        @ b1
                        s2
                        cok
                        cerr
                        (\ x1 :: AS.Types.ExLoc
                           s3 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           err' :: Text.Parsec.Error.ParseError ->
                         eok x1 s3 (Text.Parsec.Error.mergeError err err'))
                        (\ err' :: Text.Parsec.Error.ParseError ->
                         eerr (Text.Parsec.Error.mergeError err err')))
                     eerr) -}
c1df21fc5e6e9ff55de24583e20c7f1c
  sheetRefMatch2 :: GHC.Base.String
                    -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                       -> (AS.Types.ExLoc
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b)
                       -> (Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b)
                       -> (AS.Types.ExLoc
                           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                           -> Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b)
                       -> (Text.Parsec.Error.ParseError
                           -> Data.Functor.Identity.Identity b)
                       -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <L,U><L,U(U,U(U,U,U),U)><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,C(U)> -}
a98b7ddc2a759cd336050fa0d7b58cf7
  shiftCell :: (GHC.Types.Int, GHC.Types.Int)
               -> AS.Types.ASCell
               -> (AS.Types.ASCell, [AS.Types.ASLocation])
    {- Arity: 2, Strictness: <L,U(U(U),U(U))><S(LSLL),1*U(U,1*U,U,U)>m,
       Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ w :: (GHC.Types.Int, GHC.Types.Int) w1 :: AS.Types.ASCell ->
                   case w1 of ww { AS.Types.Cell ww1 ww2 ww3 ww4 ->
                   case AS.Parsing.Out.$wshiftCell
                          w
                          ww1
                          ww2
                          ww3
                          ww4 of ww5 { (#,#) ww6 ww7 ->
                   (ww6, ww7) } }) -}
b9eb7c5bab3d57c2692adbfb19190b4d
  shiftCell1 :: [(GHC.Types.Int, GHC.Types.Int)]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ (GHC.Types.Int, GHC.Types.Int)
                     AS.Parsing.Out.shiftCell2
                     (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))) -}
9a7511064a2300f6bdb82010f43a514a
  shiftCell2 :: (GHC.Types.Int, GHC.Types.Int)
    {- HasNoCafRefs, Strictness: m,
       Unfolding: ((AS.Parsing.Out.shiftCell3,
                    AS.Parsing.Out.shiftCell3)) -}
5efe923e587bca7f9313228d688e739d
  shiftCell3 :: GHC.Types.Int
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
015ad3475ee00dd598090a1a4e98761c
  shiftCell_go :: [[AS.Types.ASLocation]] -> [AS.Types.ASLocation]
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b5d5634254632289adcd2847825c67e0
  shiftExLoc :: (GHC.Types.Int, GHC.Types.Int)
                -> AS.Types.ExLoc
                -> AS.Types.ExLoc
    {- Arity: 2, Strictness: <L,U(U(U),U(U))><S,1*U> -}
e30ee4477d758fdcad71c78a28d78636
  shiftExLocs :: (GHC.Types.Int, GHC.Types.Int)
                 -> [AS.Types.ExLoc]
                 -> [AS.Types.ExLoc]
    {- Arity: 2, Strictness: <L,U(U(U),U(U))><S,1*U>,
       Unfolding: (\ offset :: (GHC.Types.Int, GHC.Types.Int)
                     exLocs :: [AS.Types.ExLoc] ->
                   GHC.Base.map
                     @ AS.Types.ExLoc
                     @ AS.Types.ExLoc
                     (AS.Parsing.Out.shiftExLoc offset)
                     exLocs) -}
d74e087cc4c3fbf95e2a35b96f634186
  showFilteredValue :: AS.Types.ASLanguage
                       -> AS.Types.ASValue
                       -> GHC.Base.String
    {- Arity: 2, Strictness: <L,U><S,1*U> -}
1bd650b815c69736283a0f2e20347d00
  showValue :: AS.Types.ASLanguage
               -> AS.Types.ASValue
               -> GHC.Base.String
    {- Arity: 2, Strictness: <L,U><S,1*U> -}
7af97889165fd0aef2fce7a5d8161b75
  toListStr :: AS.Types.ASLanguage
               -> [GHC.Base.String]
               -> GHC.Base.String
    {- Arity: 2, Strictness: <S,1*U><L,1*U>,
       Unfolding: (\ lang :: AS.Types.ASLanguage
                     lst :: [GHC.Base.String] ->
                   let {
                     $j :: [GHC.Types.Char]
                           -> [GHC.Types.Char]
                           -> [GHC.Types.Char]
                           -> [GHC.Types.Char]
                       {- Arity: 3, Strictness: <S,1*U><L,U><L,1*U> -}
                     = \ end :: [GHC.Types.Char]
                         delim :: [GHC.Types.Char]
                         start :: [GHC.Types.Char] ->
                       GHC.Base.++
                         @ GHC.Types.Char
                         end
                         (case lst of wild {
                            [] -> start
                            : x xs1
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 (Data.List.intercalate_$spoly_go
                                    @ GHC.Types.Char
                                    x
                                    (Data.List.prependToAll @ [GHC.Types.Char] delim xs1))
                                 start })
                   } in
                   case lang of wild {
                     DEFAULT
                     -> case AS.Parsing.Out.toListStr8 ret_ty [GHC.Types.Char] of {}
                     AS.Types.R
                     -> $j
                          AS.Parsing.Out.toListStr7
                          AS.Parsing.Out.toListStr5
                          AS.Parsing.Out.jsonDeserialize2
                     AS.Types.Python
                     -> $j
                          AS.Parsing.Out.toListStr3
                          AS.Parsing.Out.toListStr5
                          AS.Parsing.Out.toListStr1
                     AS.Types.OCaml
                     -> $j
                          AS.Parsing.Out.toListStr3
                          AS.Parsing.Out.getInlineDelim1
                          AS.Parsing.Out.toListStr1
                     AS.Types.SQL
                     -> $j
                          AS.Parsing.Out.toListStr3
                          AS.Parsing.Out.toListStr5
                          AS.Parsing.Out.toListStr1
                     AS.Types.Excel
                     -> $j
                          AS.Parsing.Out.toListStr3
                          AS.Parsing.Out.toListStr5
                          AS.Parsing.Out.toListStr1 }) -}
9c74ba5c29c3a5dd91d568bcf6813788
  toListStr1 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.toListStr2
                     (GHC.Types.[] @ GHC.Types.Char)) -}
e5b275321e448e42fb2b08053cdffada
  toListStr2 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ']') -}
0e5ecbc1d809fd9c4f5addab3df120a2
  toListStr3 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.toListStr4
                     (GHC.Types.[] @ GHC.Types.Char)) -}
aa63d8fbd0d0fc742ec876f688845f8c
  toListStr4 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '[') -}
da43e05536c5fd583f380185f546440b
  toListStr5 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Out.toListStr6
                     (GHC.Types.[] @ GHC.Types.Char)) -}
9078272afdec3667e52d085296dc8600
  toListStr6 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ',') -}
2e667afca4a395529f764b7e94ad856f
  toListStr7 :: [GHC.Types.Char]
    {- Unfolding: (GHC.CString.unpackCString# "c("#) -}
23a93b15b837af31d9fdb5cd70cbe63d
  toListStr8 :: ([GHC.Types.Char],
                 [GHC.Types.Char],
                 [GHC.Types.Char])
    {- Strictness: b -}
99c544f6cf59142cc76e65f73d1ad15a
  unpackExcelExprs :: AS.Types.ASValue -> [GHC.Base.String]
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ ds :: AS.Types.ASValue ->
                   case ds of wild {
                     DEFAULT -> GHC.Types.[] @ GHC.Base.String
                     AS.Types.ValueL l
                     -> GHC.Base.map
                          @ AS.Types.ASValue
                          @ [GHC.Types.Char]
                          AS.Types.str
                          l }) -}
17d9a08bddf65f1b6550b9537ce4d64c
  unpackExcelLocs :: AS.Types.ASValue
                     -> [(GHC.Types.Int, GHC.Types.Int)]
    {- Arity: 1, Strictness: <S,1*U>,
       Unfolding: (\ ds :: AS.Types.ASValue ->
                   case ds of wild {
                     DEFAULT -> AS.Parsing.Out.unpackExcelLocs3
                     AS.Types.ValueL locs
                     -> GHC.Base.map
                          @ AS.Types.ASValue
                          @ (GHC.Types.Int, GHC.Types.Int)
                          AS.Parsing.Out.unpackExcelLocs1
                          locs }) -}
cb6633bfbe352c47239b695a67df908f
  unpackExcelLocs1 :: AS.Types.ASValue
                      -> (GHC.Types.Int, GHC.Types.Int)
    {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: AS.Types.ASValue ->
                   case AS.Parsing.Out.$wlvl w of ww { (#,#) ww1 ww2 ->
                   (ww1, ww2) }) -}
f542a152c3acfd5054e5247a06971a32
  unpackExcelLocs2 :: AS.Types.ASValue -> GHC.Types.Int
    {- Arity: 1, Strictness: <S,1*U>m,
       Unfolding: InlineRule (1, True, False)
                  (\ x :: AS.Types.ASValue ->
                   case x of wild {
                     DEFAULT -> case AS.Types.dbl1 ret_ty GHC.Types.Int of {}
                     AS.Types.ValueD d
                     -> case d of wild1 { GHC.Types.D# x1 ->
                        let {
                          n :: GHC.Prim.Int# = GHC.Prim.double2Int# x1
                        } in
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.<## x1 (GHC.Prim.int2Double# n)) of wild2 {
                          GHC.Types.False -> GHC.Types.I# n
                          GHC.Types.True -> GHC.Types.I# (GHC.Prim.-# n 1) } } }) -}
54ada1cc80123cfe4c0333d57d787083
  unpackExcelLocs3 :: [(GHC.Types.Int, GHC.Types.Int)]
    {- Strictness: b -}
096782ab92d5f83ea6fcdf0cc2a0066a
  unpackExcelVals :: AS.Types.ASValue -> [AS.Types.ASValue]
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ ds :: AS.Types.ASValue ->
                   case ds of wild {
                     DEFAULT -> GHC.Types.[] @ AS.Types.ASValue
                     AS.Types.ValueL l -> l }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

