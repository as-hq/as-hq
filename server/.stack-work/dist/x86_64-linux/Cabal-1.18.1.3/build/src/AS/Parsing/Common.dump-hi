
==================== FINAL INTERFACE ====================
2015-09-01 19:49:53.909374 UTC

interface alphasheets-0.1.0.0:AS.Parsing.Common 7083
  interface hash: 490e0cddbc869eb708870f9b552e538a
  ABI hash: 1e559d9fa6be58496d3932deb847a914
  export-list hash: 855ca2332aab91a7acb18022ee906c28
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: ab021812461dd929ff0bec16539f2f43
  used TH splices: False
  where
exports:
  AS.Parsing.Common.deleteEmpty
  AS.Parsing.Common.getDelimitedSubstring
  AS.Parsing.Common.getLine
  AS.Parsing.Common.getOffsets
  AS.Parsing.Common.normalizeRanges
  AS.Parsing.Common.rangeDiff
  AS.Parsing.Common.regexList
  AS.Parsing.Common.replaceSubstrings
  AS.Parsing.Common.reshapeColArr
  AS.Parsing.Common.skip
  AS.Parsing.Common.sortStrList
module dependencies: AS.Types AS.Util
package dependencies: SHA-1.6.4.2 aeson-0.8.1.1 array-0.5.0.0
                      attoparsec-0.13.0.1 base base64-bytestring-1.0.0.1 binary-0.7.1.0
                      blaze-builder-0.4.0.1 bytestring-0.10.4.0 case-insensitive-1.2.0.4
                      containers-0.5.5.1 deepseq-1.3.0.2 dlist-0.7.1.1 entropy-0.3.7
                      ghc-prim hashable-1.2.3.3 integer-gmp mtl-2.2.1 network-2.6.2.1
                      parsec-3.1.9 primitive-0.5.2.1 random-1.1 regex-base-0.93.2
                      regex-posix-0.95.2 scientific-0.3.3.8 text-1.2.1.1 time-1.5.0.1
                      transformers-0.4.3.0 unix-2.7.1.0 unordered-containers-0.2.5.1
                      uuid-1.3.10 uuid-types-1.0.1 vector-0.10.9.1 websockets-0.9.5.0
orphans: aeson-0.8.1.1:Data.Aeson.Types.Generic
         aeson-0.8.1.1:Data.Aeson.Types.Instances
         aeson-0.8.1.1:Data.Aeson.Types.Internal
         attoparsec-0.13.0.1:Data.Attoparsec.ByteString.Char8 base:GHC.Base
         base:GHC.Float base:GHC.Real binary-0.7.1.0:Data.Binary.Generic
         bytestring-0.10.4.0:Data.ByteString.Builder
         hashable-1.2.3.3:Data.Hashable.Generic
         network-2.6.2.1:Network.Socket network-2.6.2.1:Network.Socket.Types
         random-1.1:System.Random regex-base-0.93.2:Text.Regex.Base.Context
         regex-posix-0.95.2:Text.Regex.Posix.ByteString
         regex-posix-0.95.2:Text.Regex.Posix.ByteString.Lazy
         regex-posix-0.95.2:Text.Regex.Posix.Sequence
         regex-posix-0.95.2:Text.Regex.Posix.String text-1.2.1.1:Data.Text
         text-1.2.1.1:Data.Text.Lazy text-1.2.1.1:Data.Text.Show
         time-1.5.0.1:Data.Time.Calendar.Gregorian
         time-1.5.0.1:Data.Time.Format.Parse
         time-1.5.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.4.3.0:Control.Monad.Trans.Error
         vector-0.10.9.1:Data.Vector.Fusion.Stream
         vector-0.10.9.1:Data.Vector.Unboxed
family instance modules: alphasheets-0.1.0.0:AS.Types
                         attoparsec-0.13.0.1:Data.Attoparsec.Internal.Types
                         base:Control.Applicative base:Data.Either base:Data.Monoid
                         base:Data.Type.Equality base:GHC.Exts base:GHC.Generics
                         dlist-0.7.1.1:Data.DList primitive-0.5.2.1:Control.Monad.Primitive
                         text-1.2.1.1:Data.Text text-1.2.1.1:Data.Text.Lazy
                         unordered-containers-0.2.5.1:Data.HashMap.Base
                         unordered-containers-0.2.5.1:Data.HashSet
                         uuid-types-1.0.1:Data.UUID.Types.Internal
                         uuid-types-1.0.1:Data.UUID.Types.Internal.Builder
                         vector-0.10.9.1:Data.Vector vector-0.10.9.1:Data.Vector.Primitive
                         vector-0.10.9.1:Data.Vector.Storable
                         vector-0.10.9.1:Data.Vector.Unboxed.Base
import  -/  AS.Types 57177fd753daf2295937f583773f48c2
  exports: 6e42e59e48c9bd8a9ec1e6c5c6514bc2
  ASLocation a0a8734170556a1370de82a1630a4c6d
  Index 30250568e0b81fb3ccdcef5f5512c98a
  Range e6cc6efc98449e1c579d9f9ca07d3cd6
import  -/  AS.Util fcc8b95dc3c2bad9df28c51cf1f39293
  exports: 47ea528d752de70f9f7cc438ef23ed30
  decomposeLocs 66ef07bc6ac89ed196e5675f5fe3a6eb
  every df1be5e7593df247ae94bb0d63bcc510
import  -/  base:Control.Applicative 30b769206cb5c020684e1bda0d7e7dd3
import  -/  base:Data.Char 1ace810ea04187cd227c9ed982bb7d15
import  -/  base:Data.List 0908c8f6208710e0f918cb6f09e882cc
import  -/  base:Data.Maybe 5034d40e23c3a7110309f188001df4ca
import  -/  base:Data.Tuple cac4e06c48274e85317bd3e59867ef5b
import  -/  base:GHC.Base 5d7c5f596f9a4c8a8abd8517c8bcd5dd
import  -/  base:GHC.List 4cff382327e59a5787355ca0a4174450
import  -/  base:GHC.Num 5e7786970581cacc802bf850d458a30b
import  -/  base:GHC.Show cf1a7ff9edb0f41528085aad04d33753
import  -/  base:GHC.Unicode 328b8e1d86fa0b0f8b798c018561e9b0
import  -/  base:Prelude 74043f272d60acec1777d3461cfe5ef4
import  -/  containers-0.5.5.1:Data.Map bee9dbf2f41b2d615c4b071cbb93a29d
import  -/  ghc-prim:GHC.Classes 3e6cbe1e7e80480408cfa8d5450726a0
import  -/  ghc-prim:GHC.Types dcba736fa3dfba12d307ab18354845d2
import  -/  parsec-3.1.9:Text.Parsec 322f8fcdba25896960b8a72a57a6cc03
import  -/  parsec-3.1.9:Text.Parsec.Text cf960375745df33bb92b7c1e8c170e40
import  -/  regex-posix-0.95.2:Text.Regex.Posix 066ef9de084ba63358af29f32a77c093
import  -/  regex-posix-0.95.2:Text.Regex.Posix.Wrap 0661acbe8df7bf49c397afef6751fbf9
import  -/  text-1.2.1.1:Data.Text b3c4fa3023eabdced6a311d2fdbd8c54
import  -/  text-1.2.1.1:Data.Text.Lazy 3b2da0362dc08fb1cde8f1b781e22b58
import  -/  text-1.2.1.1:Data.Text.Show 5e3bc9590794e8c16cd05f65f5a80f3c
83004e657901ae76d3165c1a81eacf63
  $wgetDelimitedSubstring :: GHC.Base.String
                             -> GHC.Base.String
                             -> GHC.Prim.Int#
                             -> GHC.Base.String
    {- Arity: 3, Strictness: <S,1*U><S,1*U><S,U> -}
c5e2cb5f6a9b4ec2d1905fe551a90be5
  $wreshapeColArr :: [a] -> GHC.Prim.Int# -> GHC.Prim.Int# -> [[a]]
    {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
065107e4c1de9a5af0d4c08cc2397fbd
  $wsortStrList :: GHC.Base.String
                   -> GHC.Base.String
                   -> GHC.Types.Ordering
    {- Arity: 2, Strictness: <L,U><L,U>,
       Unfolding: (\ ww :: GHC.Base.String ww1 :: GHC.Base.String ->
                   case GHC.Classes.$fOrd[]_$s$ccompare
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShowChar1
                             (GHC.Show.showLitString
                                (GHC.List.dropWhile @ GHC.Types.Char GHC.Unicode.isUpper ww)
                                AS.Parsing.Common.sortStrList1))
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShowChar1
                             (GHC.Show.showLitString
                                (GHC.List.dropWhile @ GHC.Types.Char GHC.Unicode.isUpper ww1)
                                AS.Parsing.Common.sortStrList1)) of wild {
                     GHC.Types.LT -> GHC.Types.GT
                     GHC.Types.EQ -> GHC.Types.EQ
                     GHC.Types.GT -> GHC.Types.LT }) -}
90792a6f3f24c0efb10a583f45f0153b
  deleteEmpty :: [GHC.Base.String] -> [GHC.Base.String]
    {- Arity: 1,
       Unfolding: (GHC.List.filter
                     @ GHC.Base.String
                     AS.Parsing.Common.deleteEmpty1) -}
bb7026f34080b03c5aed7cd48eb190ad
  deleteEmpty1 :: [GHC.Types.Char] -> GHC.Types.Bool
    {- Arity: 1,
       Unfolding: (GHC.Classes.$fEq[]_$s$c/=
                     (GHC.Types.[] @ GHC.Types.Char)) -}
7897c0e26d3f7f8f31bc3915619d7581
  getDelimitedSubstring :: GHC.Base.String
                           -> GHC.Base.String
                           -> GHC.Types.Int
                           -> GHC.Base.String
    {- Arity: 3, Strictness: <S,1*U><S,1*U><S(S),1*U(U)>,
       Inline: INLINE[0],
       Unfolding: InlineRule (3, True, False)
                  (\ w :: GHC.Base.String
                     w1 :: GHC.Base.String
                     w2 :: GHC.Types.Int ->
                   case w2 of ww { GHC.Types.I# ww1 ->
                   AS.Parsing.Common.$wgetDelimitedSubstring w w1 ww1 }) -}
08e9df8df1b50c0baeab1ecc8af8cd9f
  getLine :: GHC.Base.String -> GHC.Types.Int -> GHC.Base.String
    {- Arity: 2, Strictness: <S,1*U><S(S),1*U(U)>,
       Unfolding: InlineRule (2, True, False)
                  (\ str :: GHC.Base.String n :: GHC.Types.Int ->
                   AS.Parsing.Common.getDelimitedSubstring
                     str
                     AS.Parsing.Common.getLine1
                     n) -}
94bfa8a4d6bf15410f4647e4e25a80f6
  getLine1 :: [GHC.Types.Char]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     AS.Parsing.Common.getLine2
                     (GHC.Types.[] @ GHC.Types.Char)) -}
4ab426007565576e770edcedddccd253
  getLine2 :: GHC.Types.Char
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '\n') -}
c2e46fda1fccdf9f264f73cf501fffee
  getOffsets :: AS.Types.ASLocation
                -> [(GHC.Types.Int, GHC.Types.Int)]
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ loc :: AS.Types.ASLocation ->
                   case loc of wild {
                     AS.Types.Index ds ds1 -> AS.Parsing.Common.getOffsets1
                     AS.Types.Range ds ds1
                     -> case ds1 of wild1 { (,) ds2 ds3 ->
                        case ds2 of wild2 { (,) a b ->
                        case ds3 of wild3 { (,) c d ->
                        case c of wild4 { GHC.Types.I# x ->
                        case a of wild5 { GHC.Types.I# y ->
                        let {
                          y1 :: GHC.Prim.Int# = GHC.Prim.-# x y
                        } in
                        case GHC.Prim.tagToEnum#
                               @ GHC.Types.Bool
                               (GHC.Prim.># 0 y1) of wild6 {
                          GHC.Types.False
                          -> let {
                               lvl13 :: [GHC.Types.Int]
                               = case d of wild7 { GHC.Types.I# x1 ->
                                 case b of wild8 { GHC.Types.I# y2 ->
                                 GHC.Enum.eftInt 0 (GHC.Prim.-# x1 y2) } }
                             } in
                             letrec {
                               go :: GHC.Prim.Int# -> [(GHC.Types.Int, GHC.Types.Int)]
                                 {- Arity: 1, Strictness: <L,U> -}
                               = \ x1 :: GHC.Prim.Int# ->
                                 let {
                                   z :: [(GHC.Types.Int, GHC.Types.Int)]
                                   = case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# x1 y1) of wild7 {
                                       GHC.Types.False -> go (GHC.Prim.+# x1 1)
                                       GHC.Types.True
                                       -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int) }
                                 } in
                                 let {
                                   ds4 :: GHC.Types.Int {- Strictness: m -} = GHC.Types.I# x1
                                 } in
                                 letrec {
                                   go1 :: [GHC.Types.Int] -> [(GHC.Types.Int, GHC.Types.Int)]
                                     {- Arity: 1, Strictness: <S,1*U> -}
                                   = \ ds5 :: [GHC.Types.Int] ->
                                     case ds5 of wild7 {
                                       [] -> z
                                       : y2 ys
                                       -> GHC.Types.:
                                            @ (GHC.Types.Int, GHC.Types.Int)
                                            (ds4, y2)
                                            (go1 ys) }
                                 } in
                                 go1 lvl13
                             } in
                             go 0
                          GHC.Types.True
                          -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int) } } } } } } }) -}
8627a583383309c07451e17f9dddfcd0
  getOffsets1 :: [(GHC.Types.Int, GHC.Types.Int)]
    {- HasNoCafRefs, Strictness: m2,
       Unfolding: (GHC.Types.:
                     @ (GHC.Types.Int, GHC.Types.Int)
                     AS.Parsing.Common.getOffsets2
                     (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))) -}
273e7186a381f46b5d17464bfb4c9171
  getOffsets2 :: (GHC.Types.Int, GHC.Types.Int)
    {- HasNoCafRefs, Strictness: m,
       Unfolding: ((AS.Parsing.Common.getOffsets3,
                    AS.Parsing.Common.getOffsets3)) -}
cd6418b0b3ce310f4c29b4a399131a8c
  getOffsets3 :: GHC.Types.Int
    {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
b7769fd94e0ab2197814adc9b8966a28
  normalizeRanges :: [AS.Types.ASLocation] -> [AS.Types.ASLocation]
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
       Unfolding: (\ locs :: [AS.Types.ASLocation] ->
                   AS.Parsing.Common.normalizeRanges_go locs) -}
3a88d434a045112648cceb7585a0f109
  normalizeRanges_go :: [AS.Types.ASLocation]
                        -> [AS.Types.ASLocation]
    {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
38e81e67a63d7c298f7f14df784a5756
  rangeDiff :: ((GHC.Types.Int, GHC.Types.Int),
                (GHC.Types.Int, GHC.Types.Int))
               -> (GHC.Types.Int, GHC.Types.Int)
    {- Arity: 1, HasNoCafRefs,
       Strictness: <S,1*U(U(1*U(U),1*U(U)),U(1*U(U),1*U(U)))>m,
       Inline: INLINE[0],
       Unfolding: InlineRule (1, True, False)
                  (\ w :: ((GHC.Types.Int, GHC.Types.Int),
                           (GHC.Types.Int, GHC.Types.Int)) ->
                   case w of ww { (,) ww1 ww2 ->
                   (case ww2 of wild { (,) x ds1 ->
                    case x of wild1 { GHC.Types.I# x1 ->
                    case ww1 of wild2 { (,) x2 ds2 ->
                    case x2 of wild3 { GHC.Types.I# y ->
                    GHC.Types.I# (GHC.Prim.+# (GHC.Prim.-# x1 y) 1) } } } },
                    case ww2 of wild { (,) ds1 y ->
                    case y of wild1 { GHC.Types.I# x ->
                    case ww1 of wild2 { (,) ds2 y1 ->
                    case y1 of wild3 { GHC.Types.I# y2 ->
                    GHC.Types.I# (GHC.Prim.+# (GHC.Prim.-# x y2) 1) } } } }) }) -}
423d997a2450a2fefad1ff44a456e2fd
  regexList :: GHC.Base.String
               -> GHC.Base.String
               -> [GHC.Base.String]
    {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
8848774ecf4804a2083b49a660e4dff1
  replaceSubstrings :: GHC.Base.String
                       -> [(GHC.Base.String, GHC.Base.String)]
                       -> GHC.Base.String
    {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
7541cc3718e7b6a2b064b3b231aa0183
  reshapeColArr :: [a] -> (GHC.Types.Int, GHC.Types.Int) -> [[a]]
    {- Arity: 2, Strictness: <S,1*U><S(SS),1*U(1*U(U),1*U(U))>,
       Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ @ a w :: [a] w1 :: (GHC.Types.Int, GHC.Types.Int) ->
                   case w1 of ww { (,) ww1 ww2 ->
                   case ww1 of ww3 { GHC.Types.I# ww4 ->
                   case ww2 of ww5 { GHC.Types.I# ww6 ->
                   AS.Parsing.Common.$wreshapeColArr @ a w ww4 ww6 } } }) -}
ec72fca9002c558b9355e8d8c805042d
  skip :: Text.Parsec.Text.Parser a
          -> Text.Parsec.Text.Parser GHC.Base.String
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (AS.Parsing.Common.skip1
                     `cast`
                   (forall a.
                    <Text.Parsec.Text.Parser a>_R
                    ->_R Sym (Text.Parsec.Prim.NTCo:ParsecT[0]
                                  <Data.Text.Internal.Text>_R
                                  <()>_R
                                  <Data.Functor.Identity.Identity>_R
                                  <GHC.Base.String>_R))) -}
d9cf257d173d6ef3f83b025a24183701
  skip1 :: Text.Parsec.Text.Parser a
           -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
              -> (GHC.Base.String
                  -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                  -> Text.Parsec.Error.ParseError
                  -> Data.Functor.Identity.Identity b)
              -> (Text.Parsec.Error.ParseError
                  -> Data.Functor.Identity.Identity b)
              -> (GHC.Base.String
                  -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                  -> Text.Parsec.Error.ParseError
                  -> Data.Functor.Identity.Identity b)
              -> (Text.Parsec.Error.ParseError
                  -> Data.Functor.Identity.Identity b)
              -> Data.Functor.Identity.Identity b
    {- Arity: 6,
       Strictness: <C(C(C(C(C(S))))),1*C1(C1(C1(C1(C1(U)))))><L,U><L,C(C1(C1(U)))><L,U><L,C(C1(C1(U)))><L,U>,
       Unfolding: (\ @ a
                     p :: Text.Parsec.Text.Parser a
                     @ b
                     eta :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                     eta1 :: GHC.Base.String
                             -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                             -> Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eta2 :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eta3 :: GHC.Base.String
                             -> Text.Parsec.Prim.State Data.Text.Internal.Text ()
                             -> Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b
                     eta4 :: Text.Parsec.Error.ParseError
                             -> Data.Functor.Identity.Identity b ->
                   p `cast`
                   (Text.Parsec.Prim.NTCo:ParsecT[0]
                        <Data.Text.Internal.Text>_R
                        <()>_R
                        <Data.Functor.Identity.Identity>_R
                        <a>_R)
                     @ b
                     eta
                     (\ x :: a
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      eta1
                        (GHC.Types.[] @ GHC.Types.Char)
                        s2
                        (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                         case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                         case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                         case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                         case Text.Parsec.Error.$wmergeError
                                ww4
                                ww5
                                ww6
                                ww2
                                ww11
                                ww12
                                ww13
                                (GHC.Types.[]
                                   @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                         Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                     eta2
                     (\ x :: a
                        s2 :: Text.Parsec.Prim.State Data.Text.Internal.Text ()
                        err :: Text.Parsec.Error.ParseError ->
                      eta3
                        (GHC.Types.[] @ GHC.Types.Char)
                        s2
                        (case s2 of wild { Text.Parsec.Prim.State ds3 ds4 ds5 ->
                         case ds4 of ww10 { Text.Parsec.Pos.SourcePos ww11 ww12 ww13 ->
                         case err of ww { Text.Parsec.Error.ParseError ww1 ww2 ->
                         case ww1 of ww3 { Text.Parsec.Pos.SourcePos ww4 ww5 ww6 ->
                         case Text.Parsec.Error.$wmergeError
                                ww4
                                ww5
                                ww6
                                ww2
                                ww11
                                ww12
                                ww13
                                (GHC.Types.[]
                                   @ Text.Parsec.Error.Message) of ww14 { (#,#) ww15 ww16 ->
                         Text.Parsec.Error.ParseError ww15 ww16 } } } } }))
                     eta4) -}
cf78d2e4f49c8d9e0cb80c832953af34
  sortStrList :: (GHC.Base.String, GHC.Base.String)
                 -> (GHC.Base.String, GHC.Base.String)
                 -> GHC.Types.Ordering
    {- Arity: 2, Strictness: <S,1*U(U,A)><S,1*U(U,A)>,
       Inline: INLINE[0],
       Unfolding: InlineRule (2, True, False)
                  (\ w :: (GHC.Base.String, GHC.Base.String)
                     w1 :: (GHC.Base.String, GHC.Base.String) ->
                   case w of ww { (,) ww1 ww2 ->
                   case w1 of ww3 { (,) ww4 ww5 ->
                   AS.Parsing.Common.$wsortStrList ww1 ww4 } }) -}
f2fb564798fa41525bc958aeda292c11
  sortStrList1 :: [GHC.Types.Char]
    {- HasNoCafRefs,
       Unfolding: (GHC.Types.:
                     @ GHC.Types.Char
                     GHC.Show.$fShowChar1
                     (GHC.Types.[] @ GHC.Types.Char)) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

